// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use derive_builder::Builder;
#[allow(unused_imports)]
use parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::id_tree::Tree;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait SkillGrammarTrait<'t> {
    /// Semantic action for non-terminal 'SkillLines'
    fn skill_lines(&mut self, _arg: &SkillLines<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Line'
    fn line(&mut self, _arg: &Line<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GroupOfDropChange'
    fn group_of_drop_change(&mut self, _arg: &GroupOfDropChange<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ChangeDropWithDropUnlockLine'
    fn change_drop_with_drop_unlock_line(
        &mut self,
        _arg: &ChangeDropWithDropUnlockLine<'t>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StartsWithDropLine'
    fn starts_with_drop_line(&mut self, _arg: &StartsWithDropLine<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenRandomDropStmt'
    fn gen_random_drop_stmt(&mut self, _arg: &GenRandomDropStmt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenRandomDropBlock'
    fn gen_random_drop_block(&mut self, _arg: &GenRandomDropBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenShapeStmt'
    fn gen_shape_stmt(&mut self, _arg: &GenShapeStmt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DropRefreshStmt'
    fn drop_refresh_stmt(&mut self, _arg: &DropRefreshStmt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DropUnLockStmt'
    fn drop_un_lock_stmt(&mut self, _arg: &DropUnLockStmt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TurnsOfApplyStmt'
    fn turns_of_apply_stmt(&mut self, _arg: &TurnsOfApplyStmt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ChangeDropBlockOtherFirst'
    fn change_drop_block_other_first(
        &mut self,
        _arg: &ChangeDropBlockOtherFirst<'t>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenShapeBlock'
    fn gen_shape_block(&mut self, _arg: &GenShapeBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenShapeBlockRowCol'
    fn gen_shape_block_row_col(&mut self, _arg: &GenShapeBlockRowCol<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenShapeBlockOtherRowCol'
    fn gen_shape_block_other_row_col(&mut self, _arg: &GenShapeBlockOtherRowCol<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GSStartPosition'
    fn g_s_start_position(&mut self, _arg: &GSStartPosition<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GSSPSide'
    fn g_s_s_p_side(&mut self, _arg: &GSSPSide<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GSSPCenter'
    fn g_s_s_p_center(&mut self, _arg: &GSSPCenter<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GSSPCenterBlocks'
    fn g_s_s_p_center_blocks(&mut self, _arg: &GSSPCenterBlocks<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GSSPCenterBlock'
    fn g_s_s_p_center_block(&mut self, _arg: &GSSPCenterBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Position'
    fn position(&mut self, _arg: &Position<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GSSPSideWriteWidth'
    fn g_s_s_p_side_write_width(&mut self, _arg: &GSSPSideWriteWidth<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PositionLRTB'
    fn position_l_r_t_b(&mut self, _arg: &PositionLRTB<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PositionLR'
    fn position_l_r(&mut self, _arg: &PositionLR<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PositionTB'
    fn position_t_b(&mut self, _arg: &PositionTB<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PositionTOrB'
    fn position_t_or_b(&mut self, _arg: &PositionTOrB<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenShapeNumOfGen'
    fn gen_shape_num_of_gen(&mut self, _arg: &GenShapeNumOfGen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeType'
    fn shape_type(&mut self, _arg: &ShapeType<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DropUnlockBlock'
    fn drop_unlock_block(&mut self, _arg: &DropUnlockBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Drops'
    fn drops(&mut self, _arg: &Drops<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ManyDrop'
    fn many_drop(&mut self, _arg: &ManyDrop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllDrops'
    fn all_drops(&mut self, _arg: &AllDrops<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FiveAttribute'
    fn five_attribute(&mut self, _arg: &FiveAttribute<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Quantity'
    fn quantity(&mut self, _arg: &Quantity<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Drop'
    fn drop(&mut self, _arg: &Drop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NonColoredDrop'
    fn non_colored_drop(&mut self, _arg: &NonColoredDrop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Color'
    fn color(&mut self, _arg: &Color<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RandomSuffix'
    fn random_suffix(&mut self, _arg: &RandomSuffix<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Size'
    fn size(&mut self, _arg: &Size<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OnBoard'
    fn on_board(&mut self, _arg: &OnBoard<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Turns'
    fn turns(&mut self, _arg: &Turns<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TurnsOfApplyBlock'
    fn turns_of_apply_block(&mut self, _arg: &TurnsOfApplyBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DropsEasierToFalloff'
    fn drops_easier_to_falloff(&mut self, _arg: &DropsEasierToFalloff<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SkillVolumeVariation'
    fn skill_volume_variation(&mut self, _arg: &SkillVolumeVariation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Fire'
    fn fire(&mut self, _arg: &Fire<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Water'
    fn water(&mut self, _arg: &Water<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Wood'
    fn wood(&mut self, _arg: &Wood<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Lightning'
    fn lightning(&mut self, _arg: &Lightning<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dark'
    fn dark(&mut self, _arg: &Dark<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Recovery'
    fn recovery(&mut self, _arg: &Recovery<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Disturb'
    fn disturb(&mut self, _arg: &Disturb<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bomb'
    fn bomb(&mut self, _arg: &Bomb<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DeadlyPoison'
    fn deadly_poison(&mut self, _arg: &DeadlyPoison<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Poison'
    fn poison(&mut self, _arg: &Poison<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfL'
    fn shape_of_l(&mut self, _arg: &ShapeOfL<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfZ'
    fn shape_of_z(&mut self, _arg: &ShapeOfZ<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfCross'
    fn shape_of_cross(&mut self, _arg: &ShapeOfCross<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfSquare'
    fn shape_of_square(&mut self, _arg: &ShapeOfSquare<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfBoardPerimeter'
    fn shape_of_board_perimeter(&mut self, _arg: &ShapeOfBoardPerimeter<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfBoardCenter'
    fn shape_of_board_center(&mut self, _arg: &ShapeOfBoardCenter<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfBoardTop'
    fn shape_of_board_top(&mut self, _arg: &ShapeOfBoardTop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfBoardBottom'
    fn shape_of_board_bottom(&mut self, _arg: &ShapeOfBoardBottom<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfBoardCorners'
    fn shape_of_board_corners(&mut self, _arg: &ShapeOfBoardCorners<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfSpiderweb'
    fn shape_of_spiderweb(&mut self, _arg: &ShapeOfSpiderweb<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfCrescentMoon'
    fn shape_of_crescent_moon(&mut self, _arg: &ShapeOfCrescentMoon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfOblique'
    fn shape_of_oblique(&mut self, _arg: &ShapeOfOblique<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ShapeOfSomeKind'
    fn shape_of_some_kind(&mut self, _arg: &ShapeOfSomeKind<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordChange'
    fn word_change(&mut self, _arg: &WordChange<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordDrop'
    fn word_drop(&mut self, _arg: &WordDrop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordAll'
    fn word_all(&mut self, _arg: &WordAll<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordFiveAttribute'
    fn word_five_attribute(&mut self, _arg: &WordFiveAttribute<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordRandom'
    fn word_random(&mut self, _arg: &WordRandom<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordReplace'
    fn word_replace(&mut self, _arg: &WordReplace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordCount'
    fn word_count(&mut self, _arg: &WordCount<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordGen'
    fn word_gen(&mut self, _arg: &WordGen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordOther'
    fn word_other(&mut self, _arg: &WordOther<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordVertical'
    fn word_vertical(&mut self, _arg: &WordVertical<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordHorizon'
    fn word_horizon(&mut self, _arg: &WordHorizon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordRow'
    fn word_row(&mut self, _arg: &WordRow<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordCol'
    fn word_col(&mut self, _arg: &WordCol<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordSide'
    fn word_side(&mut self, _arg: &WordSide<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordLeftAndRight'
    fn word_left_and_right(&mut self, _arg: &WordLeftAndRight<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordLeft'
    fn word_left(&mut self, _arg: &WordLeft<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordRight'
    fn word_right(&mut self, _arg: &WordRight<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordTop'
    fn word_top(&mut self, _arg: &WordTop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordBottom'
    fn word_bottom(&mut self, _arg: &WordBottom<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordMost'
    fn word_most(&mut self, _arg: &WordMost<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordLook'
    fn word_look(&mut self, _arg: &WordLook<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordBoard'
    fn word_board(&mut self, _arg: &WordBoard<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordRelease'
    fn word_release(&mut self, _arg: &WordRelease<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordLock'
    fn word_lock(&mut self, _arg: &WordLock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordState'
    fn word_state(&mut self, _arg: &WordState<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordPowerUp'
    fn word_power_up(&mut self, _arg: &WordPowerUp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordTurn'
    fn word_turn(&mut self, _arg: &WordTurn<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordBetween'
    fn word_between(&mut self, _arg: &WordBetween<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordLittleMore'
    fn word_little_more(&mut self, _arg: &WordLittleMore<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordLittle'
    fn word_little(&mut self, _arg: &WordLittle<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordOnly'
    fn word_only(&mut self, _arg: &WordOnly<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordFalloff'
    fn word_falloff(&mut self, _arg: &WordFalloff<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordFall'
    fn word_fall(&mut self, _arg: &WordFall<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Wo'
    fn wo(&mut self, _arg: &Wo<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ni'
    fn ni(&mut self, _arg: &Ni<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'No'
    fn no(&mut self, _arg: &No<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'So'
    fn so(&mut self, _arg: &So<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'And'
    fn and(&mut self, _arg: &And<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Si'
    fn si(&mut self, _arg: &Si<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ga'
    fn ga(&mut self, _arg: &Ga<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Each'
    fn each(&mut self, _arg: &Each<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'From'
    fn from(&mut self, _arg: &From<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Multi'
    fn multi(&mut self, _arg: &Multi<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Camma'
    fn camma(&mut self, _arg: &Camma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Period'
    fn period(&mut self, _arg: &Period<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PosInt'
    fn pos_int(&mut self, _arg: &PosInt<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 1
///
/// Line: GroupOfDropChange;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct LineGroupOfDropChange<'t> {
    pub group_of_drop_change: Box<GroupOfDropChange<'t>>,
}

///
/// Type derived for production 2
///
/// Line: DropRefreshStmt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct LineDropRefreshStmt<'t> {
    pub drop_refresh_stmt: Box<DropRefreshStmt<'t>>,
}

///
/// Type derived for production 3
///
/// Line: DropUnLockStmt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct LineDropUnLockStmt<'t> {
    pub drop_un_lock_stmt: Box<DropUnLockStmt<'t>>,
}

///
/// Type derived for production 4
///
/// Line: TurnsOfApplyStmt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct LineTurnsOfApplyStmt<'t> {
    pub turns_of_apply_stmt: Box<TurnsOfApplyStmt<'t>>,
}

///
/// Type derived for production 5
///
/// GroupOfDropChange: GroupOfDropChangeOpt /* Option */ GroupOfDropChangeOpt0 /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GroupOfDropChangeGroupOfDropChangeOptGroupOfDropChangeOpt0<'t> {
    pub group_of_drop_change_opt: Option<Box<GroupOfDropChangeOpt<'t>>>,
    pub group_of_drop_change_opt0: Option<Box<GroupOfDropChangeOpt0<'t>>>,
}

///
/// Type derived for production 6
///
/// GroupOfDropChange: ChangeDropWithDropUnlockLine;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GroupOfDropChangeChangeDropWithDropUnlockLine<'t> {
    pub change_drop_with_drop_unlock_line: Box<ChangeDropWithDropUnlockLine<'t>>,
}

///
/// Type derived for production 8
///
/// GroupOfDropChangeOpt0Group: StartsWithDropLine;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GroupOfDropChangeOpt0GroupStartsWithDropLine<'t> {
    pub starts_with_drop_line: Box<StartsWithDropLine<'t>>,
}

///
/// Type derived for production 9
///
/// GroupOfDropChangeOpt0Group: GenRandomDropStmt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GroupOfDropChangeOpt0GroupGenRandomDropStmt<'t> {
    pub gen_random_drop_stmt: Box<GenRandomDropStmt<'t>>,
}

///
/// Type derived for production 10
///
/// GroupOfDropChangeOpt0Group: GenShapeStmt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GroupOfDropChangeOpt0GroupGenShapeStmt<'t> {
    pub gen_shape_stmt: Box<GenShapeStmt<'t>>,
}

///
/// Type derived for production 16
///
/// ChangeDropWithDropUnlockLineOpt0Group: Drops Ni WordChange ChangeDropWithDropUnlockLineOpt1 /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropWithDropUnlockLineOpt0GroupDropsNiWordChangeChangeDropWithDropUnlockLineOpt1<
    't,
> {
    pub drops: Box<Drops<'t>>,
    pub ni: Box<Ni<'t>>,
    pub word_change: Box<WordChange<'t>>,
    pub change_drop_with_drop_unlock_line_opt1: Option<Box<ChangeDropWithDropUnlockLineOpt1<'t>>>,
}

///
/// Type derived for production 17
///
/// ChangeDropWithDropUnlockLineOpt0Group: GenShapeStmt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropWithDropUnlockLineOpt0GroupGenShapeStmt<'t> {
    pub gen_shape_stmt: Box<GenShapeStmt<'t>>,
}

///
/// Type derived for production 18
///
/// ChangeDropWithDropUnlockLineOpt0Group: WordPowerUp;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropWithDropUnlockLineOpt0GroupWordPowerUp<'t> {
    pub word_power_up: Box<WordPowerUp<'t>>,
}

///
/// Type derived for production 19
///
/// ChangeDropWithDropUnlockLineOpt0Group: WordLock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropWithDropUnlockLineOpt0GroupWordLock<'t> {
    pub word_lock: Box<WordLock<'t>>,
}

///
/// Type derived for production 24
///
/// ChangeDropWithDropUnlockLineOptGroup: DropUnlockBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropWithDropUnlockLineOptGroupDropUnlockBlock<'t> {
    pub drop_unlock_block: Box<DropUnlockBlock<'t>>,
}

///
/// Type derived for production 25
///
/// ChangeDropWithDropUnlockLineOptGroup: Wo;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropWithDropUnlockLineOptGroupWo<'t> {
    pub wo: Box<Wo<'t>>,
}

///
/// Type derived for production 28
///
/// StartsWithDropLineSuffix0: Wo StartsWithDropLineSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct StartsWithDropLineSuffix0WoStartsWithDropLineSuffix<'t> {
    pub wo: Box<Wo<'t>>,
    pub starts_with_drop_line_suffix: Box<StartsWithDropLineSuffix<'t>>,
}

///
/// Type derived for production 29
///
/// StartsWithDropLineSuffix0: WordOther From GenRandomDropBlock WordGen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct StartsWithDropLineSuffix0WordOtherFromGenRandomDropBlockWordGen<'t> {
    pub word_other: Box<WordOther<'t>>,
    pub from: Box<From<'t>>,
    pub gen_random_drop_block: Box<GenRandomDropBlock<'t>>,
    pub word_gen: Box<WordGen<'t>>,
}

///
/// Type derived for production 30
///
/// StartsWithDropLineSuffix: Drop Ni StartsWithDropLineList /* Vec */ WordChange;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct StartsWithDropLineSuffixDropNiStartsWithDropLineListWordChange<'t> {
    pub drop: Box<Drop<'t>>,
    pub ni: Box<Ni<'t>>,
    pub starts_with_drop_line_list: Vec<StartsWithDropLineList<'t>>,
    pub word_change: Box<WordChange<'t>>,
}

///
/// Type derived for production 31
///
/// StartsWithDropLineSuffix: RandomSuffix Drops Ni WordChange;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct StartsWithDropLineSuffixRandomSuffixDropsNiWordChange<'t> {
    pub random_suffix: Box<RandomSuffix<'t>>,
    pub drops: Box<Drops<'t>>,
    pub ni: Box<Ni<'t>>,
    pub word_change: Box<WordChange<'t>>,
}

///
/// Type derived for production 32
///
/// StartsWithDropLineSuffix: Quantity StartsWithDropLineList0 /* Vec */ WordGen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct StartsWithDropLineSuffixQuantityStartsWithDropLineList0WordGen<'t> {
    pub quantity: Box<Quantity<'t>>,
    pub starts_with_drop_line_list0: Vec<StartsWithDropLineList0<'t>>,
    pub word_gen: Box<WordGen<'t>>,
}

///
/// Type derived for production 33
///
/// StartsWithDropLineSuffix: StartsWithDropLineOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct StartsWithDropLineSuffixStartsWithDropLineOpt<'t> {
    pub starts_with_drop_line_opt: Option<Box<StartsWithDropLineOpt<'t>>>,
}

///
/// Type derived for production 39
///
/// StartsWithDropLineOptGroup: WordPowerUp;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct StartsWithDropLineOptGroupWordPowerUp<'t> {
    pub word_power_up: Box<WordPowerUp<'t>>,
}

///
/// Type derived for production 40
///
/// StartsWithDropLineOptGroup: WordLock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct StartsWithDropLineOptGroupWordLock<'t> {
    pub word_lock: Box<WordLock<'t>>,
}

///
/// Type derived for production 48
///
/// GenShapeStmtOptGroup: WordChange;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeStmtOptGroupWordChange<'t> {
    pub word_change: Box<WordChange<'t>>,
}

///
/// Type derived for production 49
///
/// GenShapeStmtOptGroup: WordGen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeStmtOptGroupWordGen<'t> {
    pub word_gen: Box<WordGen<'t>>,
}

///
/// Type derived for production 55
///
/// GenShapeBlock: GenShapeBlockRowCol GenShapeBlockList /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeBlockGenShapeBlockRowColGenShapeBlockList<'t> {
    pub gen_shape_block_row_col: Box<GenShapeBlockRowCol<'t>>,
    pub gen_shape_block_list: Vec<GenShapeBlockList<'t>>,
}

///
/// Type derived for production 58
///
/// GenShapeBlock: GenShapeBlockOtherRowCol;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeBlockGenShapeBlockOtherRowCol<'t> {
    pub gen_shape_block_other_row_col: Box<GenShapeBlockOtherRowCol<'t>>,
}

///
/// Type derived for production 61
///
/// GenShapeBlockOtherRowColSuffix: Ni Drops Wo GenShapeBlockOtherRowColOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeBlockOtherRowColSuffixNiDropsWoGenShapeBlockOtherRowColOpt<'t> {
    pub ni: Box<Ni<'t>>,
    pub drops: Box<Drops<'t>>,
    pub wo: Box<Wo<'t>>,
    pub gen_shape_block_other_row_col_opt: Option<Box<GenShapeBlockOtherRowColOpt<'t>>>,
}

///
/// Type derived for production 62
///
/// GenShapeBlockOtherRowColSuffix: Wo Drops Ni;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeBlockOtherRowColSuffixWoDropsNi<'t> {
    pub wo: Box<Wo<'t>>,
    pub drops: Box<Drops<'t>>,
    pub ni: Box<Ni<'t>>,
}

///
/// Type derived for production 65
///
/// GSStartPosition: GSSPSide;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSStartPositionGSSPSide<'t> {
    pub g_s_s_p_side: Box<GSSPSide<'t>>,
}

///
/// Type derived for production 66
///
/// GSStartPosition: GSSPCenter;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSStartPositionGSSPCenter<'t> {
    pub g_s_s_p_center: Box<GSSPCenter<'t>>,
}

///
/// Type derived for production 76
///
/// GSSPCenterOpt0Group: WordVertical;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPCenterOpt0GroupWordVertical<'t> {
    pub word_vertical: Box<WordVertical<'t>>,
}

///
/// Type derived for production 77
///
/// GSSPCenterOpt0Group: WordHorizon;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPCenterOpt0GroupWordHorizon<'t> {
    pub word_horizon: Box<WordHorizon<'t>>,
}

///
/// Type derived for production 86
///
/// GSSPCenterBlockOptGroup: WordCol;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPCenterBlockOptGroupWordCol<'t> {
    pub word_col: Box<WordCol<'t>>,
}

///
/// Type derived for production 87
///
/// GSSPCenterBlockOptGroup: WordRow;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPCenterBlockOptGroupWordRow<'t> {
    pub word_row: Box<WordRow<'t>>,
}

///
/// Type derived for production 89
///
/// Position: PositionLR GSSPSideWriteWidth;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionPositionLRGSSPSideWriteWidth<'t> {
    pub position_l_r: Box<PositionLR<'t>>,
    pub g_s_s_p_side_write_width: Box<GSSPSideWriteWidth<'t>>,
}

///
/// Type derived for production 90
///
/// Position: PositionTB;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionPositionTB<'t> {
    pub position_t_b: Box<PositionTB<'t>>,
}

///
/// Type derived for production 91
///
/// GSSPSideWriteWidth: WordSide GSSPSideWriteWidthOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPSideWriteWidthWordSideGSSPSideWriteWidthOpt<'t> {
    pub word_side: Box<WordSide<'t>>,
    pub g_s_s_p_side_write_width_opt: Option<Box<GSSPSideWriteWidthOpt<'t>>>,
}

///
/// Type derived for production 92
///
/// GSSPSideWriteWidth: WordVertical;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPSideWriteWidthWordVertical<'t> {
    pub word_vertical: Box<WordVertical<'t>>,
}

///
/// Type derived for production 95
///
/// PositionLRTB: WordLeft;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionLRTBWordLeft<'t> {
    pub word_left: Box<WordLeft<'t>>,
}

///
/// Type derived for production 96
///
/// PositionLRTB: WordRight;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionLRTBWordRight<'t> {
    pub word_right: Box<WordRight<'t>>,
}

///
/// Type derived for production 97
///
/// PositionLRTB: WordTop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionLRTBWordTop<'t> {
    pub word_top: Box<WordTop<'t>>,
}

///
/// Type derived for production 98
///
/// PositionLRTB: WordBottom;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionLRTBWordBottom<'t> {
    pub word_bottom: Box<WordBottom<'t>>,
}

///
/// Type derived for production 99
///
/// PositionLR: WordLeft;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionLRWordLeft<'t> {
    pub word_left: Box<WordLeft<'t>>,
}

///
/// Type derived for production 100
///
/// PositionLR: WordRight;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionLRWordRight<'t> {
    pub word_right: Box<WordRight<'t>>,
}

///
/// Type derived for production 101
///
/// PositionLR: WordLeftAndRight;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionLRWordLeftAndRight<'t> {
    pub word_left_and_right: Box<WordLeftAndRight<'t>>,
}

///
/// Type derived for production 105
///
/// PositionTOrB: WordTop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionTOrBWordTop<'t> {
    pub word_top: Box<WordTop<'t>>,
}

///
/// Type derived for production 106
///
/// PositionTOrB: WordBottom;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionTOrBWordBottom<'t> {
    pub word_bottom: Box<WordBottom<'t>>,
}

///
/// Type derived for production 108
///
/// ShapeType: ShapeOfL;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeShapeOfL<'t> {
    pub shape_of_l: Box<ShapeOfL<'t>>,
}

///
/// Type derived for production 109
///
/// ShapeType: ShapeTypeOpt /* Option */ ShapeOfZ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeShapeTypeOptShapeOfZ<'t> {
    pub shape_type_opt: Option<Box<ShapeTypeOpt<'t>>>,
    pub shape_of_z: Box<ShapeOfZ<'t>>,
}

///
/// Type derived for production 110
///
/// ShapeType: ShapeOfCross;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeShapeOfCross<'t> {
    pub shape_of_cross: Box<ShapeOfCross<'t>>,
}

///
/// Type derived for production 111
///
/// ShapeType: Size No ShapeOfSquare;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeSizeNoShapeOfSquare<'t> {
    pub size: Box<Size<'t>>,
    pub no: Box<No<'t>>,
    pub shape_of_square: Box<ShapeOfSquare<'t>>,
}

///
/// Type derived for production 112
///
/// ShapeType: ShapeOfBoardPerimeter;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeShapeOfBoardPerimeter<'t> {
    pub shape_of_board_perimeter: Box<ShapeOfBoardPerimeter<'t>>,
}

///
/// Type derived for production 113
///
/// ShapeType: ShapeOfBoardCenter;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeShapeOfBoardCenter<'t> {
    pub shape_of_board_center: Box<ShapeOfBoardCenter<'t>>,
}

///
/// Type derived for production 114
///
/// ShapeType: ShapeOfBoardTop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeShapeOfBoardTop<'t> {
    pub shape_of_board_top: Box<ShapeOfBoardTop<'t>>,
}

///
/// Type derived for production 115
///
/// ShapeType: ShapeOfBoardBottom;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeShapeOfBoardBottom<'t> {
    pub shape_of_board_bottom: Box<ShapeOfBoardBottom<'t>>,
}

///
/// Type derived for production 116
///
/// ShapeType: ShapeOfBoardCorners;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeShapeOfBoardCorners<'t> {
    pub shape_of_board_corners: Box<ShapeOfBoardCorners<'t>>,
}

///
/// Type derived for production 117
///
/// ShapeType: ShapeOfSpiderweb;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeShapeOfSpiderweb<'t> {
    pub shape_of_spiderweb: Box<ShapeOfSpiderweb<'t>>,
}

///
/// Type derived for production 118
///
/// ShapeType: ShapeOfCrescentMoon;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeShapeOfCrescentMoon<'t> {
    pub shape_of_crescent_moon: Box<ShapeOfCrescentMoon<'t>>,
}

///
/// Type derived for production 119
///
/// ShapeType: ShapeTypeOpt0 /* Option */ ShapeOfOblique;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeShapeTypeOpt0ShapeOfOblique<'t> {
    pub shape_type_opt0: Option<Box<ShapeTypeOpt0<'t>>>,
    pub shape_of_oblique: Box<ShapeOfOblique<'t>>,
}

///
/// Type derived for production 120
///
/// ShapeType: PosInt ShapeOfSomeKind;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypePosIntShapeOfSomeKind<'t> {
    pub pos_int: Box<PosInt<'t>>,
    pub shape_of_some_kind: Box<ShapeOfSomeKind<'t>>,
}

///
/// Type derived for production 130
///
/// Drops: Drop DropsSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsDropDropsSuffix<'t> {
    pub drop: Box<Drop<'t>>,
    pub drops_suffix: Box<DropsSuffix<'t>>,
}

///
/// Type derived for production 131
///
/// DropsSuffix: DropsList /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsSuffixDropsList<'t> {
    pub drops_list: Vec<DropsList<'t>>,
}

///
/// Type derived for production 132
///
/// Drops: FiveAttribute DropsList0 /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsFiveAttributeDropsList0<'t> {
    pub five_attribute: Box<FiveAttribute<'t>>,
    pub drops_list0: Vec<DropsList0<'t>>,
}

///
/// Type derived for production 133
///
/// DropsSuffix: And Drop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsSuffixAndDrop<'t> {
    pub and: Box<And<'t>>,
    pub drop: Box<Drop<'t>>,
}

///
/// Type derived for production 138
///
/// ManyDrop: Camma Drop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ManyDropCammaDrop<'t> {
    pub camma: Box<Camma<'t>>,
    pub drop: Box<Drop<'t>>,
}

///
/// Type derived for production 139
///
/// ManyDrop: Plus Drop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ManyDropPlusDrop<'t> {
    pub plus: Box<Plus<'t>>,
    pub drop: Box<Drop<'t>>,
}

///
/// Type derived for production 147
///
/// Drop: Color DropOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropColorDropOpt<'t> {
    pub color: Box<Color<'t>>,
    pub drop_opt: Option<Box<DropOpt<'t>>>,
}

///
/// Type derived for production 148
///
/// Drop: NonColoredDrop DropOpt0 /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropNonColoredDropDropOpt0<'t> {
    pub non_colored_drop: Box<NonColoredDrop<'t>>,
    pub drop_opt0: Option<Box<DropOpt0<'t>>>,
}

///
/// Type derived for production 153
///
/// NonColoredDrop: Recovery;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropRecovery<'t> {
    pub recovery: Box<Recovery<'t>>,
}

///
/// Type derived for production 154
///
/// NonColoredDrop: Disturb;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropDisturb<'t> {
    pub disturb: Box<Disturb<'t>>,
}

///
/// Type derived for production 155
///
/// NonColoredDrop: Bomb;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropBomb<'t> {
    pub bomb: Box<Bomb<'t>>,
}

///
/// Type derived for production 156
///
/// NonColoredDrop: Poison;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropPoison<'t> {
    pub poison: Box<Poison<'t>>,
}

///
/// Type derived for production 157
///
/// NonColoredDrop: DeadlyPoison;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropDeadlyPoison<'t> {
    pub deadly_poison: Box<DeadlyPoison<'t>>,
}

///
/// Type derived for production 158
///
/// Color: Fire;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorFire<'t> {
    pub fire: Box<Fire<'t>>,
}

///
/// Type derived for production 159
///
/// Color: Water;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorWater<'t> {
    pub water: Box<Water<'t>>,
}

///
/// Type derived for production 160
///
/// Color: Wood;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorWood<'t> {
    pub wood: Box<Wood<'t>>,
}

///
/// Type derived for production 161
///
/// Color: Lightning;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorLightning<'t> {
    pub lightning: Box<Lightning<'t>>,
}

///
/// Type derived for production 162
///
/// Color: Dark;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorDark<'t> {
    pub dark: Box<Dark<'t>>,
}

///
/// Type derived for production 170
///
/// DropsEasierToFalloffOpt1Group: WordFalloff;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsEasierToFalloffOpt1GroupWordFalloff<'t> {
    pub word_falloff: Box<WordFalloff<'t>>,
}

///
/// Type derived for production 171
///
/// DropsEasierToFalloffOpt1Group: WordFall;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsEasierToFalloffOpt1GroupWordFall<'t> {
    pub word_fall: Box<WordFall<'t>>,
}

///
/// Type derived for production 177
///
/// SkillVolumeVariation: WordLittleMore;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct SkillVolumeVariationWordLittleMore<'t> {
    pub word_little_more: Box<WordLittleMore<'t>>,
}

///
/// Type derived for production 178
///
/// SkillVolumeVariation: WordLittle;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct SkillVolumeVariationWordLittle<'t> {
    pub word_little: Box<WordLittle<'t>>,
}

///
/// Type derived for production 179
///
/// SkillVolumeVariation: WordOnly;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct SkillVolumeVariationWordOnly<'t> {
    pub word_only: Box<WordOnly<'t>>,
}

///
/// Type derived for production 211
///
/// WordCountOptGroup: '個';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordCountOptGroup個<'t> {
    pub 個: Token<'t>, /* 個 */
}

///
/// Type derived for production 212
///
/// WordCountOptGroup: 'つ';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordCountOptGroupつ<'t> {
    pub つ: Token<'t>, /* つ */
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AllDrops
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct AllDrops<'t> {
    pub word_all: Box<WordAll<'t>>,
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal And
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct And<'t> {
    pub and: Token<'t>, /* と */
}

///
/// Type derived for non-terminal Bomb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Bomb<'t> {
    pub bomb: Token<'t>, /* 爆弾 */
}

///
/// Type derived for non-terminal Camma
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Camma<'t> {
    pub camma: Token<'t>, /* 、 */
}

///
/// Type derived for non-terminal ChangeDropBlockOtherFirst
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropBlockOtherFirst<'t> {
    pub drops: Box<Drops<'t>>,
    pub wo: Box<Wo<'t>>,
    pub drop: Box<Drop<'t>>,
    pub ni: Box<Ni<'t>>,
}

///
/// Type derived for non-terminal ChangeDropWithDropUnlockLine
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropWithDropUnlockLine<'t> {
    pub all_drops: Box<AllDrops<'t>>,
    pub change_drop_with_drop_unlock_line_opt: Option<Box<ChangeDropWithDropUnlockLineOpt<'t>>>,
    pub change_drop_with_drop_unlock_line_opt0: Option<Box<ChangeDropWithDropUnlockLineOpt0<'t>>>,
}

///
/// Type derived for non-terminal ChangeDropWithDropUnlockLineOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropWithDropUnlockLineOpt<'t> {
    pub change_drop_with_drop_unlock_line_opt_group: Box<ChangeDropWithDropUnlockLineOptGroup<'t>>,
}

///
/// Type derived for non-terminal ChangeDropWithDropUnlockLineOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropWithDropUnlockLineOpt0<'t> {
    pub change_drop_with_drop_unlock_line_opt0_group:
        Box<ChangeDropWithDropUnlockLineOpt0Group<'t>>,
}

///
/// Type derived for non-terminal ChangeDropWithDropUnlockLineOpt0Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ChangeDropWithDropUnlockLineOpt0Group<'t> {
    DropsNiWordChangeChangeDropWithDropUnlockLineOpt1(
        ChangeDropWithDropUnlockLineOpt0GroupDropsNiWordChangeChangeDropWithDropUnlockLineOpt1<'t>,
    ),
    GenShapeStmt(ChangeDropWithDropUnlockLineOpt0GroupGenShapeStmt<'t>),
    WordPowerUp(ChangeDropWithDropUnlockLineOpt0GroupWordPowerUp<'t>),
    WordLock(ChangeDropWithDropUnlockLineOpt0GroupWordLock<'t>),
}

///
/// Type derived for non-terminal ChangeDropWithDropUnlockLineOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropWithDropUnlockLineOpt1<'t> {
    pub si: Box<Si<'t>>,
    pub camma: Box<Camma<'t>>,
    pub gen_random_drop_block: Box<GenRandomDropBlock<'t>>,
    pub word_gen: Box<WordGen<'t>>,
}

///
/// Type derived for non-terminal ChangeDropWithDropUnlockLineOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ChangeDropWithDropUnlockLineOptGroup<'t> {
    DropUnlockBlock(ChangeDropWithDropUnlockLineOptGroupDropUnlockBlock<'t>),
    Wo(ChangeDropWithDropUnlockLineOptGroupWo<'t>),
}

///
/// Type derived for non-terminal Color
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Color<'t> {
    Fire(ColorFire<'t>),
    Water(ColorWater<'t>),
    Wood(ColorWood<'t>),
    Lightning(ColorLightning<'t>),
    Dark(ColorDark<'t>),
}

///
/// Type derived for non-terminal Dark
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Dark<'t> {
    pub dark: Token<'t>, /* 闇 */
}

///
/// Type derived for non-terminal DeadlyPoison
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DeadlyPoison<'t> {
    pub deadly_poison: Token<'t>, /* 猛毒 */
}

///
/// Type derived for non-terminal Disturb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Disturb<'t> {
    pub disturb: Token<'t>, /* お邪魔 */
}

///
/// Type derived for non-terminal Drop
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Drop<'t> {
    ColorDropOpt(DropColorDropOpt<'t>),
    NonColoredDropDropOpt0(DropNonColoredDropDropOpt0<'t>),
}

///
/// Type derived for non-terminal DropOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropOpt<'t> {
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal DropOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropOpt0<'t> {
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal DropRefreshStmt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropRefreshStmt<'t> {
    pub random_suffix: Box<RandomSuffix<'t>>,
    pub word_drop: Box<WordDrop<'t>>,
    pub wo: Box<Wo<'t>>,
    pub word_replace: Box<WordReplace<'t>>,
}

///
/// Type derived for non-terminal DropUnLockStmt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropUnLockStmt<'t> {
    pub word_drop: Box<WordDrop<'t>>,
    pub no: Box<No<'t>>,
    pub word_lock: Box<WordLock<'t>>,
    pub word_state: Box<WordState<'t>>,
    pub wo: Box<Wo<'t>>,
    pub word_release: Box<WordRelease<'t>>,
}

///
/// Type derived for non-terminal DropUnlockBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropUnlockBlock<'t> {
    pub drop_unlock_block_opt: Option<Box<DropUnlockBlockOpt<'t>>>,
    pub word_lock: Box<WordLock<'t>>,
    pub wo: Box<Wo<'t>>,
    pub word_release: Box<WordRelease<'t>>,
    pub si: Box<Si<'t>>,
    pub camma: Box<Camma<'t>>,
}

///
/// Type derived for non-terminal DropUnlockBlockOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropUnlockBlockOpt<'t> {
    pub drop_unlock_block_opt0: Option<Box<DropUnlockBlockOpt0<'t>>>,
    pub no: Box<No<'t>>,
}

///
/// Type derived for non-terminal DropUnlockBlockOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropUnlockBlockOpt0<'t> {
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal Drops
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Drops<'t> {
    DropDropsSuffix(DropsDropDropsSuffix<'t>),
    FiveAttributeDropsList0(DropsFiveAttributeDropsList0<'t>),
}

///
/// Type derived for non-terminal DropsEasierToFalloff
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsEasierToFalloff<'t> {
    pub drops: Box<Drops<'t>>,
    pub drops_easier_to_falloff_opt: Option<Box<DropsEasierToFalloffOpt<'t>>>,
    pub drops_easier_to_falloff_opt0: Option<Box<DropsEasierToFalloffOpt0<'t>>>,
    pub drops_easier_to_falloff_opt1: Option<Box<DropsEasierToFalloffOpt1<'t>>>,
}

///
/// Type derived for non-terminal DropsEasierToFalloffOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsEasierToFalloffOpt<'t> {
    pub ga: Box<Ga<'t>>,
}

///
/// Type derived for non-terminal DropsEasierToFalloffOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsEasierToFalloffOpt0<'t> {
    pub skill_volume_variation: Box<SkillVolumeVariation<'t>>,
}

///
/// Type derived for non-terminal DropsEasierToFalloffOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsEasierToFalloffOpt1<'t> {
    pub drops_easier_to_falloff_opt1_group: Box<DropsEasierToFalloffOpt1Group<'t>>,
}

///
/// Type derived for non-terminal DropsEasierToFalloffOpt1Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DropsEasierToFalloffOpt1Group<'t> {
    WordFalloff(DropsEasierToFalloffOpt1GroupWordFalloff<'t>),
    WordFall(DropsEasierToFalloffOpt1GroupWordFall<'t>),
}

///
/// Type derived for non-terminal DropsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsList<'t> {
    pub many_drop: Box<ManyDrop<'t>>,
}

///
/// Type derived for non-terminal DropsList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsList0<'t> {
    pub plus: Box<Plus<'t>>,
    pub drop: Box<Drop<'t>>,
}

///
/// Type derived for non-terminal DropsSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DropsSuffix<'t> {
    DropsList(DropsSuffixDropsList<'t>),
    AndDrop(DropsSuffixAndDrop<'t>),
}

///
/// Type derived for non-terminal Each
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Each<'t> {
    pub each: Token<'t>, /* ずつ */
}

///
/// Type derived for non-terminal Fire
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Fire<'t> {
    pub fire: Token<'t>, /* 火 */
}

///
/// Type derived for non-terminal FiveAttribute
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct FiveAttribute<'t> {
    pub word_five_attribute: Box<WordFiveAttribute<'t>>,
    pub five_attribute_opt: Option<Box<FiveAttributeOpt<'t>>>,
}

///
/// Type derived for non-terminal FiveAttributeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct FiveAttributeOpt<'t> {
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal From
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct From<'t> {
    pub from: Token<'t>, /* から */
}

///
/// Type derived for non-terminal GSSPCenter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPCenter<'t> {
    pub g_s_s_p_center_blocks: Box<GSSPCenterBlocks<'t>>,
    pub g_s_s_p_center_opt: Option<Box<GSSPCenterOpt<'t>>>,
    pub g_s_s_p_center_opt0: Option<Box<GSSPCenterOpt0<'t>>>,
    pub gen_shape_num_of_gen: Box<GenShapeNumOfGen<'t>>,
}

///
/// Type derived for non-terminal GSSPCenterBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPCenterBlock<'t> {
    pub position_l_r_t_b: Box<PositionLRTB<'t>>,
    pub from: Box<From<'t>>,
    pub pos_int: Box<PosInt<'t>>,
    pub g_s_s_p_center_block_opt: Option<Box<GSSPCenterBlockOpt<'t>>>,
    pub word_look: Box<WordLook<'t>>,
}

///
/// Type derived for non-terminal GSSPCenterBlockOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPCenterBlockOpt<'t> {
    pub g_s_s_p_center_block_opt_group: Box<GSSPCenterBlockOptGroup<'t>>,
}

///
/// Type derived for non-terminal GSSPCenterBlockOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GSSPCenterBlockOptGroup<'t> {
    WordCol(GSSPCenterBlockOptGroupWordCol<'t>),
    WordRow(GSSPCenterBlockOptGroupWordRow<'t>),
}

///
/// Type derived for non-terminal GSSPCenterBlocks
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPCenterBlocks<'t> {
    pub g_s_s_p_center_block: Box<GSSPCenterBlock<'t>>,
    pub g_s_s_p_center_blocks_opt: Option<Box<GSSPCenterBlocksOpt<'t>>>,
}

///
/// Type derived for non-terminal GSSPCenterBlocksOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPCenterBlocksOpt<'t> {
    pub and: Box<And<'t>>,
    pub g_s_s_p_center_block: Box<GSSPCenterBlock<'t>>,
}

///
/// Type derived for non-terminal GSSPCenterOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPCenterOpt<'t> {
    pub no: Box<No<'t>>,
}

///
/// Type derived for non-terminal GSSPCenterOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPCenterOpt0<'t> {
    pub g_s_s_p_center_opt0_group: Box<GSSPCenterOpt0Group<'t>>,
}

///
/// Type derived for non-terminal GSSPCenterOpt0Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GSSPCenterOpt0Group<'t> {
    WordVertical(GSSPCenterOpt0GroupWordVertical<'t>),
    WordHorizon(GSSPCenterOpt0GroupWordHorizon<'t>),
}

///
/// Type derived for non-terminal GSSPSide
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPSide<'t> {
    pub position: Box<Position<'t>>,
    pub g_s_s_p_side_opt: Option<Box<GSSPSideOpt<'t>>>,
    pub gen_shape_num_of_gen: Box<GenShapeNumOfGen<'t>>,
    pub g_s_s_p_side_opt0: Option<Box<GSSPSideOpt0<'t>>>,
}

///
/// Type derived for non-terminal GSSPSideOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPSideOpt<'t> {
    pub word_horizon: Box<WordHorizon<'t>>,
}

///
/// Type derived for non-terminal GSSPSideOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPSideOpt0<'t> {
    pub and: Box<And<'t>>,
    pub position: Box<Position<'t>>,
    pub g_s_s_p_side_opt1: Option<Box<GSSPSideOpt1<'t>>>,
    pub gen_shape_num_of_gen: Box<GenShapeNumOfGen<'t>>,
}

///
/// Type derived for non-terminal GSSPSideOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPSideOpt1<'t> {
    pub word_horizon: Box<WordHorizon<'t>>,
}

///
/// Type derived for non-terminal GSSPSideWriteWidth
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GSSPSideWriteWidth<'t> {
    WordSideGSSPSideWriteWidthOpt(GSSPSideWriteWidthWordSideGSSPSideWriteWidthOpt<'t>),
    WordVertical(GSSPSideWriteWidthWordVertical<'t>),
}

///
/// Type derived for non-terminal GSSPSideWriteWidthOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GSSPSideWriteWidthOpt<'t> {
    pub word_vertical: Box<WordVertical<'t>>,
}

///
/// Type derived for non-terminal GSStartPosition
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GSStartPosition<'t> {
    GSSPSide(GSStartPositionGSSPSide<'t>),
    GSSPCenter(GSStartPositionGSSPCenter<'t>),
}

///
/// Type derived for non-terminal Ga
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Ga<'t> {
    pub ga: Token<'t>, /* が */
}

///
/// Type derived for non-terminal GenRandomDropBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenRandomDropBlock<'t> {
    pub drops: Box<Drops<'t>>,
    pub wo: Box<Wo<'t>>,
    pub quantity: Box<Quantity<'t>>,
}

///
/// Type derived for non-terminal GenRandomDropStmt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenRandomDropStmt<'t> {
    pub random_suffix: Box<RandomSuffix<'t>>,
    pub gen_random_drop_block: Box<GenRandomDropBlock<'t>>,
    pub gen_random_drop_stmt_list: Vec<GenRandomDropStmtList<'t>>,
    pub word_gen: Box<WordGen<'t>>,
}

///
/// Type derived for non-terminal GenRandomDropStmtList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenRandomDropStmtList<'t> {
    pub camma: Box<Camma<'t>>,
    pub gen_random_drop_block: Box<GenRandomDropBlock<'t>>,
}

///
/// Type derived for non-terminal GenShapeBlock
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GenShapeBlock<'t> {
    GenShapeBlockRowColGenShapeBlockList(GenShapeBlockGenShapeBlockRowColGenShapeBlockList<'t>),
    GenShapeBlockOtherRowCol(GenShapeBlockGenShapeBlockOtherRowCol<'t>),
}

///
/// Type derived for non-terminal GenShapeBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeBlockList<'t> {
    pub camma: Box<Camma<'t>>,
    pub gen_shape_block_row_col: Box<GenShapeBlockRowCol<'t>>,
}

///
/// Type derived for non-terminal GenShapeBlockOtherRowCol
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeBlockOtherRowCol<'t> {
    pub shape_type: Box<ShapeType<'t>>,
    pub gen_shape_block_other_row_col_suffix: Box<GenShapeBlockOtherRowColSuffix<'t>>,
}

///
/// Type derived for non-terminal GenShapeBlockOtherRowColOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeBlockOtherRowColOpt<'t> {
    pub quantity: Box<Quantity<'t>>,
}

///
/// Type derived for non-terminal GenShapeBlockOtherRowColSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GenShapeBlockOtherRowColSuffix<'t> {
    NiDropsWoGenShapeBlockOtherRowColOpt(
        GenShapeBlockOtherRowColSuffixNiDropsWoGenShapeBlockOtherRowColOpt<'t>,
    ),
    WoDropsNi(GenShapeBlockOtherRowColSuffixWoDropsNi<'t>),
}

///
/// Type derived for non-terminal GenShapeBlockRowCol
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeBlockRowCol<'t> {
    pub g_s_start_position: Box<GSStartPosition<'t>>,
    pub wo: Box<Wo<'t>>,
    pub drop: Box<Drop<'t>>,
    pub ni: Box<Ni<'t>>,
}

///
/// Type derived for non-terminal GenShapeNumOfGen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeNumOfGen<'t> {
    pub pos_int: Box<PosInt<'t>>,
    pub word_col: Box<WordCol<'t>>,
}

///
/// Type derived for non-terminal GenShapeStmt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeStmt<'t> {
    pub gen_shape_block: Box<GenShapeBlock<'t>>,
    pub gen_shape_stmt_opt: Option<Box<GenShapeStmtOpt<'t>>>,
}

///
/// Type derived for non-terminal GenShapeStmtOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenShapeStmtOpt<'t> {
    pub gen_shape_stmt_opt_group: Box<GenShapeStmtOptGroup<'t>>,
}

///
/// Type derived for non-terminal GenShapeStmtOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GenShapeStmtOptGroup<'t> {
    WordChange(GenShapeStmtOptGroupWordChange<'t>),
    WordGen(GenShapeStmtOptGroupWordGen<'t>),
}

///
/// Type derived for non-terminal GroupOfDropChange
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GroupOfDropChange<'t> {
    GroupOfDropChangeOptGroupOfDropChangeOpt0(
        GroupOfDropChangeGroupOfDropChangeOptGroupOfDropChangeOpt0<'t>,
    ),
    ChangeDropWithDropUnlockLine(GroupOfDropChangeChangeDropWithDropUnlockLine<'t>),
}

///
/// Type derived for non-terminal GroupOfDropChangeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GroupOfDropChangeOpt<'t> {
    pub drop_unlock_block: Box<DropUnlockBlock<'t>>,
}

///
/// Type derived for non-terminal GroupOfDropChangeOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GroupOfDropChangeOpt0<'t> {
    pub group_of_drop_change_opt0_group: Box<GroupOfDropChangeOpt0Group<'t>>,
}

///
/// Type derived for non-terminal GroupOfDropChangeOpt0Group
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GroupOfDropChangeOpt0Group<'t> {
    StartsWithDropLine(GroupOfDropChangeOpt0GroupStartsWithDropLine<'t>),
    GenRandomDropStmt(GroupOfDropChangeOpt0GroupGenRandomDropStmt<'t>),
    GenShapeStmt(GroupOfDropChangeOpt0GroupGenShapeStmt<'t>),
}

///
/// Type derived for non-terminal Lightning
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Lightning<'t> {
    pub lightning: Token<'t>, /* 光 */
}

///
/// Type derived for non-terminal Line
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Line<'t> {
    GroupOfDropChange(LineGroupOfDropChange<'t>),
    DropRefreshStmt(LineDropRefreshStmt<'t>),
    DropUnLockStmt(LineDropUnLockStmt<'t>),
    TurnsOfApplyStmt(LineTurnsOfApplyStmt<'t>),
}

///
/// Type derived for non-terminal ManyDrop
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ManyDrop<'t> {
    CammaDrop(ManyDropCammaDrop<'t>),
    PlusDrop(ManyDropPlusDrop<'t>),
}

///
/// Type derived for non-terminal Multi
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Multi<'t> {
    pub multi: Token<'t>, /* × */
}

///
/// Type derived for non-terminal Ni
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Ni<'t> {
    pub ni: Token<'t>, /* に */
}

///
/// Type derived for non-terminal No
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct No<'t> {
    pub no: Token<'t>, /* の */
}

///
/// Type derived for non-terminal NonColoredDrop
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum NonColoredDrop<'t> {
    Recovery(NonColoredDropRecovery<'t>),
    Disturb(NonColoredDropDisturb<'t>),
    Bomb(NonColoredDropBomb<'t>),
    Poison(NonColoredDropPoison<'t>),
    DeadlyPoison(NonColoredDropDeadlyPoison<'t>),
}

///
/// Type derived for non-terminal OnBoard
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct OnBoard<'t> {
    pub word_board: Box<WordBoard<'t>>,
    pub word_top: Box<WordTop<'t>>,
    pub ni: Box<Ni<'t>>,
}

///
/// Type derived for non-terminal Period
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Period<'t> {
    pub period: Token<'t>, /* 。 */
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Plus<'t> {
    pub plus: Token<'t>, /* + */
}

///
/// Type derived for non-terminal Poison
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Poison<'t> {
    pub poison: Token<'t>, /* 毒 */
}

///
/// Type derived for non-terminal PosInt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PosInt<'t> {
    pub pos_int: Token<'t>, /* [1-9]([0-9])* */
}

///
/// Type derived for non-terminal Position
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Position<'t> {
    PositionLRGSSPSideWriteWidth(PositionPositionLRGSSPSideWriteWidth<'t>),
    PositionTB(PositionPositionTB<'t>),
}

///
/// Type derived for non-terminal PositionLR
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PositionLR<'t> {
    WordLeft(PositionLRWordLeft<'t>),
    WordRight(PositionLRWordRight<'t>),
    WordLeftAndRight(PositionLRWordLeftAndRight<'t>),
}

///
/// Type derived for non-terminal PositionLRTB
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PositionLRTB<'t> {
    WordLeft(PositionLRTBWordLeft<'t>),
    WordRight(PositionLRTBWordRight<'t>),
    WordTop(PositionLRTBWordTop<'t>),
    WordBottom(PositionLRTBWordBottom<'t>),
}

///
/// Type derived for non-terminal PositionTB
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionTB<'t> {
    pub position_t_b_opt: Option<Box<PositionTBOpt<'t>>>,
    pub position_t_or_b: Box<PositionTOrB<'t>>,
    pub word_row: Box<WordRow<'t>>,
}

///
/// Type derived for non-terminal PositionTBOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PositionTBOpt<'t> {
    pub word_most: Box<WordMost<'t>>,
}

///
/// Type derived for non-terminal PositionTOrB
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PositionTOrB<'t> {
    WordTop(PositionTOrBWordTop<'t>),
    WordBottom(PositionTOrBWordBottom<'t>),
}

///
/// Type derived for non-terminal Quantity
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Quantity<'t> {
    pub pos_int: Box<PosInt<'t>>,
    pub word_count: Box<WordCount<'t>>,
    pub quantity_opt: Option<Box<QuantityOpt<'t>>>,
}

///
/// Type derived for non-terminal QuantityOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct QuantityOpt<'t> {
    pub each: Box<Each<'t>>,
}

///
/// Type derived for non-terminal RandomSuffix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct RandomSuffix<'t> {
    pub word_random: Box<WordRandom<'t>>,
    pub so: Box<So<'t>>,
}

///
/// Type derived for non-terminal Recovery
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Recovery<'t> {
    pub recovery: Token<'t>, /* 回復 */
}

///
/// Type derived for non-terminal ShapeOfBoardBottom
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfBoardBottom<'t> {
    pub shape_of_board_bottom: Token<'t>, /* 盤面下部 */
}

///
/// Type derived for non-terminal ShapeOfBoardCenter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfBoardCenter<'t> {
    pub shape_of_board_center: Token<'t>, /* 盤面中央 */
}

///
/// Type derived for non-terminal ShapeOfBoardCorners
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfBoardCorners<'t> {
    pub shape_of_board_corners: Token<'t>, /* 盤面4隅 */
}

///
/// Type derived for non-terminal ShapeOfBoardPerimeter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfBoardPerimeter<'t> {
    pub shape_of_board_perimeter: Token<'t>, /* 盤面外周 */
}

///
/// Type derived for non-terminal ShapeOfBoardTop
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfBoardTop<'t> {
    pub shape_of_board_top: Token<'t>, /* 盤面上部 */
}

///
/// Type derived for non-terminal ShapeOfCrescentMoon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfCrescentMoon<'t> {
    pub shape_of_crescent_moon: Token<'t>, /* 三日月状 */
}

///
/// Type derived for non-terminal ShapeOfCross
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfCross<'t> {
    pub shape_of_cross: Token<'t>, /* 十字型 */
}

///
/// Type derived for non-terminal ShapeOfL
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfL<'t> {
    pub shape_of_l: Token<'t>, /* L字型 */
}

///
/// Type derived for non-terminal ShapeOfOblique
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfOblique<'t> {
    pub shape_of_oblique: Token<'t>, /* 斜め */
}

///
/// Type derived for non-terminal ShapeOfSomeKind
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfSomeKind<'t> {
    pub shape_of_some_kind: Token<'t>, /* の形 */
}

///
/// Type derived for non-terminal ShapeOfSpiderweb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfSpiderweb<'t> {
    pub shape_of_spiderweb: Token<'t>, /* 蜘蛛の巣状 */
}

///
/// Type derived for non-terminal ShapeOfSquare
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfSquare<'t> {
    pub shape_of_square: Token<'t>, /* 正方形 */
}

///
/// Type derived for non-terminal ShapeOfZ
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeOfZ<'t> {
    pub shape_of_z: Token<'t>, /* Z字型 */
}

///
/// Type derived for non-terminal ShapeType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ShapeType<'t> {
    ShapeOfL(ShapeTypeShapeOfL<'t>),
    ShapeTypeOptShapeOfZ(ShapeTypeShapeTypeOptShapeOfZ<'t>),
    ShapeOfCross(ShapeTypeShapeOfCross<'t>),
    SizeNoShapeOfSquare(ShapeTypeSizeNoShapeOfSquare<'t>),
    ShapeOfBoardPerimeter(ShapeTypeShapeOfBoardPerimeter<'t>),
    ShapeOfBoardCenter(ShapeTypeShapeOfBoardCenter<'t>),
    ShapeOfBoardTop(ShapeTypeShapeOfBoardTop<'t>),
    ShapeOfBoardBottom(ShapeTypeShapeOfBoardBottom<'t>),
    ShapeOfBoardCorners(ShapeTypeShapeOfBoardCorners<'t>),
    ShapeOfSpiderweb(ShapeTypeShapeOfSpiderweb<'t>),
    ShapeOfCrescentMoon(ShapeTypeShapeOfCrescentMoon<'t>),
    ShapeTypeOpt0ShapeOfOblique(ShapeTypeShapeTypeOpt0ShapeOfOblique<'t>),
    PosIntShapeOfSomeKind(ShapeTypePosIntShapeOfSomeKind<'t>),
}

///
/// Type derived for non-terminal ShapeTypeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeOpt<'t> {
    pub on_board: Box<OnBoard<'t>>,
}

///
/// Type derived for non-terminal ShapeTypeOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ShapeTypeOpt0<'t> {
    pub on_board: Box<OnBoard<'t>>,
}

///
/// Type derived for non-terminal Si
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Si<'t> {
    pub si: Token<'t>, /* し */
}

///
/// Type derived for non-terminal Size
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Size<'t> {
    pub pos_int: Box<PosInt<'t>>,
    pub multi: Box<Multi<'t>>,
    pub pos_int0: Box<PosInt<'t>>,
}

///
/// Type derived for non-terminal SkillLines
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct SkillLines<'t> {
    pub line: Box<Line<'t>>,
    pub period: Box<Period<'t>>,
}

///
/// Type derived for non-terminal SkillVolumeVariation
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SkillVolumeVariation<'t> {
    WordLittleMore(SkillVolumeVariationWordLittleMore<'t>),
    WordLittle(SkillVolumeVariationWordLittle<'t>),
    WordOnly(SkillVolumeVariationWordOnly<'t>),
}

///
/// Type derived for non-terminal So
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct So<'t> {
    pub so: Token<'t>, /* で */
}

///
/// Type derived for non-terminal StartsWithDropLine
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct StartsWithDropLine<'t> {
    pub drops: Box<Drops<'t>>,
    pub starts_with_drop_line_suffix0: Box<StartsWithDropLineSuffix0<'t>>,
}

///
/// Type derived for non-terminal StartsWithDropLineList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct StartsWithDropLineList<'t> {
    pub camma: Box<Camma<'t>>,
    pub change_drop_block_other_first: Box<ChangeDropBlockOtherFirst<'t>>,
}

///
/// Type derived for non-terminal StartsWithDropLineList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct StartsWithDropLineList0<'t> {
    pub camma: Box<Camma<'t>>,
    pub gen_random_drop_block: Box<GenRandomDropBlock<'t>>,
}

///
/// Type derived for non-terminal StartsWithDropLineOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct StartsWithDropLineOpt<'t> {
    pub starts_with_drop_line_opt_group: Box<StartsWithDropLineOptGroup<'t>>,
}

///
/// Type derived for non-terminal StartsWithDropLineOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StartsWithDropLineOptGroup<'t> {
    WordPowerUp(StartsWithDropLineOptGroupWordPowerUp<'t>),
    WordLock(StartsWithDropLineOptGroupWordLock<'t>),
}

///
/// Type derived for non-terminal StartsWithDropLineSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StartsWithDropLineSuffix<'t> {
    DropNiStartsWithDropLineListWordChange(
        StartsWithDropLineSuffixDropNiStartsWithDropLineListWordChange<'t>,
    ),
    RandomSuffixDropsNiWordChange(StartsWithDropLineSuffixRandomSuffixDropsNiWordChange<'t>),
    QuantityStartsWithDropLineList0WordGen(
        StartsWithDropLineSuffixQuantityStartsWithDropLineList0WordGen<'t>,
    ),
    StartsWithDropLineOpt(StartsWithDropLineSuffixStartsWithDropLineOpt<'t>),
}

///
/// Type derived for non-terminal StartsWithDropLineSuffix0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StartsWithDropLineSuffix0<'t> {
    WoStartsWithDropLineSuffix(StartsWithDropLineSuffix0WoStartsWithDropLineSuffix<'t>),
    WordOtherFromGenRandomDropBlockWordGen(
        StartsWithDropLineSuffix0WordOtherFromGenRandomDropBlockWordGen<'t>,
    ),
}

///
/// Type derived for non-terminal Turns
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Turns<'t> {
    pub pos_int: Box<PosInt<'t>>,
    pub word_turn: Box<WordTurn<'t>>,
    pub no: Box<No<'t>>,
    pub word_between: Box<WordBetween<'t>>,
    pub camma: Box<Camma<'t>>,
}

///
/// Type derived for non-terminal TurnsOfApplyBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct TurnsOfApplyBlock<'t> {
    pub drops_easier_to_falloff: Box<DropsEasierToFalloff<'t>>,
}

///
/// Type derived for non-terminal TurnsOfApplyStmt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct TurnsOfApplyStmt<'t> {
    pub turns: Box<Turns<'t>>,
    pub turns_of_apply_block: Box<TurnsOfApplyBlock<'t>>,
}

///
/// Type derived for non-terminal Water
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Water<'t> {
    pub water: Token<'t>, /* 水 */
}

///
/// Type derived for non-terminal Wo
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Wo<'t> {
    pub wo: Token<'t>, /* を */
}

///
/// Type derived for non-terminal Wood
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Wood<'t> {
    pub wood: Token<'t>, /* 木 */
}

///
/// Type derived for non-terminal WordAll
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordAll<'t> {
    pub word_all: Token<'t>, /* 全 */
}

///
/// Type derived for non-terminal WordBetween
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordBetween<'t> {
    pub word_between: Token<'t>, /* 間 */
}

///
/// Type derived for non-terminal WordBoard
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordBoard<'t> {
    pub word_board: Token<'t>, /* 盤面 */
}

///
/// Type derived for non-terminal WordBottom
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordBottom<'t> {
    pub word_bottom: Token<'t>, /* 下 */
}

///
/// Type derived for non-terminal WordChange
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordChange<'t> {
    pub word_change: Token<'t>, /* 変化 */
}

///
/// Type derived for non-terminal WordCol
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordCol<'t> {
    pub word_col: Token<'t>, /* 列 */
}

///
/// Type derived for non-terminal WordCount
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordCount<'t> {
    pub word_count_opt: Option<Box<WordCountOpt<'t>>>,
}

///
/// Type derived for non-terminal WordCountOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordCountOpt<'t> {
    pub word_count_opt_group: Box<WordCountOptGroup<'t>>,
}

///
/// Type derived for non-terminal WordCountOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum WordCountOptGroup<'t> {
    個(WordCountOptGroup個<'t>),
    つ(WordCountOptGroupつ<'t>),
}

///
/// Type derived for non-terminal WordDrop
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordDrop<'t> {
    pub word_drop: Token<'t>, /* ドロップ */
}

///
/// Type derived for non-terminal WordFall
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordFall<'t> {
    pub word_fall: Token<'t>, /* 落ちてくる */
}

///
/// Type derived for non-terminal WordFalloff
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordFalloff<'t> {
    pub word_falloff: Token<'t>, /* 落ちやすくなる */
}

///
/// Type derived for non-terminal WordFiveAttribute
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordFiveAttribute<'t> {
    pub word_five_attribute: Token<'t>, /* 5属性 */
}

///
/// Type derived for non-terminal WordGen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordGen<'t> {
    pub word_gen: Token<'t>, /* 生成 */
}

///
/// Type derived for non-terminal WordHorizon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordHorizon<'t> {
    pub word_horizon: Token<'t>, /* 横 */
}

///
/// Type derived for non-terminal WordLeft
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordLeft<'t> {
    pub word_left: Token<'t>, /* 左 */
}

///
/// Type derived for non-terminal WordLeftAndRight
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordLeftAndRight<'t> {
    pub word_left_and_right: Token<'t>, /* 両 */
}

///
/// Type derived for non-terminal WordLittle
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordLittle<'t> {
    pub word_little: Token<'t>, /* 少し */
}

///
/// Type derived for non-terminal WordLittleMore
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordLittleMore<'t> {
    pub word_little_more: Token<'t>, /* ほんの少し */
}

///
/// Type derived for non-terminal WordLock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordLock<'t> {
    pub word_lock: Token<'t>, /* ロック */
}

///
/// Type derived for non-terminal WordLook
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordLook<'t> {
    pub word_look: Token<'t>, /* 目 */
}

///
/// Type derived for non-terminal WordMost
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordMost<'t> {
    pub word_most: Token<'t>, /* 最 */
}

///
/// Type derived for non-terminal WordOnly
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordOnly<'t> {
    pub word_only: Token<'t>, /* のみ */
}

///
/// Type derived for non-terminal WordOther
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordOther<'t> {
    pub word_other: Token<'t>, /* 以外 */
}

///
/// Type derived for non-terminal WordPowerUp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordPowerUp<'t> {
    pub word_power_up: Token<'t>, /* 強化 */
}

///
/// Type derived for non-terminal WordRandom
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordRandom<'t> {
    pub word_random: Token<'t>, /* ランダム */
}

///
/// Type derived for non-terminal WordRelease
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordRelease<'t> {
    pub word_release: Token<'t>, /* 解除 */
}

///
/// Type derived for non-terminal WordReplace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordReplace<'t> {
    pub word_replace: Token<'t>, /* 入れ替える */
}

///
/// Type derived for non-terminal WordRight
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordRight<'t> {
    pub word_right: Token<'t>, /* 右 */
}

///
/// Type derived for non-terminal WordRow
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordRow<'t> {
    pub word_row: Token<'t>, /* 段 */
}

///
/// Type derived for non-terminal WordSide
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordSide<'t> {
    pub word_side: Token<'t>, /* 端 */
}

///
/// Type derived for non-terminal WordState
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordState<'t> {
    pub word_state: Token<'t>, /* 状態 */
}

///
/// Type derived for non-terminal WordTop
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordTop<'t> {
    pub word_top: Token<'t>, /* 上 */
}

///
/// Type derived for non-terminal WordTurn
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordTurn<'t> {
    pub word_turn: Token<'t>, /* ターン */
}

///
/// Type derived for non-terminal WordVertical
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordVertical<'t> {
    pub word_vertical: Token<'t>, /* 縦 */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AllDrops(AllDrops<'t>),
    And(And<'t>),
    Bomb(Bomb<'t>),
    Camma(Camma<'t>),
    ChangeDropBlockOtherFirst(ChangeDropBlockOtherFirst<'t>),
    ChangeDropWithDropUnlockLine(ChangeDropWithDropUnlockLine<'t>),
    ChangeDropWithDropUnlockLineOpt(Option<Box<ChangeDropWithDropUnlockLineOpt<'t>>>),
    ChangeDropWithDropUnlockLineOpt0(Option<Box<ChangeDropWithDropUnlockLineOpt0<'t>>>),
    ChangeDropWithDropUnlockLineOpt0Group(ChangeDropWithDropUnlockLineOpt0Group<'t>),
    ChangeDropWithDropUnlockLineOpt1(Option<Box<ChangeDropWithDropUnlockLineOpt1<'t>>>),
    ChangeDropWithDropUnlockLineOptGroup(ChangeDropWithDropUnlockLineOptGroup<'t>),
    Color(Color<'t>),
    Dark(Dark<'t>),
    DeadlyPoison(DeadlyPoison<'t>),
    Disturb(Disturb<'t>),
    Drop(Drop<'t>),
    DropOpt(Option<Box<DropOpt<'t>>>),
    DropOpt0(Option<Box<DropOpt0<'t>>>),
    DropRefreshStmt(DropRefreshStmt<'t>),
    DropUnLockStmt(DropUnLockStmt<'t>),
    DropUnlockBlock(DropUnlockBlock<'t>),
    DropUnlockBlockOpt(Option<Box<DropUnlockBlockOpt<'t>>>),
    DropUnlockBlockOpt0(Option<Box<DropUnlockBlockOpt0<'t>>>),
    Drops(Drops<'t>),
    DropsEasierToFalloff(DropsEasierToFalloff<'t>),
    DropsEasierToFalloffOpt(Option<Box<DropsEasierToFalloffOpt<'t>>>),
    DropsEasierToFalloffOpt0(Option<Box<DropsEasierToFalloffOpt0<'t>>>),
    DropsEasierToFalloffOpt1(Option<Box<DropsEasierToFalloffOpt1<'t>>>),
    DropsEasierToFalloffOpt1Group(DropsEasierToFalloffOpt1Group<'t>),
    DropsList(Vec<DropsList<'t>>),
    DropsList0(Vec<DropsList0<'t>>),
    DropsSuffix(DropsSuffix<'t>),
    Each(Each<'t>),
    Fire(Fire<'t>),
    FiveAttribute(FiveAttribute<'t>),
    FiveAttributeOpt(Option<Box<FiveAttributeOpt<'t>>>),
    From(From<'t>),
    GSSPCenter(GSSPCenter<'t>),
    GSSPCenterBlock(GSSPCenterBlock<'t>),
    GSSPCenterBlockOpt(Option<Box<GSSPCenterBlockOpt<'t>>>),
    GSSPCenterBlockOptGroup(GSSPCenterBlockOptGroup<'t>),
    GSSPCenterBlocks(GSSPCenterBlocks<'t>),
    GSSPCenterBlocksOpt(Option<Box<GSSPCenterBlocksOpt<'t>>>),
    GSSPCenterOpt(Option<Box<GSSPCenterOpt<'t>>>),
    GSSPCenterOpt0(Option<Box<GSSPCenterOpt0<'t>>>),
    GSSPCenterOpt0Group(GSSPCenterOpt0Group<'t>),
    GSSPSide(GSSPSide<'t>),
    GSSPSideOpt(Option<Box<GSSPSideOpt<'t>>>),
    GSSPSideOpt0(Option<Box<GSSPSideOpt0<'t>>>),
    GSSPSideOpt1(Option<Box<GSSPSideOpt1<'t>>>),
    GSSPSideWriteWidth(GSSPSideWriteWidth<'t>),
    GSSPSideWriteWidthOpt(Option<Box<GSSPSideWriteWidthOpt<'t>>>),
    GSStartPosition(GSStartPosition<'t>),
    Ga(Ga<'t>),
    GenRandomDropBlock(GenRandomDropBlock<'t>),
    GenRandomDropStmt(GenRandomDropStmt<'t>),
    GenRandomDropStmtList(Vec<GenRandomDropStmtList<'t>>),
    GenShapeBlock(GenShapeBlock<'t>),
    GenShapeBlockList(Vec<GenShapeBlockList<'t>>),
    GenShapeBlockOtherRowCol(GenShapeBlockOtherRowCol<'t>),
    GenShapeBlockOtherRowColOpt(Option<Box<GenShapeBlockOtherRowColOpt<'t>>>),
    GenShapeBlockOtherRowColSuffix(GenShapeBlockOtherRowColSuffix<'t>),
    GenShapeBlockRowCol(GenShapeBlockRowCol<'t>),
    GenShapeNumOfGen(GenShapeNumOfGen<'t>),
    GenShapeStmt(GenShapeStmt<'t>),
    GenShapeStmtOpt(Option<Box<GenShapeStmtOpt<'t>>>),
    GenShapeStmtOptGroup(GenShapeStmtOptGroup<'t>),
    GroupOfDropChange(GroupOfDropChange<'t>),
    GroupOfDropChangeOpt(Option<Box<GroupOfDropChangeOpt<'t>>>),
    GroupOfDropChangeOpt0(Option<Box<GroupOfDropChangeOpt0<'t>>>),
    GroupOfDropChangeOpt0Group(GroupOfDropChangeOpt0Group<'t>),
    Lightning(Lightning<'t>),
    Line(Line<'t>),
    ManyDrop(ManyDrop<'t>),
    Multi(Multi<'t>),
    Ni(Ni<'t>),
    No(No<'t>),
    NonColoredDrop(NonColoredDrop<'t>),
    OnBoard(OnBoard<'t>),
    Period(Period<'t>),
    Plus(Plus<'t>),
    Poison(Poison<'t>),
    PosInt(PosInt<'t>),
    Position(Position<'t>),
    PositionLR(PositionLR<'t>),
    PositionLRTB(PositionLRTB<'t>),
    PositionTB(PositionTB<'t>),
    PositionTBOpt(Option<Box<PositionTBOpt<'t>>>),
    PositionTOrB(PositionTOrB<'t>),
    Quantity(Quantity<'t>),
    QuantityOpt(Option<Box<QuantityOpt<'t>>>),
    RandomSuffix(RandomSuffix<'t>),
    Recovery(Recovery<'t>),
    ShapeOfBoardBottom(ShapeOfBoardBottom<'t>),
    ShapeOfBoardCenter(ShapeOfBoardCenter<'t>),
    ShapeOfBoardCorners(ShapeOfBoardCorners<'t>),
    ShapeOfBoardPerimeter(ShapeOfBoardPerimeter<'t>),
    ShapeOfBoardTop(ShapeOfBoardTop<'t>),
    ShapeOfCrescentMoon(ShapeOfCrescentMoon<'t>),
    ShapeOfCross(ShapeOfCross<'t>),
    ShapeOfL(ShapeOfL<'t>),
    ShapeOfOblique(ShapeOfOblique<'t>),
    ShapeOfSomeKind(ShapeOfSomeKind<'t>),
    ShapeOfSpiderweb(ShapeOfSpiderweb<'t>),
    ShapeOfSquare(ShapeOfSquare<'t>),
    ShapeOfZ(ShapeOfZ<'t>),
    ShapeType(ShapeType<'t>),
    ShapeTypeOpt(Option<Box<ShapeTypeOpt<'t>>>),
    ShapeTypeOpt0(Option<Box<ShapeTypeOpt0<'t>>>),
    Si(Si<'t>),
    Size(Size<'t>),
    SkillLines(SkillLines<'t>),
    SkillVolumeVariation(SkillVolumeVariation<'t>),
    So(So<'t>),
    StartsWithDropLine(StartsWithDropLine<'t>),
    StartsWithDropLineList(Vec<StartsWithDropLineList<'t>>),
    StartsWithDropLineList0(Vec<StartsWithDropLineList0<'t>>),
    StartsWithDropLineOpt(Option<Box<StartsWithDropLineOpt<'t>>>),
    StartsWithDropLineOptGroup(StartsWithDropLineOptGroup<'t>),
    StartsWithDropLineSuffix(StartsWithDropLineSuffix<'t>),
    StartsWithDropLineSuffix0(StartsWithDropLineSuffix0<'t>),
    Turns(Turns<'t>),
    TurnsOfApplyBlock(TurnsOfApplyBlock<'t>),
    TurnsOfApplyStmt(TurnsOfApplyStmt<'t>),
    Water(Water<'t>),
    Wo(Wo<'t>),
    Wood(Wood<'t>),
    WordAll(WordAll<'t>),
    WordBetween(WordBetween<'t>),
    WordBoard(WordBoard<'t>),
    WordBottom(WordBottom<'t>),
    WordChange(WordChange<'t>),
    WordCol(WordCol<'t>),
    WordCount(WordCount<'t>),
    WordCountOpt(Option<Box<WordCountOpt<'t>>>),
    WordCountOptGroup(WordCountOptGroup<'t>),
    WordDrop(WordDrop<'t>),
    WordFall(WordFall<'t>),
    WordFalloff(WordFalloff<'t>),
    WordFiveAttribute(WordFiveAttribute<'t>),
    WordGen(WordGen<'t>),
    WordHorizon(WordHorizon<'t>),
    WordLeft(WordLeft<'t>),
    WordLeftAndRight(WordLeftAndRight<'t>),
    WordLittle(WordLittle<'t>),
    WordLittleMore(WordLittleMore<'t>),
    WordLock(WordLock<'t>),
    WordLook(WordLook<'t>),
    WordMost(WordMost<'t>),
    WordOnly(WordOnly<'t>),
    WordOther(WordOther<'t>),
    WordPowerUp(WordPowerUp<'t>),
    WordRandom(WordRandom<'t>),
    WordRelease(WordRelease<'t>),
    WordReplace(WordReplace<'t>),
    WordRight(WordRight<'t>),
    WordRow(WordRow<'t>),
    WordSide(WordSide<'t>),
    WordState(WordState<'t>),
    WordTop(WordTop<'t>),
    WordTurn(WordTurn<'t>),
    WordVertical(WordVertical<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct SkillGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn SkillGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `SkillGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> SkillGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn SkillGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// SkillLines: Line Period;
    ///
    #[parol_runtime::function_name::named]
    fn skill_lines(
        &mut self,
        _line: &ParseTreeStackEntry<'t>,
        _period: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let period = pop_item!(self, period, Period, context);
        let line = pop_item!(self, line, Line, context);
        let skill_lines_built = SkillLinesBuilder::default()
            .line(Box::new(line))
            .period(Box::new(period))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.skill_lines(&skill_lines_built)?;
        self.push(ASTType::SkillLines(skill_lines_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Line: GroupOfDropChange;
    ///
    #[parol_runtime::function_name::named]
    fn line_0(
        &mut self,
        _group_of_drop_change: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let group_of_drop_change =
            pop_item!(self, group_of_drop_change, GroupOfDropChange, context);
        let line_0_built = LineGroupOfDropChangeBuilder::default()
            .group_of_drop_change(Box::new(group_of_drop_change))
            .build()
            .into_diagnostic()?;
        let line_0_built = Line::GroupOfDropChange(line_0_built);
        // Calling user action here
        self.user_grammar.line(&line_0_built)?;
        self.push(ASTType::Line(line_0_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// Line: DropRefreshStmt;
    ///
    #[parol_runtime::function_name::named]
    fn line_1(
        &mut self,
        _drop_refresh_stmt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_refresh_stmt = pop_item!(self, drop_refresh_stmt, DropRefreshStmt, context);
        let line_1_built = LineDropRefreshStmtBuilder::default()
            .drop_refresh_stmt(Box::new(drop_refresh_stmt))
            .build()
            .into_diagnostic()?;
        let line_1_built = Line::DropRefreshStmt(line_1_built);
        // Calling user action here
        self.user_grammar.line(&line_1_built)?;
        self.push(ASTType::Line(line_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// Line: DropUnLockStmt;
    ///
    #[parol_runtime::function_name::named]
    fn line_2(
        &mut self,
        _drop_un_lock_stmt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_un_lock_stmt = pop_item!(self, drop_un_lock_stmt, DropUnLockStmt, context);
        let line_2_built = LineDropUnLockStmtBuilder::default()
            .drop_un_lock_stmt(Box::new(drop_un_lock_stmt))
            .build()
            .into_diagnostic()?;
        let line_2_built = Line::DropUnLockStmt(line_2_built);
        // Calling user action here
        self.user_grammar.line(&line_2_built)?;
        self.push(ASTType::Line(line_2_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// Line: TurnsOfApplyStmt;
    ///
    #[parol_runtime::function_name::named]
    fn line_3(
        &mut self,
        _turns_of_apply_stmt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let turns_of_apply_stmt = pop_item!(self, turns_of_apply_stmt, TurnsOfApplyStmt, context);
        let line_3_built = LineTurnsOfApplyStmtBuilder::default()
            .turns_of_apply_stmt(Box::new(turns_of_apply_stmt))
            .build()
            .into_diagnostic()?;
        let line_3_built = Line::TurnsOfApplyStmt(line_3_built);
        // Calling user action here
        self.user_grammar.line(&line_3_built)?;
        self.push(ASTType::Line(line_3_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// GroupOfDropChange: GroupOfDropChangeOpt /* Option */ GroupOfDropChangeOpt0 /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn group_of_drop_change_0(
        &mut self,
        _group_of_drop_change_opt: &ParseTreeStackEntry<'t>,
        _group_of_drop_change_opt0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let group_of_drop_change_opt0 = pop_item!(
            self,
            group_of_drop_change_opt0,
            GroupOfDropChangeOpt0,
            context
        );
        let group_of_drop_change_opt = pop_item!(
            self,
            group_of_drop_change_opt,
            GroupOfDropChangeOpt,
            context
        );
        let group_of_drop_change_0_built =
            GroupOfDropChangeGroupOfDropChangeOptGroupOfDropChangeOpt0Builder::default()
                .group_of_drop_change_opt(group_of_drop_change_opt)
                .group_of_drop_change_opt0(group_of_drop_change_opt0)
                .build()
                .into_diagnostic()?;
        let group_of_drop_change_0_built =
            GroupOfDropChange::GroupOfDropChangeOptGroupOfDropChangeOpt0(
                group_of_drop_change_0_built,
            );
        // Calling user action here
        self.user_grammar
            .group_of_drop_change(&group_of_drop_change_0_built)?;
        self.push(
            ASTType::GroupOfDropChange(group_of_drop_change_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// GroupOfDropChange: ChangeDropWithDropUnlockLine;
    ///
    #[parol_runtime::function_name::named]
    fn group_of_drop_change_1(
        &mut self,
        _change_drop_with_drop_unlock_line: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_with_drop_unlock_line = pop_item!(
            self,
            change_drop_with_drop_unlock_line,
            ChangeDropWithDropUnlockLine,
            context
        );
        let group_of_drop_change_1_built =
            GroupOfDropChangeChangeDropWithDropUnlockLineBuilder::default()
                .change_drop_with_drop_unlock_line(Box::new(change_drop_with_drop_unlock_line))
                .build()
                .into_diagnostic()?;
        let group_of_drop_change_1_built =
            GroupOfDropChange::ChangeDropWithDropUnlockLine(group_of_drop_change_1_built);
        // Calling user action here
        self.user_grammar
            .group_of_drop_change(&group_of_drop_change_1_built)?;
        self.push(
            ASTType::GroupOfDropChange(group_of_drop_change_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// GroupOfDropChangeOpt0 /* Option<T>::Some */: GroupOfDropChangeOpt0Group;
    ///
    #[parol_runtime::function_name::named]
    fn group_of_drop_change_opt0_0(
        &mut self,
        _group_of_drop_change_opt0_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let group_of_drop_change_opt0_group = pop_item!(
            self,
            group_of_drop_change_opt0_group,
            GroupOfDropChangeOpt0Group,
            context
        );
        let group_of_drop_change_opt0_0_built = GroupOfDropChangeOpt0Builder::default()
            .group_of_drop_change_opt0_group(Box::new(group_of_drop_change_opt0_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::GroupOfDropChangeOpt0(Some(Box::new(group_of_drop_change_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// GroupOfDropChangeOpt0Group: StartsWithDropLine;
    ///
    #[parol_runtime::function_name::named]
    fn group_of_drop_change_opt0_group_0(
        &mut self,
        _starts_with_drop_line: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let starts_with_drop_line =
            pop_item!(self, starts_with_drop_line, StartsWithDropLine, context);
        let group_of_drop_change_opt0_group_0_built =
            GroupOfDropChangeOpt0GroupStartsWithDropLineBuilder::default()
                .starts_with_drop_line(Box::new(starts_with_drop_line))
                .build()
                .into_diagnostic()?;
        let group_of_drop_change_opt0_group_0_built =
            GroupOfDropChangeOpt0Group::StartsWithDropLine(group_of_drop_change_opt0_group_0_built);
        self.push(
            ASTType::GroupOfDropChangeOpt0Group(group_of_drop_change_opt0_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// GroupOfDropChangeOpt0Group: GenRandomDropStmt;
    ///
    #[parol_runtime::function_name::named]
    fn group_of_drop_change_opt0_group_1(
        &mut self,
        _gen_random_drop_stmt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_random_drop_stmt =
            pop_item!(self, gen_random_drop_stmt, GenRandomDropStmt, context);
        let group_of_drop_change_opt0_group_1_built =
            GroupOfDropChangeOpt0GroupGenRandomDropStmtBuilder::default()
                .gen_random_drop_stmt(Box::new(gen_random_drop_stmt))
                .build()
                .into_diagnostic()?;
        let group_of_drop_change_opt0_group_1_built =
            GroupOfDropChangeOpt0Group::GenRandomDropStmt(group_of_drop_change_opt0_group_1_built);
        self.push(
            ASTType::GroupOfDropChangeOpt0Group(group_of_drop_change_opt0_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// GroupOfDropChangeOpt0Group: GenShapeStmt;
    ///
    #[parol_runtime::function_name::named]
    fn group_of_drop_change_opt0_group_2(
        &mut self,
        _gen_shape_stmt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_shape_stmt = pop_item!(self, gen_shape_stmt, GenShapeStmt, context);
        let group_of_drop_change_opt0_group_2_built =
            GroupOfDropChangeOpt0GroupGenShapeStmtBuilder::default()
                .gen_shape_stmt(Box::new(gen_shape_stmt))
                .build()
                .into_diagnostic()?;
        let group_of_drop_change_opt0_group_2_built =
            GroupOfDropChangeOpt0Group::GenShapeStmt(group_of_drop_change_opt0_group_2_built);
        self.push(
            ASTType::GroupOfDropChangeOpt0Group(group_of_drop_change_opt0_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// GroupOfDropChangeOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn group_of_drop_change_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GroupOfDropChangeOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// GroupOfDropChangeOpt /* Option<T>::Some */: DropUnlockBlock;
    ///
    #[parol_runtime::function_name::named]
    fn group_of_drop_change_opt_0(
        &mut self,
        _drop_unlock_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_unlock_block = pop_item!(self, drop_unlock_block, DropUnlockBlock, context);
        let group_of_drop_change_opt_0_built = GroupOfDropChangeOptBuilder::default()
            .drop_unlock_block(Box::new(drop_unlock_block))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::GroupOfDropChangeOpt(Some(Box::new(group_of_drop_change_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// GroupOfDropChangeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn group_of_drop_change_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GroupOfDropChangeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// ChangeDropWithDropUnlockLine: AllDrops ChangeDropWithDropUnlockLineOpt /* Option */ ChangeDropWithDropUnlockLineOpt0 /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line(
        &mut self,
        _all_drops: &ParseTreeStackEntry<'t>,
        _change_drop_with_drop_unlock_line_opt: &ParseTreeStackEntry<'t>,
        _change_drop_with_drop_unlock_line_opt0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_with_drop_unlock_line_opt0 = pop_item!(
            self,
            change_drop_with_drop_unlock_line_opt0,
            ChangeDropWithDropUnlockLineOpt0,
            context
        );
        let change_drop_with_drop_unlock_line_opt = pop_item!(
            self,
            change_drop_with_drop_unlock_line_opt,
            ChangeDropWithDropUnlockLineOpt,
            context
        );
        let all_drops = pop_item!(self, all_drops, AllDrops, context);
        let change_drop_with_drop_unlock_line_built =
            ChangeDropWithDropUnlockLineBuilder::default()
                .all_drops(Box::new(all_drops))
                .change_drop_with_drop_unlock_line_opt(change_drop_with_drop_unlock_line_opt)
                .change_drop_with_drop_unlock_line_opt0(change_drop_with_drop_unlock_line_opt0)
                .build()
                .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .change_drop_with_drop_unlock_line(&change_drop_with_drop_unlock_line_built)?;
        self.push(
            ASTType::ChangeDropWithDropUnlockLine(change_drop_with_drop_unlock_line_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// ChangeDropWithDropUnlockLineOpt0 /* Option<T>::Some */: ChangeDropWithDropUnlockLineOpt0Group;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line_opt0_0(
        &mut self,
        _change_drop_with_drop_unlock_line_opt0_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_with_drop_unlock_line_opt0_group = pop_item!(
            self,
            change_drop_with_drop_unlock_line_opt0_group,
            ChangeDropWithDropUnlockLineOpt0Group,
            context
        );
        let change_drop_with_drop_unlock_line_opt0_0_built =
            ChangeDropWithDropUnlockLineOpt0Builder::default()
                .change_drop_with_drop_unlock_line_opt0_group(Box::new(
                    change_drop_with_drop_unlock_line_opt0_group,
                ))
                .build()
                .into_diagnostic()?;
        self.push(
            ASTType::ChangeDropWithDropUnlockLineOpt0(Some(Box::new(
                change_drop_with_drop_unlock_line_opt0_0_built,
            ))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// ChangeDropWithDropUnlockLineOpt0Group: Drops Ni WordChange ChangeDropWithDropUnlockLineOpt1 /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line_opt0_group_0(
        &mut self,
        _drops: &ParseTreeStackEntry<'t>,
        _ni: &ParseTreeStackEntry<'t>,
        _word_change: &ParseTreeStackEntry<'t>,
        _change_drop_with_drop_unlock_line_opt1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_with_drop_unlock_line_opt1 = pop_item!(
            self,
            change_drop_with_drop_unlock_line_opt1,
            ChangeDropWithDropUnlockLineOpt1,
            context
        );
        let word_change = pop_item!(self, word_change, WordChange, context);
        let ni = pop_item!(self, ni, Ni, context);
        let drops = pop_item!(self, drops, Drops, context);
        let change_drop_with_drop_unlock_line_opt0_group_0_built = ChangeDropWithDropUnlockLineOpt0GroupDropsNiWordChangeChangeDropWithDropUnlockLineOpt1Builder::default()
            .drops(Box::new(drops))
            .ni(Box::new(ni))
            .word_change(Box::new(word_change))
            .change_drop_with_drop_unlock_line_opt1(change_drop_with_drop_unlock_line_opt1)
            .build()
            .into_diagnostic()?;
        let change_drop_with_drop_unlock_line_opt0_group_0_built = ChangeDropWithDropUnlockLineOpt0Group::DropsNiWordChangeChangeDropWithDropUnlockLineOpt1(change_drop_with_drop_unlock_line_opt0_group_0_built);
        self.push(
            ASTType::ChangeDropWithDropUnlockLineOpt0Group(
                change_drop_with_drop_unlock_line_opt0_group_0_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// ChangeDropWithDropUnlockLineOpt0Group: GenShapeStmt;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line_opt0_group_1(
        &mut self,
        _gen_shape_stmt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_shape_stmt = pop_item!(self, gen_shape_stmt, GenShapeStmt, context);
        let change_drop_with_drop_unlock_line_opt0_group_1_built =
            ChangeDropWithDropUnlockLineOpt0GroupGenShapeStmtBuilder::default()
                .gen_shape_stmt(Box::new(gen_shape_stmt))
                .build()
                .into_diagnostic()?;
        let change_drop_with_drop_unlock_line_opt0_group_1_built =
            ChangeDropWithDropUnlockLineOpt0Group::GenShapeStmt(
                change_drop_with_drop_unlock_line_opt0_group_1_built,
            );
        self.push(
            ASTType::ChangeDropWithDropUnlockLineOpt0Group(
                change_drop_with_drop_unlock_line_opt0_group_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// ChangeDropWithDropUnlockLineOpt0Group: WordPowerUp;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line_opt0_group_2(
        &mut self,
        _word_power_up: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_power_up = pop_item!(self, word_power_up, WordPowerUp, context);
        let change_drop_with_drop_unlock_line_opt0_group_2_built =
            ChangeDropWithDropUnlockLineOpt0GroupWordPowerUpBuilder::default()
                .word_power_up(Box::new(word_power_up))
                .build()
                .into_diagnostic()?;
        let change_drop_with_drop_unlock_line_opt0_group_2_built =
            ChangeDropWithDropUnlockLineOpt0Group::WordPowerUp(
                change_drop_with_drop_unlock_line_opt0_group_2_built,
            );
        self.push(
            ASTType::ChangeDropWithDropUnlockLineOpt0Group(
                change_drop_with_drop_unlock_line_opt0_group_2_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// ChangeDropWithDropUnlockLineOpt0Group: WordLock;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line_opt0_group_3(
        &mut self,
        _word_lock: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_lock = pop_item!(self, word_lock, WordLock, context);
        let change_drop_with_drop_unlock_line_opt0_group_3_built =
            ChangeDropWithDropUnlockLineOpt0GroupWordLockBuilder::default()
                .word_lock(Box::new(word_lock))
                .build()
                .into_diagnostic()?;
        let change_drop_with_drop_unlock_line_opt0_group_3_built =
            ChangeDropWithDropUnlockLineOpt0Group::WordLock(
                change_drop_with_drop_unlock_line_opt0_group_3_built,
            );
        self.push(
            ASTType::ChangeDropWithDropUnlockLineOpt0Group(
                change_drop_with_drop_unlock_line_opt0_group_3_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// ChangeDropWithDropUnlockLineOpt1 /* Option<T>::Some */: Si Camma GenRandomDropBlock WordGen;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line_opt1_0(
        &mut self,
        _si: &ParseTreeStackEntry<'t>,
        _camma: &ParseTreeStackEntry<'t>,
        _gen_random_drop_block: &ParseTreeStackEntry<'t>,
        _word_gen: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_gen = pop_item!(self, word_gen, WordGen, context);
        let gen_random_drop_block =
            pop_item!(self, gen_random_drop_block, GenRandomDropBlock, context);
        let camma = pop_item!(self, camma, Camma, context);
        let si = pop_item!(self, si, Si, context);
        let change_drop_with_drop_unlock_line_opt1_0_built =
            ChangeDropWithDropUnlockLineOpt1Builder::default()
                .si(Box::new(si))
                .camma(Box::new(camma))
                .gen_random_drop_block(Box::new(gen_random_drop_block))
                .word_gen(Box::new(word_gen))
                .build()
                .into_diagnostic()?;
        self.push(
            ASTType::ChangeDropWithDropUnlockLineOpt1(Some(Box::new(
                change_drop_with_drop_unlock_line_opt1_0_built,
            ))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// ChangeDropWithDropUnlockLineOpt1 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line_opt1_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ChangeDropWithDropUnlockLineOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// ChangeDropWithDropUnlockLineOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line_opt0_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ChangeDropWithDropUnlockLineOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// ChangeDropWithDropUnlockLineOpt /* Option<T>::Some */: ChangeDropWithDropUnlockLineOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line_opt_0(
        &mut self,
        _change_drop_with_drop_unlock_line_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_with_drop_unlock_line_opt_group = pop_item!(
            self,
            change_drop_with_drop_unlock_line_opt_group,
            ChangeDropWithDropUnlockLineOptGroup,
            context
        );
        let change_drop_with_drop_unlock_line_opt_0_built =
            ChangeDropWithDropUnlockLineOptBuilder::default()
                .change_drop_with_drop_unlock_line_opt_group(Box::new(
                    change_drop_with_drop_unlock_line_opt_group,
                ))
                .build()
                .into_diagnostic()?;
        self.push(
            ASTType::ChangeDropWithDropUnlockLineOpt(Some(Box::new(
                change_drop_with_drop_unlock_line_opt_0_built,
            ))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// ChangeDropWithDropUnlockLineOptGroup: DropUnlockBlock;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line_opt_group_0(
        &mut self,
        _drop_unlock_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_unlock_block = pop_item!(self, drop_unlock_block, DropUnlockBlock, context);
        let change_drop_with_drop_unlock_line_opt_group_0_built =
            ChangeDropWithDropUnlockLineOptGroupDropUnlockBlockBuilder::default()
                .drop_unlock_block(Box::new(drop_unlock_block))
                .build()
                .into_diagnostic()?;
        let change_drop_with_drop_unlock_line_opt_group_0_built =
            ChangeDropWithDropUnlockLineOptGroup::DropUnlockBlock(
                change_drop_with_drop_unlock_line_opt_group_0_built,
            );
        self.push(
            ASTType::ChangeDropWithDropUnlockLineOptGroup(
                change_drop_with_drop_unlock_line_opt_group_0_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// ChangeDropWithDropUnlockLineOptGroup: Wo;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line_opt_group_1(
        &mut self,
        _wo: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let wo = pop_item!(self, wo, Wo, context);
        let change_drop_with_drop_unlock_line_opt_group_1_built =
            ChangeDropWithDropUnlockLineOptGroupWoBuilder::default()
                .wo(Box::new(wo))
                .build()
                .into_diagnostic()?;
        let change_drop_with_drop_unlock_line_opt_group_1_built =
            ChangeDropWithDropUnlockLineOptGroup::Wo(
                change_drop_with_drop_unlock_line_opt_group_1_built,
            );
        self.push(
            ASTType::ChangeDropWithDropUnlockLineOptGroup(
                change_drop_with_drop_unlock_line_opt_group_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// ChangeDropWithDropUnlockLineOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_with_drop_unlock_line_opt_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ChangeDropWithDropUnlockLineOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// StartsWithDropLine: Drops StartsWithDropLineSuffix0;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line(
        &mut self,
        _drops: &ParseTreeStackEntry<'t>,
        _starts_with_drop_line_suffix0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let starts_with_drop_line_suffix0 = pop_item!(
            self,
            starts_with_drop_line_suffix0,
            StartsWithDropLineSuffix0,
            context
        );
        let drops = pop_item!(self, drops, Drops, context);
        let starts_with_drop_line_built = StartsWithDropLineBuilder::default()
            .drops(Box::new(drops))
            .starts_with_drop_line_suffix0(Box::new(starts_with_drop_line_suffix0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .starts_with_drop_line(&starts_with_drop_line_built)?;
        self.push(
            ASTType::StartsWithDropLine(starts_with_drop_line_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// StartsWithDropLineSuffix0: Wo StartsWithDropLineSuffix;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_suffix0_0(
        &mut self,
        _wo: &ParseTreeStackEntry<'t>,
        _starts_with_drop_line_suffix: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let starts_with_drop_line_suffix = pop_item!(
            self,
            starts_with_drop_line_suffix,
            StartsWithDropLineSuffix,
            context
        );
        let wo = pop_item!(self, wo, Wo, context);
        let starts_with_drop_line_suffix0_0_built =
            StartsWithDropLineSuffix0WoStartsWithDropLineSuffixBuilder::default()
                .wo(Box::new(wo))
                .starts_with_drop_line_suffix(Box::new(starts_with_drop_line_suffix))
                .build()
                .into_diagnostic()?;
        let starts_with_drop_line_suffix0_0_built =
            StartsWithDropLineSuffix0::WoStartsWithDropLineSuffix(
                starts_with_drop_line_suffix0_0_built,
            );
        self.push(
            ASTType::StartsWithDropLineSuffix0(starts_with_drop_line_suffix0_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// StartsWithDropLineSuffix0: WordOther From GenRandomDropBlock WordGen;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_suffix0_1(
        &mut self,
        _word_other: &ParseTreeStackEntry<'t>,
        _from: &ParseTreeStackEntry<'t>,
        _gen_random_drop_block: &ParseTreeStackEntry<'t>,
        _word_gen: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_gen = pop_item!(self, word_gen, WordGen, context);
        let gen_random_drop_block =
            pop_item!(self, gen_random_drop_block, GenRandomDropBlock, context);
        let from = pop_item!(self, from, From, context);
        let word_other = pop_item!(self, word_other, WordOther, context);
        let starts_with_drop_line_suffix0_1_built =
            StartsWithDropLineSuffix0WordOtherFromGenRandomDropBlockWordGenBuilder::default()
                .word_other(Box::new(word_other))
                .from(Box::new(from))
                .gen_random_drop_block(Box::new(gen_random_drop_block))
                .word_gen(Box::new(word_gen))
                .build()
                .into_diagnostic()?;
        let starts_with_drop_line_suffix0_1_built =
            StartsWithDropLineSuffix0::WordOtherFromGenRandomDropBlockWordGen(
                starts_with_drop_line_suffix0_1_built,
            );
        self.push(
            ASTType::StartsWithDropLineSuffix0(starts_with_drop_line_suffix0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// StartsWithDropLineSuffix: Drop Ni StartsWithDropLineList /* Vec */ WordChange;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_suffix_0(
        &mut self,
        _drop: &ParseTreeStackEntry<'t>,
        _ni: &ParseTreeStackEntry<'t>,
        _starts_with_drop_line_list: &ParseTreeStackEntry<'t>,
        _word_change: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_change = pop_item!(self, word_change, WordChange, context);
        let starts_with_drop_line_list = pop_and_reverse_item!(
            self,
            starts_with_drop_line_list,
            StartsWithDropLineList,
            context
        );
        let ni = pop_item!(self, ni, Ni, context);
        let drop = pop_item!(self, drop, Drop, context);
        let starts_with_drop_line_suffix_0_built =
            StartsWithDropLineSuffixDropNiStartsWithDropLineListWordChangeBuilder::default()
                .drop(Box::new(drop))
                .ni(Box::new(ni))
                .starts_with_drop_line_list(starts_with_drop_line_list)
                .word_change(Box::new(word_change))
                .build()
                .into_diagnostic()?;
        let starts_with_drop_line_suffix_0_built =
            StartsWithDropLineSuffix::DropNiStartsWithDropLineListWordChange(
                starts_with_drop_line_suffix_0_built,
            );
        self.push(
            ASTType::StartsWithDropLineSuffix(starts_with_drop_line_suffix_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// StartsWithDropLineSuffix: RandomSuffix Drops Ni WordChange;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_suffix_1(
        &mut self,
        _random_suffix: &ParseTreeStackEntry<'t>,
        _drops: &ParseTreeStackEntry<'t>,
        _ni: &ParseTreeStackEntry<'t>,
        _word_change: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_change = pop_item!(self, word_change, WordChange, context);
        let ni = pop_item!(self, ni, Ni, context);
        let drops = pop_item!(self, drops, Drops, context);
        let random_suffix = pop_item!(self, random_suffix, RandomSuffix, context);
        let starts_with_drop_line_suffix_1_built =
            StartsWithDropLineSuffixRandomSuffixDropsNiWordChangeBuilder::default()
                .random_suffix(Box::new(random_suffix))
                .drops(Box::new(drops))
                .ni(Box::new(ni))
                .word_change(Box::new(word_change))
                .build()
                .into_diagnostic()?;
        let starts_with_drop_line_suffix_1_built =
            StartsWithDropLineSuffix::RandomSuffixDropsNiWordChange(
                starts_with_drop_line_suffix_1_built,
            );
        self.push(
            ASTType::StartsWithDropLineSuffix(starts_with_drop_line_suffix_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// StartsWithDropLineSuffix: Quantity StartsWithDropLineList0 /* Vec */ WordGen;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_suffix_2(
        &mut self,
        _quantity: &ParseTreeStackEntry<'t>,
        _starts_with_drop_line_list0: &ParseTreeStackEntry<'t>,
        _word_gen: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_gen = pop_item!(self, word_gen, WordGen, context);
        let starts_with_drop_line_list0 = pop_and_reverse_item!(
            self,
            starts_with_drop_line_list0,
            StartsWithDropLineList0,
            context
        );
        let quantity = pop_item!(self, quantity, Quantity, context);
        let starts_with_drop_line_suffix_2_built =
            StartsWithDropLineSuffixQuantityStartsWithDropLineList0WordGenBuilder::default()
                .quantity(Box::new(quantity))
                .starts_with_drop_line_list0(starts_with_drop_line_list0)
                .word_gen(Box::new(word_gen))
                .build()
                .into_diagnostic()?;
        let starts_with_drop_line_suffix_2_built =
            StartsWithDropLineSuffix::QuantityStartsWithDropLineList0WordGen(
                starts_with_drop_line_suffix_2_built,
            );
        self.push(
            ASTType::StartsWithDropLineSuffix(starts_with_drop_line_suffix_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// StartsWithDropLineSuffix: StartsWithDropLineOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_suffix_3(
        &mut self,
        _starts_with_drop_line_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let starts_with_drop_line_opt = pop_item!(
            self,
            starts_with_drop_line_opt,
            StartsWithDropLineOpt,
            context
        );
        let starts_with_drop_line_suffix_3_built =
            StartsWithDropLineSuffixStartsWithDropLineOptBuilder::default()
                .starts_with_drop_line_opt(starts_with_drop_line_opt)
                .build()
                .into_diagnostic()?;
        let starts_with_drop_line_suffix_3_built =
            StartsWithDropLineSuffix::StartsWithDropLineOpt(starts_with_drop_line_suffix_3_built);
        self.push(
            ASTType::StartsWithDropLineSuffix(starts_with_drop_line_suffix_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// StartsWithDropLineList /* Vec<T>::Push */: Camma ChangeDropBlockOtherFirst StartsWithDropLineList;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_list_0(
        &mut self,
        _camma: &ParseTreeStackEntry<'t>,
        _change_drop_block_other_first: &ParseTreeStackEntry<'t>,
        _starts_with_drop_line_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut starts_with_drop_line_list = pop_item!(
            self,
            starts_with_drop_line_list,
            StartsWithDropLineList,
            context
        );
        let change_drop_block_other_first = pop_item!(
            self,
            change_drop_block_other_first,
            ChangeDropBlockOtherFirst,
            context
        );
        let camma = pop_item!(self, camma, Camma, context);
        let starts_with_drop_line_list_0_built = StartsWithDropLineListBuilder::default()
            .change_drop_block_other_first(Box::new(change_drop_block_other_first))
            .camma(Box::new(camma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        starts_with_drop_line_list.push(starts_with_drop_line_list_0_built);
        self.push(
            ASTType::StartsWithDropLineList(starts_with_drop_line_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// StartsWithDropLineList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let starts_with_drop_line_list_1_built = Vec::new();
        self.push(
            ASTType::StartsWithDropLineList(starts_with_drop_line_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// StartsWithDropLineList0 /* Vec<T>::Push */: Camma GenRandomDropBlock StartsWithDropLineList0;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_list0_0(
        &mut self,
        _camma: &ParseTreeStackEntry<'t>,
        _gen_random_drop_block: &ParseTreeStackEntry<'t>,
        _starts_with_drop_line_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut starts_with_drop_line_list0 = pop_item!(
            self,
            starts_with_drop_line_list0,
            StartsWithDropLineList0,
            context
        );
        let gen_random_drop_block =
            pop_item!(self, gen_random_drop_block, GenRandomDropBlock, context);
        let camma = pop_item!(self, camma, Camma, context);
        let starts_with_drop_line_list0_0_built = StartsWithDropLineList0Builder::default()
            .gen_random_drop_block(Box::new(gen_random_drop_block))
            .camma(Box::new(camma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        starts_with_drop_line_list0.push(starts_with_drop_line_list0_0_built);
        self.push(
            ASTType::StartsWithDropLineList0(starts_with_drop_line_list0),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// StartsWithDropLineList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_list0_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let starts_with_drop_line_list0_1_built = Vec::new();
        self.push(
            ASTType::StartsWithDropLineList0(starts_with_drop_line_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// StartsWithDropLineOpt /* Option<T>::Some */: StartsWithDropLineOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_opt_0(
        &mut self,
        _starts_with_drop_line_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let starts_with_drop_line_opt_group = pop_item!(
            self,
            starts_with_drop_line_opt_group,
            StartsWithDropLineOptGroup,
            context
        );
        let starts_with_drop_line_opt_0_built = StartsWithDropLineOptBuilder::default()
            .starts_with_drop_line_opt_group(Box::new(starts_with_drop_line_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StartsWithDropLineOpt(Some(Box::new(starts_with_drop_line_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// StartsWithDropLineOptGroup: WordPowerUp;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_opt_group_0(
        &mut self,
        _word_power_up: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_power_up = pop_item!(self, word_power_up, WordPowerUp, context);
        let starts_with_drop_line_opt_group_0_built =
            StartsWithDropLineOptGroupWordPowerUpBuilder::default()
                .word_power_up(Box::new(word_power_up))
                .build()
                .into_diagnostic()?;
        let starts_with_drop_line_opt_group_0_built =
            StartsWithDropLineOptGroup::WordPowerUp(starts_with_drop_line_opt_group_0_built);
        self.push(
            ASTType::StartsWithDropLineOptGroup(starts_with_drop_line_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// StartsWithDropLineOptGroup: WordLock;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_opt_group_1(
        &mut self,
        _word_lock: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_lock = pop_item!(self, word_lock, WordLock, context);
        let starts_with_drop_line_opt_group_1_built =
            StartsWithDropLineOptGroupWordLockBuilder::default()
                .word_lock(Box::new(word_lock))
                .build()
                .into_diagnostic()?;
        let starts_with_drop_line_opt_group_1_built =
            StartsWithDropLineOptGroup::WordLock(starts_with_drop_line_opt_group_1_built);
        self.push(
            ASTType::StartsWithDropLineOptGroup(starts_with_drop_line_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// StartsWithDropLineOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn starts_with_drop_line_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StartsWithDropLineOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// GenRandomDropStmt: RandomSuffix GenRandomDropBlock GenRandomDropStmtList /* Vec */ WordGen;
    ///
    #[parol_runtime::function_name::named]
    fn gen_random_drop_stmt(
        &mut self,
        _random_suffix: &ParseTreeStackEntry<'t>,
        _gen_random_drop_block: &ParseTreeStackEntry<'t>,
        _gen_random_drop_stmt_list: &ParseTreeStackEntry<'t>,
        _word_gen: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_gen = pop_item!(self, word_gen, WordGen, context);
        let gen_random_drop_stmt_list = pop_and_reverse_item!(
            self,
            gen_random_drop_stmt_list,
            GenRandomDropStmtList,
            context
        );
        let gen_random_drop_block =
            pop_item!(self, gen_random_drop_block, GenRandomDropBlock, context);
        let random_suffix = pop_item!(self, random_suffix, RandomSuffix, context);
        let gen_random_drop_stmt_built = GenRandomDropStmtBuilder::default()
            .random_suffix(Box::new(random_suffix))
            .gen_random_drop_block(Box::new(gen_random_drop_block))
            .gen_random_drop_stmt_list(gen_random_drop_stmt_list)
            .word_gen(Box::new(word_gen))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .gen_random_drop_stmt(&gen_random_drop_stmt_built)?;
        self.push(
            ASTType::GenRandomDropStmt(gen_random_drop_stmt_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// GenRandomDropStmtList /* Vec<T>::Push */: Camma GenRandomDropBlock GenRandomDropStmtList;
    ///
    #[parol_runtime::function_name::named]
    fn gen_random_drop_stmt_list_0(
        &mut self,
        _camma: &ParseTreeStackEntry<'t>,
        _gen_random_drop_block: &ParseTreeStackEntry<'t>,
        _gen_random_drop_stmt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut gen_random_drop_stmt_list = pop_item!(
            self,
            gen_random_drop_stmt_list,
            GenRandomDropStmtList,
            context
        );
        let gen_random_drop_block =
            pop_item!(self, gen_random_drop_block, GenRandomDropBlock, context);
        let camma = pop_item!(self, camma, Camma, context);
        let gen_random_drop_stmt_list_0_built = GenRandomDropStmtListBuilder::default()
            .gen_random_drop_block(Box::new(gen_random_drop_block))
            .camma(Box::new(camma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        gen_random_drop_stmt_list.push(gen_random_drop_stmt_list_0_built);
        self.push(
            ASTType::GenRandomDropStmtList(gen_random_drop_stmt_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// GenRandomDropStmtList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn gen_random_drop_stmt_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_random_drop_stmt_list_1_built = Vec::new();
        self.push(
            ASTType::GenRandomDropStmtList(gen_random_drop_stmt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// GenRandomDropBlock: Drops Wo Quantity;
    ///
    #[parol_runtime::function_name::named]
    fn gen_random_drop_block(
        &mut self,
        _drops: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _quantity: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quantity = pop_item!(self, quantity, Quantity, context);
        let wo = pop_item!(self, wo, Wo, context);
        let drops = pop_item!(self, drops, Drops, context);
        let gen_random_drop_block_built = GenRandomDropBlockBuilder::default()
            .drops(Box::new(drops))
            .wo(Box::new(wo))
            .quantity(Box::new(quantity))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .gen_random_drop_block(&gen_random_drop_block_built)?;
        self.push(
            ASTType::GenRandomDropBlock(gen_random_drop_block_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// GenShapeStmt: GenShapeBlock GenShapeStmtOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_stmt(
        &mut self,
        _gen_shape_block: &ParseTreeStackEntry<'t>,
        _gen_shape_stmt_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_shape_stmt_opt = pop_item!(self, gen_shape_stmt_opt, GenShapeStmtOpt, context);
        let gen_shape_block = pop_item!(self, gen_shape_block, GenShapeBlock, context);
        let gen_shape_stmt_built = GenShapeStmtBuilder::default()
            .gen_shape_block(Box::new(gen_shape_block))
            .gen_shape_stmt_opt(gen_shape_stmt_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.gen_shape_stmt(&gen_shape_stmt_built)?;
        self.push(ASTType::GenShapeStmt(gen_shape_stmt_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// GenShapeStmtOpt /* Option<T>::Some */: GenShapeStmtOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_stmt_opt_0(
        &mut self,
        _gen_shape_stmt_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_shape_stmt_opt_group = pop_item!(
            self,
            gen_shape_stmt_opt_group,
            GenShapeStmtOptGroup,
            context
        );
        let gen_shape_stmt_opt_0_built = GenShapeStmtOptBuilder::default()
            .gen_shape_stmt_opt_group(Box::new(gen_shape_stmt_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::GenShapeStmtOpt(Some(Box::new(gen_shape_stmt_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// GenShapeStmtOptGroup: WordChange;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_stmt_opt_group_0(
        &mut self,
        _word_change: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_change = pop_item!(self, word_change, WordChange, context);
        let gen_shape_stmt_opt_group_0_built = GenShapeStmtOptGroupWordChangeBuilder::default()
            .word_change(Box::new(word_change))
            .build()
            .into_diagnostic()?;
        let gen_shape_stmt_opt_group_0_built =
            GenShapeStmtOptGroup::WordChange(gen_shape_stmt_opt_group_0_built);
        self.push(
            ASTType::GenShapeStmtOptGroup(gen_shape_stmt_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// GenShapeStmtOptGroup: WordGen;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_stmt_opt_group_1(
        &mut self,
        _word_gen: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_gen = pop_item!(self, word_gen, WordGen, context);
        let gen_shape_stmt_opt_group_1_built = GenShapeStmtOptGroupWordGenBuilder::default()
            .word_gen(Box::new(word_gen))
            .build()
            .into_diagnostic()?;
        let gen_shape_stmt_opt_group_1_built =
            GenShapeStmtOptGroup::WordGen(gen_shape_stmt_opt_group_1_built);
        self.push(
            ASTType::GenShapeStmtOptGroup(gen_shape_stmt_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// GenShapeStmtOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_stmt_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GenShapeStmtOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// DropRefreshStmt: RandomSuffix WordDrop Wo WordReplace;
    ///
    #[parol_runtime::function_name::named]
    fn drop_refresh_stmt(
        &mut self,
        _random_suffix: &ParseTreeStackEntry<'t>,
        _word_drop: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _word_replace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_replace = pop_item!(self, word_replace, WordReplace, context);
        let wo = pop_item!(self, wo, Wo, context);
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let random_suffix = pop_item!(self, random_suffix, RandomSuffix, context);
        let drop_refresh_stmt_built = DropRefreshStmtBuilder::default()
            .random_suffix(Box::new(random_suffix))
            .word_drop(Box::new(word_drop))
            .wo(Box::new(wo))
            .word_replace(Box::new(word_replace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .drop_refresh_stmt(&drop_refresh_stmt_built)?;
        self.push(ASTType::DropRefreshStmt(drop_refresh_stmt_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// DropUnLockStmt: WordDrop No WordLock WordState Wo WordRelease;
    ///
    #[parol_runtime::function_name::named]
    fn drop_un_lock_stmt(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _no: &ParseTreeStackEntry<'t>,
        _word_lock: &ParseTreeStackEntry<'t>,
        _word_state: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _word_release: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_release = pop_item!(self, word_release, WordRelease, context);
        let wo = pop_item!(self, wo, Wo, context);
        let word_state = pop_item!(self, word_state, WordState, context);
        let word_lock = pop_item!(self, word_lock, WordLock, context);
        let no = pop_item!(self, no, No, context);
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let drop_un_lock_stmt_built = DropUnLockStmtBuilder::default()
            .word_drop(Box::new(word_drop))
            .no(Box::new(no))
            .word_lock(Box::new(word_lock))
            .word_state(Box::new(word_state))
            .wo(Box::new(wo))
            .word_release(Box::new(word_release))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .drop_un_lock_stmt(&drop_un_lock_stmt_built)?;
        self.push(ASTType::DropUnLockStmt(drop_un_lock_stmt_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// TurnsOfApplyStmt: Turns TurnsOfApplyBlock;
    ///
    #[parol_runtime::function_name::named]
    fn turns_of_apply_stmt(
        &mut self,
        _turns: &ParseTreeStackEntry<'t>,
        _turns_of_apply_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let turns_of_apply_block =
            pop_item!(self, turns_of_apply_block, TurnsOfApplyBlock, context);
        let turns = pop_item!(self, turns, Turns, context);
        let turns_of_apply_stmt_built = TurnsOfApplyStmtBuilder::default()
            .turns(Box::new(turns))
            .turns_of_apply_block(Box::new(turns_of_apply_block))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .turns_of_apply_stmt(&turns_of_apply_stmt_built)?;
        self.push(
            ASTType::TurnsOfApplyStmt(turns_of_apply_stmt_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// ChangeDropBlockOtherFirst: Drops Wo Drop Ni;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_block_other_first(
        &mut self,
        _drops: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _ni: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ni = pop_item!(self, ni, Ni, context);
        let drop = pop_item!(self, drop, Drop, context);
        let wo = pop_item!(self, wo, Wo, context);
        let drops = pop_item!(self, drops, Drops, context);
        let change_drop_block_other_first_built = ChangeDropBlockOtherFirstBuilder::default()
            .drops(Box::new(drops))
            .wo(Box::new(wo))
            .drop(Box::new(drop))
            .ni(Box::new(ni))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .change_drop_block_other_first(&change_drop_block_other_first_built)?;
        self.push(
            ASTType::ChangeDropBlockOtherFirst(change_drop_block_other_first_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// GenShapeBlock: GenShapeBlockRowCol GenShapeBlockList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_block_0(
        &mut self,
        _gen_shape_block_row_col: &ParseTreeStackEntry<'t>,
        _gen_shape_block_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_shape_block_list =
            pop_and_reverse_item!(self, gen_shape_block_list, GenShapeBlockList, context);
        let gen_shape_block_row_col =
            pop_item!(self, gen_shape_block_row_col, GenShapeBlockRowCol, context);
        let gen_shape_block_0_built =
            GenShapeBlockGenShapeBlockRowColGenShapeBlockListBuilder::default()
                .gen_shape_block_row_col(Box::new(gen_shape_block_row_col))
                .gen_shape_block_list(gen_shape_block_list)
                .build()
                .into_diagnostic()?;
        let gen_shape_block_0_built =
            GenShapeBlock::GenShapeBlockRowColGenShapeBlockList(gen_shape_block_0_built);
        // Calling user action here
        self.user_grammar
            .gen_shape_block(&gen_shape_block_0_built)?;
        self.push(ASTType::GenShapeBlock(gen_shape_block_0_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// GenShapeBlockList /* Vec<T>::Push */: Camma GenShapeBlockRowCol GenShapeBlockList;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_block_list_0(
        &mut self,
        _camma: &ParseTreeStackEntry<'t>,
        _gen_shape_block_row_col: &ParseTreeStackEntry<'t>,
        _gen_shape_block_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut gen_shape_block_list =
            pop_item!(self, gen_shape_block_list, GenShapeBlockList, context);
        let gen_shape_block_row_col =
            pop_item!(self, gen_shape_block_row_col, GenShapeBlockRowCol, context);
        let camma = pop_item!(self, camma, Camma, context);
        let gen_shape_block_list_0_built = GenShapeBlockListBuilder::default()
            .gen_shape_block_row_col(Box::new(gen_shape_block_row_col))
            .camma(Box::new(camma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        gen_shape_block_list.push(gen_shape_block_list_0_built);
        self.push(ASTType::GenShapeBlockList(gen_shape_block_list), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// GenShapeBlockList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_block_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_shape_block_list_1_built = Vec::new();
        self.push(
            ASTType::GenShapeBlockList(gen_shape_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// GenShapeBlock: GenShapeBlockOtherRowCol;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_block_1(
        &mut self,
        _gen_shape_block_other_row_col: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_shape_block_other_row_col = pop_item!(
            self,
            gen_shape_block_other_row_col,
            GenShapeBlockOtherRowCol,
            context
        );
        let gen_shape_block_1_built = GenShapeBlockGenShapeBlockOtherRowColBuilder::default()
            .gen_shape_block_other_row_col(Box::new(gen_shape_block_other_row_col))
            .build()
            .into_diagnostic()?;
        let gen_shape_block_1_built =
            GenShapeBlock::GenShapeBlockOtherRowCol(gen_shape_block_1_built);
        // Calling user action here
        self.user_grammar
            .gen_shape_block(&gen_shape_block_1_built)?;
        self.push(ASTType::GenShapeBlock(gen_shape_block_1_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// GenShapeBlockRowCol: GSStartPosition Wo Drop Ni;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_block_row_col(
        &mut self,
        _g_s_start_position: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _ni: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ni = pop_item!(self, ni, Ni, context);
        let drop = pop_item!(self, drop, Drop, context);
        let wo = pop_item!(self, wo, Wo, context);
        let g_s_start_position = pop_item!(self, g_s_start_position, GSStartPosition, context);
        let gen_shape_block_row_col_built = GenShapeBlockRowColBuilder::default()
            .g_s_start_position(Box::new(g_s_start_position))
            .wo(Box::new(wo))
            .drop(Box::new(drop))
            .ni(Box::new(ni))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .gen_shape_block_row_col(&gen_shape_block_row_col_built)?;
        self.push(
            ASTType::GenShapeBlockRowCol(gen_shape_block_row_col_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// GenShapeBlockOtherRowCol: ShapeType GenShapeBlockOtherRowColSuffix;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_block_other_row_col(
        &mut self,
        _shape_type: &ParseTreeStackEntry<'t>,
        _gen_shape_block_other_row_col_suffix: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_shape_block_other_row_col_suffix = pop_item!(
            self,
            gen_shape_block_other_row_col_suffix,
            GenShapeBlockOtherRowColSuffix,
            context
        );
        let shape_type = pop_item!(self, shape_type, ShapeType, context);
        let gen_shape_block_other_row_col_built = GenShapeBlockOtherRowColBuilder::default()
            .shape_type(Box::new(shape_type))
            .gen_shape_block_other_row_col_suffix(Box::new(gen_shape_block_other_row_col_suffix))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .gen_shape_block_other_row_col(&gen_shape_block_other_row_col_built)?;
        self.push(
            ASTType::GenShapeBlockOtherRowCol(gen_shape_block_other_row_col_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// GenShapeBlockOtherRowColSuffix: Ni Drops Wo GenShapeBlockOtherRowColOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_block_other_row_col_suffix_0(
        &mut self,
        _ni: &ParseTreeStackEntry<'t>,
        _drops: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _gen_shape_block_other_row_col_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_shape_block_other_row_col_opt = pop_item!(
            self,
            gen_shape_block_other_row_col_opt,
            GenShapeBlockOtherRowColOpt,
            context
        );
        let wo = pop_item!(self, wo, Wo, context);
        let drops = pop_item!(self, drops, Drops, context);
        let ni = pop_item!(self, ni, Ni, context);
        let gen_shape_block_other_row_col_suffix_0_built =
            GenShapeBlockOtherRowColSuffixNiDropsWoGenShapeBlockOtherRowColOptBuilder::default()
                .ni(Box::new(ni))
                .drops(Box::new(drops))
                .wo(Box::new(wo))
                .gen_shape_block_other_row_col_opt(gen_shape_block_other_row_col_opt)
                .build()
                .into_diagnostic()?;
        let gen_shape_block_other_row_col_suffix_0_built =
            GenShapeBlockOtherRowColSuffix::NiDropsWoGenShapeBlockOtherRowColOpt(
                gen_shape_block_other_row_col_suffix_0_built,
            );
        self.push(
            ASTType::GenShapeBlockOtherRowColSuffix(gen_shape_block_other_row_col_suffix_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// GenShapeBlockOtherRowColSuffix: Wo Drops Ni;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_block_other_row_col_suffix_1(
        &mut self,
        _wo: &ParseTreeStackEntry<'t>,
        _drops: &ParseTreeStackEntry<'t>,
        _ni: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ni = pop_item!(self, ni, Ni, context);
        let drops = pop_item!(self, drops, Drops, context);
        let wo = pop_item!(self, wo, Wo, context);
        let gen_shape_block_other_row_col_suffix_1_built =
            GenShapeBlockOtherRowColSuffixWoDropsNiBuilder::default()
                .wo(Box::new(wo))
                .drops(Box::new(drops))
                .ni(Box::new(ni))
                .build()
                .into_diagnostic()?;
        let gen_shape_block_other_row_col_suffix_1_built =
            GenShapeBlockOtherRowColSuffix::WoDropsNi(gen_shape_block_other_row_col_suffix_1_built);
        self.push(
            ASTType::GenShapeBlockOtherRowColSuffix(gen_shape_block_other_row_col_suffix_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// GenShapeBlockOtherRowColOpt /* Option<T>::Some */: Quantity;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_block_other_row_col_opt_0(
        &mut self,
        _quantity: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quantity = pop_item!(self, quantity, Quantity, context);
        let gen_shape_block_other_row_col_opt_0_built =
            GenShapeBlockOtherRowColOptBuilder::default()
                .quantity(Box::new(quantity))
                .build()
                .into_diagnostic()?;
        self.push(
            ASTType::GenShapeBlockOtherRowColOpt(Some(Box::new(
                gen_shape_block_other_row_col_opt_0_built,
            ))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// GenShapeBlockOtherRowColOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_block_other_row_col_opt_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GenShapeBlockOtherRowColOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// GSStartPosition: GSSPSide;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_start_position_0(
        &mut self,
        _g_s_s_p_side: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_s_s_p_side = pop_item!(self, g_s_s_p_side, GSSPSide, context);
        let g_s_start_position_0_built = GSStartPositionGSSPSideBuilder::default()
            .g_s_s_p_side(Box::new(g_s_s_p_side))
            .build()
            .into_diagnostic()?;
        let g_s_start_position_0_built = GSStartPosition::GSSPSide(g_s_start_position_0_built);
        // Calling user action here
        self.user_grammar
            .g_s_start_position(&g_s_start_position_0_built)?;
        self.push(
            ASTType::GSStartPosition(g_s_start_position_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// GSStartPosition: GSSPCenter;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_start_position_1(
        &mut self,
        _g_s_s_p_center: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_s_s_p_center = pop_item!(self, g_s_s_p_center, GSSPCenter, context);
        let g_s_start_position_1_built = GSStartPositionGSSPCenterBuilder::default()
            .g_s_s_p_center(Box::new(g_s_s_p_center))
            .build()
            .into_diagnostic()?;
        let g_s_start_position_1_built = GSStartPosition::GSSPCenter(g_s_start_position_1_built);
        // Calling user action here
        self.user_grammar
            .g_s_start_position(&g_s_start_position_1_built)?;
        self.push(
            ASTType::GSStartPosition(g_s_start_position_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// GSSPSide: Position GSSPSideOpt /* Option */ GenShapeNumOfGen GSSPSideOpt0 /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_side(
        &mut self,
        _position: &ParseTreeStackEntry<'t>,
        _g_s_s_p_side_opt: &ParseTreeStackEntry<'t>,
        _gen_shape_num_of_gen: &ParseTreeStackEntry<'t>,
        _g_s_s_p_side_opt0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_s_s_p_side_opt0 = pop_item!(self, g_s_s_p_side_opt0, GSSPSideOpt0, context);
        let gen_shape_num_of_gen = pop_item!(self, gen_shape_num_of_gen, GenShapeNumOfGen, context);
        let g_s_s_p_side_opt = pop_item!(self, g_s_s_p_side_opt, GSSPSideOpt, context);
        let position = pop_item!(self, position, Position, context);
        let g_s_s_p_side_built = GSSPSideBuilder::default()
            .position(Box::new(position))
            .g_s_s_p_side_opt(g_s_s_p_side_opt)
            .gen_shape_num_of_gen(Box::new(gen_shape_num_of_gen))
            .g_s_s_p_side_opt0(g_s_s_p_side_opt0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.g_s_s_p_side(&g_s_s_p_side_built)?;
        self.push(ASTType::GSSPSide(g_s_s_p_side_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// GSSPSideOpt0 /* Option<T>::Some */: And Position GSSPSideOpt1 /* Option */ GenShapeNumOfGen;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_side_opt0_0(
        &mut self,
        _and: &ParseTreeStackEntry<'t>,
        _position: &ParseTreeStackEntry<'t>,
        _g_s_s_p_side_opt1: &ParseTreeStackEntry<'t>,
        _gen_shape_num_of_gen: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_shape_num_of_gen = pop_item!(self, gen_shape_num_of_gen, GenShapeNumOfGen, context);
        let g_s_s_p_side_opt1 = pop_item!(self, g_s_s_p_side_opt1, GSSPSideOpt1, context);
        let position = pop_item!(self, position, Position, context);
        let and = pop_item!(self, and, And, context);
        let g_s_s_p_side_opt0_0_built = GSSPSideOpt0Builder::default()
            .and(Box::new(and))
            .position(Box::new(position))
            .g_s_s_p_side_opt1(g_s_s_p_side_opt1)
            .gen_shape_num_of_gen(Box::new(gen_shape_num_of_gen))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::GSSPSideOpt0(Some(Box::new(g_s_s_p_side_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// GSSPSideOpt1 /* Option<T>::Some */: WordHorizon;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_side_opt1_0(
        &mut self,
        _word_horizon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_horizon = pop_item!(self, word_horizon, WordHorizon, context);
        let g_s_s_p_side_opt1_0_built = GSSPSideOpt1Builder::default()
            .word_horizon(Box::new(word_horizon))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::GSSPSideOpt1(Some(Box::new(g_s_s_p_side_opt1_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// GSSPSideOpt1 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_side_opt1_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GSSPSideOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// GSSPSideOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_side_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GSSPSideOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// GSSPSideOpt /* Option<T>::Some */: WordHorizon;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_side_opt_0(
        &mut self,
        _word_horizon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_horizon = pop_item!(self, word_horizon, WordHorizon, context);
        let g_s_s_p_side_opt_0_built = GSSPSideOptBuilder::default()
            .word_horizon(Box::new(word_horizon))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::GSSPSideOpt(Some(Box::new(g_s_s_p_side_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// GSSPSideOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_side_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GSSPSideOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// GSSPCenter: GSSPCenterBlocks GSSPCenterOpt /* Option */ GSSPCenterOpt0 /* Option */ GenShapeNumOfGen;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center(
        &mut self,
        _g_s_s_p_center_blocks: &ParseTreeStackEntry<'t>,
        _g_s_s_p_center_opt: &ParseTreeStackEntry<'t>,
        _g_s_s_p_center_opt0: &ParseTreeStackEntry<'t>,
        _gen_shape_num_of_gen: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_shape_num_of_gen = pop_item!(self, gen_shape_num_of_gen, GenShapeNumOfGen, context);
        let g_s_s_p_center_opt0 = pop_item!(self, g_s_s_p_center_opt0, GSSPCenterOpt0, context);
        let g_s_s_p_center_opt = pop_item!(self, g_s_s_p_center_opt, GSSPCenterOpt, context);
        let g_s_s_p_center_blocks =
            pop_item!(self, g_s_s_p_center_blocks, GSSPCenterBlocks, context);
        let g_s_s_p_center_built = GSSPCenterBuilder::default()
            .g_s_s_p_center_blocks(Box::new(g_s_s_p_center_blocks))
            .g_s_s_p_center_opt(g_s_s_p_center_opt)
            .g_s_s_p_center_opt0(g_s_s_p_center_opt0)
            .gen_shape_num_of_gen(Box::new(gen_shape_num_of_gen))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.g_s_s_p_center(&g_s_s_p_center_built)?;
        self.push(ASTType::GSSPCenter(g_s_s_p_center_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// GSSPCenterOpt0 /* Option<T>::Some */: GSSPCenterOpt0Group;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_opt0_0(
        &mut self,
        _g_s_s_p_center_opt0_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_s_s_p_center_opt0_group = pop_item!(
            self,
            g_s_s_p_center_opt0_group,
            GSSPCenterOpt0Group,
            context
        );
        let g_s_s_p_center_opt0_0_built = GSSPCenterOpt0Builder::default()
            .g_s_s_p_center_opt0_group(Box::new(g_s_s_p_center_opt0_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::GSSPCenterOpt0(Some(Box::new(g_s_s_p_center_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// GSSPCenterOpt0Group: WordVertical;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_opt0_group_0(
        &mut self,
        _word_vertical: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_vertical = pop_item!(self, word_vertical, WordVertical, context);
        let g_s_s_p_center_opt0_group_0_built = GSSPCenterOpt0GroupWordVerticalBuilder::default()
            .word_vertical(Box::new(word_vertical))
            .build()
            .into_diagnostic()?;
        let g_s_s_p_center_opt0_group_0_built =
            GSSPCenterOpt0Group::WordVertical(g_s_s_p_center_opt0_group_0_built);
        self.push(
            ASTType::GSSPCenterOpt0Group(g_s_s_p_center_opt0_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// GSSPCenterOpt0Group: WordHorizon;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_opt0_group_1(
        &mut self,
        _word_horizon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_horizon = pop_item!(self, word_horizon, WordHorizon, context);
        let g_s_s_p_center_opt0_group_1_built = GSSPCenterOpt0GroupWordHorizonBuilder::default()
            .word_horizon(Box::new(word_horizon))
            .build()
            .into_diagnostic()?;
        let g_s_s_p_center_opt0_group_1_built =
            GSSPCenterOpt0Group::WordHorizon(g_s_s_p_center_opt0_group_1_built);
        self.push(
            ASTType::GSSPCenterOpt0Group(g_s_s_p_center_opt0_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// GSSPCenterOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GSSPCenterOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// GSSPCenterOpt /* Option<T>::Some */: No;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_opt_0(
        &mut self,
        _no: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let no = pop_item!(self, no, No, context);
        let g_s_s_p_center_opt_0_built = GSSPCenterOptBuilder::default()
            .no(Box::new(no))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::GSSPCenterOpt(Some(Box::new(g_s_s_p_center_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// GSSPCenterOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GSSPCenterOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// GSSPCenterBlocks: GSSPCenterBlock GSSPCenterBlocksOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_blocks(
        &mut self,
        _g_s_s_p_center_block: &ParseTreeStackEntry<'t>,
        _g_s_s_p_center_blocks_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_s_s_p_center_blocks_opt = pop_item!(
            self,
            g_s_s_p_center_blocks_opt,
            GSSPCenterBlocksOpt,
            context
        );
        let g_s_s_p_center_block = pop_item!(self, g_s_s_p_center_block, GSSPCenterBlock, context);
        let g_s_s_p_center_blocks_built = GSSPCenterBlocksBuilder::default()
            .g_s_s_p_center_block(Box::new(g_s_s_p_center_block))
            .g_s_s_p_center_blocks_opt(g_s_s_p_center_blocks_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .g_s_s_p_center_blocks(&g_s_s_p_center_blocks_built)?;
        self.push(
            ASTType::GSSPCenterBlocks(g_s_s_p_center_blocks_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// GSSPCenterBlocksOpt /* Option<T>::Some */: And GSSPCenterBlock;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_blocks_opt_0(
        &mut self,
        _and: &ParseTreeStackEntry<'t>,
        _g_s_s_p_center_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_s_s_p_center_block = pop_item!(self, g_s_s_p_center_block, GSSPCenterBlock, context);
        let and = pop_item!(self, and, And, context);
        let g_s_s_p_center_blocks_opt_0_built = GSSPCenterBlocksOptBuilder::default()
            .and(Box::new(and))
            .g_s_s_p_center_block(Box::new(g_s_s_p_center_block))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::GSSPCenterBlocksOpt(Some(Box::new(g_s_s_p_center_blocks_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// GSSPCenterBlocksOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_blocks_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GSSPCenterBlocksOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// GSSPCenterBlock: PositionLRTB From PosInt GSSPCenterBlockOpt /* Option */ WordLook;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_block(
        &mut self,
        _position_l_r_t_b: &ParseTreeStackEntry<'t>,
        _from: &ParseTreeStackEntry<'t>,
        _pos_int: &ParseTreeStackEntry<'t>,
        _g_s_s_p_center_block_opt: &ParseTreeStackEntry<'t>,
        _word_look: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_look = pop_item!(self, word_look, WordLook, context);
        let g_s_s_p_center_block_opt =
            pop_item!(self, g_s_s_p_center_block_opt, GSSPCenterBlockOpt, context);
        let pos_int = pop_item!(self, pos_int, PosInt, context);
        let from = pop_item!(self, from, From, context);
        let position_l_r_t_b = pop_item!(self, position_l_r_t_b, PositionLRTB, context);
        let g_s_s_p_center_block_built = GSSPCenterBlockBuilder::default()
            .position_l_r_t_b(Box::new(position_l_r_t_b))
            .from(Box::new(from))
            .pos_int(Box::new(pos_int))
            .g_s_s_p_center_block_opt(g_s_s_p_center_block_opt)
            .word_look(Box::new(word_look))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .g_s_s_p_center_block(&g_s_s_p_center_block_built)?;
        self.push(
            ASTType::GSSPCenterBlock(g_s_s_p_center_block_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// GSSPCenterBlockOpt /* Option<T>::Some */: GSSPCenterBlockOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_block_opt_0(
        &mut self,
        _g_s_s_p_center_block_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_s_s_p_center_block_opt_group = pop_item!(
            self,
            g_s_s_p_center_block_opt_group,
            GSSPCenterBlockOptGroup,
            context
        );
        let g_s_s_p_center_block_opt_0_built = GSSPCenterBlockOptBuilder::default()
            .g_s_s_p_center_block_opt_group(Box::new(g_s_s_p_center_block_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::GSSPCenterBlockOpt(Some(Box::new(g_s_s_p_center_block_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// GSSPCenterBlockOptGroup: WordCol;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_block_opt_group_0(
        &mut self,
        _word_col: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_col = pop_item!(self, word_col, WordCol, context);
        let g_s_s_p_center_block_opt_group_0_built =
            GSSPCenterBlockOptGroupWordColBuilder::default()
                .word_col(Box::new(word_col))
                .build()
                .into_diagnostic()?;
        let g_s_s_p_center_block_opt_group_0_built =
            GSSPCenterBlockOptGroup::WordCol(g_s_s_p_center_block_opt_group_0_built);
        self.push(
            ASTType::GSSPCenterBlockOptGroup(g_s_s_p_center_block_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// GSSPCenterBlockOptGroup: WordRow;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_block_opt_group_1(
        &mut self,
        _word_row: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_row = pop_item!(self, word_row, WordRow, context);
        let g_s_s_p_center_block_opt_group_1_built =
            GSSPCenterBlockOptGroupWordRowBuilder::default()
                .word_row(Box::new(word_row))
                .build()
                .into_diagnostic()?;
        let g_s_s_p_center_block_opt_group_1_built =
            GSSPCenterBlockOptGroup::WordRow(g_s_s_p_center_block_opt_group_1_built);
        self.push(
            ASTType::GSSPCenterBlockOptGroup(g_s_s_p_center_block_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// GSSPCenterBlockOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_center_block_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GSSPCenterBlockOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// Position: PositionLR GSSPSideWriteWidth;
    ///
    #[parol_runtime::function_name::named]
    fn position_0(
        &mut self,
        _position_l_r: &ParseTreeStackEntry<'t>,
        _g_s_s_p_side_write_width: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_s_s_p_side_write_width =
            pop_item!(self, g_s_s_p_side_write_width, GSSPSideWriteWidth, context);
        let position_l_r = pop_item!(self, position_l_r, PositionLR, context);
        let position_0_built = PositionPositionLRGSSPSideWriteWidthBuilder::default()
            .position_l_r(Box::new(position_l_r))
            .g_s_s_p_side_write_width(Box::new(g_s_s_p_side_write_width))
            .build()
            .into_diagnostic()?;
        let position_0_built = Position::PositionLRGSSPSideWriteWidth(position_0_built);
        // Calling user action here
        self.user_grammar.position(&position_0_built)?;
        self.push(ASTType::Position(position_0_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// Position: PositionTB;
    ///
    #[parol_runtime::function_name::named]
    fn position_1(
        &mut self,
        _position_t_b: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let position_t_b = pop_item!(self, position_t_b, PositionTB, context);
        let position_1_built = PositionPositionTBBuilder::default()
            .position_t_b(Box::new(position_t_b))
            .build()
            .into_diagnostic()?;
        let position_1_built = Position::PositionTB(position_1_built);
        // Calling user action here
        self.user_grammar.position(&position_1_built)?;
        self.push(ASTType::Position(position_1_built), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// GSSPSideWriteWidth: WordSide GSSPSideWriteWidthOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_side_write_width_0(
        &mut self,
        _word_side: &ParseTreeStackEntry<'t>,
        _g_s_s_p_side_write_width_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_s_s_p_side_write_width_opt = pop_item!(
            self,
            g_s_s_p_side_write_width_opt,
            GSSPSideWriteWidthOpt,
            context
        );
        let word_side = pop_item!(self, word_side, WordSide, context);
        let g_s_s_p_side_write_width_0_built =
            GSSPSideWriteWidthWordSideGSSPSideWriteWidthOptBuilder::default()
                .word_side(Box::new(word_side))
                .g_s_s_p_side_write_width_opt(g_s_s_p_side_write_width_opt)
                .build()
                .into_diagnostic()?;
        let g_s_s_p_side_write_width_0_built =
            GSSPSideWriteWidth::WordSideGSSPSideWriteWidthOpt(g_s_s_p_side_write_width_0_built);
        // Calling user action here
        self.user_grammar
            .g_s_s_p_side_write_width(&g_s_s_p_side_write_width_0_built)?;
        self.push(
            ASTType::GSSPSideWriteWidth(g_s_s_p_side_write_width_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// GSSPSideWriteWidth: WordVertical;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_side_write_width_1(
        &mut self,
        _word_vertical: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_vertical = pop_item!(self, word_vertical, WordVertical, context);
        let g_s_s_p_side_write_width_1_built = GSSPSideWriteWidthWordVerticalBuilder::default()
            .word_vertical(Box::new(word_vertical))
            .build()
            .into_diagnostic()?;
        let g_s_s_p_side_write_width_1_built =
            GSSPSideWriteWidth::WordVertical(g_s_s_p_side_write_width_1_built);
        // Calling user action here
        self.user_grammar
            .g_s_s_p_side_write_width(&g_s_s_p_side_write_width_1_built)?;
        self.push(
            ASTType::GSSPSideWriteWidth(g_s_s_p_side_write_width_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// GSSPSideWriteWidthOpt /* Option<T>::Some */: WordVertical;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_side_write_width_opt_0(
        &mut self,
        _word_vertical: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_vertical = pop_item!(self, word_vertical, WordVertical, context);
        let g_s_s_p_side_write_width_opt_0_built = GSSPSideWriteWidthOptBuilder::default()
            .word_vertical(Box::new(word_vertical))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::GSSPSideWriteWidthOpt(Some(Box::new(g_s_s_p_side_write_width_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// GSSPSideWriteWidthOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn g_s_s_p_side_write_width_opt_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GSSPSideWriteWidthOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// PositionLRTB: WordLeft;
    ///
    #[parol_runtime::function_name::named]
    fn position_l_r_t_b_0(
        &mut self,
        _word_left: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_left = pop_item!(self, word_left, WordLeft, context);
        let position_l_r_t_b_0_built = PositionLRTBWordLeftBuilder::default()
            .word_left(Box::new(word_left))
            .build()
            .into_diagnostic()?;
        let position_l_r_t_b_0_built = PositionLRTB::WordLeft(position_l_r_t_b_0_built);
        // Calling user action here
        self.user_grammar
            .position_l_r_t_b(&position_l_r_t_b_0_built)?;
        self.push(ASTType::PositionLRTB(position_l_r_t_b_0_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// PositionLRTB: WordRight;
    ///
    #[parol_runtime::function_name::named]
    fn position_l_r_t_b_1(
        &mut self,
        _word_right: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_right = pop_item!(self, word_right, WordRight, context);
        let position_l_r_t_b_1_built = PositionLRTBWordRightBuilder::default()
            .word_right(Box::new(word_right))
            .build()
            .into_diagnostic()?;
        let position_l_r_t_b_1_built = PositionLRTB::WordRight(position_l_r_t_b_1_built);
        // Calling user action here
        self.user_grammar
            .position_l_r_t_b(&position_l_r_t_b_1_built)?;
        self.push(ASTType::PositionLRTB(position_l_r_t_b_1_built), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// PositionLRTB: WordTop;
    ///
    #[parol_runtime::function_name::named]
    fn position_l_r_t_b_2(
        &mut self,
        _word_top: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_top = pop_item!(self, word_top, WordTop, context);
        let position_l_r_t_b_2_built = PositionLRTBWordTopBuilder::default()
            .word_top(Box::new(word_top))
            .build()
            .into_diagnostic()?;
        let position_l_r_t_b_2_built = PositionLRTB::WordTop(position_l_r_t_b_2_built);
        // Calling user action here
        self.user_grammar
            .position_l_r_t_b(&position_l_r_t_b_2_built)?;
        self.push(ASTType::PositionLRTB(position_l_r_t_b_2_built), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// PositionLRTB: WordBottom;
    ///
    #[parol_runtime::function_name::named]
    fn position_l_r_t_b_3(
        &mut self,
        _word_bottom: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_bottom = pop_item!(self, word_bottom, WordBottom, context);
        let position_l_r_t_b_3_built = PositionLRTBWordBottomBuilder::default()
            .word_bottom(Box::new(word_bottom))
            .build()
            .into_diagnostic()?;
        let position_l_r_t_b_3_built = PositionLRTB::WordBottom(position_l_r_t_b_3_built);
        // Calling user action here
        self.user_grammar
            .position_l_r_t_b(&position_l_r_t_b_3_built)?;
        self.push(ASTType::PositionLRTB(position_l_r_t_b_3_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// PositionLR: WordLeft;
    ///
    #[parol_runtime::function_name::named]
    fn position_l_r_0(
        &mut self,
        _word_left: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_left = pop_item!(self, word_left, WordLeft, context);
        let position_l_r_0_built = PositionLRWordLeftBuilder::default()
            .word_left(Box::new(word_left))
            .build()
            .into_diagnostic()?;
        let position_l_r_0_built = PositionLR::WordLeft(position_l_r_0_built);
        // Calling user action here
        self.user_grammar.position_l_r(&position_l_r_0_built)?;
        self.push(ASTType::PositionLR(position_l_r_0_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// PositionLR: WordRight;
    ///
    #[parol_runtime::function_name::named]
    fn position_l_r_1(
        &mut self,
        _word_right: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_right = pop_item!(self, word_right, WordRight, context);
        let position_l_r_1_built = PositionLRWordRightBuilder::default()
            .word_right(Box::new(word_right))
            .build()
            .into_diagnostic()?;
        let position_l_r_1_built = PositionLR::WordRight(position_l_r_1_built);
        // Calling user action here
        self.user_grammar.position_l_r(&position_l_r_1_built)?;
        self.push(ASTType::PositionLR(position_l_r_1_built), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// PositionLR: WordLeftAndRight;
    ///
    #[parol_runtime::function_name::named]
    fn position_l_r_2(
        &mut self,
        _word_left_and_right: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_left_and_right = pop_item!(self, word_left_and_right, WordLeftAndRight, context);
        let position_l_r_2_built = PositionLRWordLeftAndRightBuilder::default()
            .word_left_and_right(Box::new(word_left_and_right))
            .build()
            .into_diagnostic()?;
        let position_l_r_2_built = PositionLR::WordLeftAndRight(position_l_r_2_built);
        // Calling user action here
        self.user_grammar.position_l_r(&position_l_r_2_built)?;
        self.push(ASTType::PositionLR(position_l_r_2_built), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// PositionTB: PositionTBOpt /* Option */ PositionTOrB WordRow;
    ///
    #[parol_runtime::function_name::named]
    fn position_t_b(
        &mut self,
        _position_t_b_opt: &ParseTreeStackEntry<'t>,
        _position_t_or_b: &ParseTreeStackEntry<'t>,
        _word_row: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_row = pop_item!(self, word_row, WordRow, context);
        let position_t_or_b = pop_item!(self, position_t_or_b, PositionTOrB, context);
        let position_t_b_opt = pop_item!(self, position_t_b_opt, PositionTBOpt, context);
        let position_t_b_built = PositionTBBuilder::default()
            .position_t_b_opt(position_t_b_opt)
            .position_t_or_b(Box::new(position_t_or_b))
            .word_row(Box::new(word_row))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.position_t_b(&position_t_b_built)?;
        self.push(ASTType::PositionTB(position_t_b_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// PositionTBOpt /* Option<T>::Some */: WordMost;
    ///
    #[parol_runtime::function_name::named]
    fn position_t_b_opt_0(
        &mut self,
        _word_most: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_most = pop_item!(self, word_most, WordMost, context);
        let position_t_b_opt_0_built = PositionTBOptBuilder::default()
            .word_most(Box::new(word_most))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::PositionTBOpt(Some(Box::new(position_t_b_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// PositionTBOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn position_t_b_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PositionTBOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// PositionTOrB: WordTop;
    ///
    #[parol_runtime::function_name::named]
    fn position_t_or_b_0(
        &mut self,
        _word_top: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_top = pop_item!(self, word_top, WordTop, context);
        let position_t_or_b_0_built = PositionTOrBWordTopBuilder::default()
            .word_top(Box::new(word_top))
            .build()
            .into_diagnostic()?;
        let position_t_or_b_0_built = PositionTOrB::WordTop(position_t_or_b_0_built);
        // Calling user action here
        self.user_grammar
            .position_t_or_b(&position_t_or_b_0_built)?;
        self.push(ASTType::PositionTOrB(position_t_or_b_0_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// PositionTOrB: WordBottom;
    ///
    #[parol_runtime::function_name::named]
    fn position_t_or_b_1(
        &mut self,
        _word_bottom: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_bottom = pop_item!(self, word_bottom, WordBottom, context);
        let position_t_or_b_1_built = PositionTOrBWordBottomBuilder::default()
            .word_bottom(Box::new(word_bottom))
            .build()
            .into_diagnostic()?;
        let position_t_or_b_1_built = PositionTOrB::WordBottom(position_t_or_b_1_built);
        // Calling user action here
        self.user_grammar
            .position_t_or_b(&position_t_or_b_1_built)?;
        self.push(ASTType::PositionTOrB(position_t_or_b_1_built), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// GenShapeNumOfGen: PosInt WordCol;
    ///
    #[parol_runtime::function_name::named]
    fn gen_shape_num_of_gen(
        &mut self,
        _pos_int: &ParseTreeStackEntry<'t>,
        _word_col: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_col = pop_item!(self, word_col, WordCol, context);
        let pos_int = pop_item!(self, pos_int, PosInt, context);
        let gen_shape_num_of_gen_built = GenShapeNumOfGenBuilder::default()
            .pos_int(Box::new(pos_int))
            .word_col(Box::new(word_col))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .gen_shape_num_of_gen(&gen_shape_num_of_gen_built)?;
        self.push(
            ASTType::GenShapeNumOfGen(gen_shape_num_of_gen_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// ShapeType: ShapeOfL;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_0(
        &mut self,
        _shape_of_l: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_l = pop_item!(self, shape_of_l, ShapeOfL, context);
        let shape_type_0_built = ShapeTypeShapeOfLBuilder::default()
            .shape_of_l(Box::new(shape_of_l))
            .build()
            .into_diagnostic()?;
        let shape_type_0_built = ShapeType::ShapeOfL(shape_type_0_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_0_built)?;
        self.push(ASTType::ShapeType(shape_type_0_built), context);
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// ShapeType: ShapeTypeOpt /* Option */ ShapeOfZ;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_1(
        &mut self,
        _shape_type_opt: &ParseTreeStackEntry<'t>,
        _shape_of_z: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_z = pop_item!(self, shape_of_z, ShapeOfZ, context);
        let shape_type_opt = pop_item!(self, shape_type_opt, ShapeTypeOpt, context);
        let shape_type_1_built = ShapeTypeShapeTypeOptShapeOfZBuilder::default()
            .shape_type_opt(shape_type_opt)
            .shape_of_z(Box::new(shape_of_z))
            .build()
            .into_diagnostic()?;
        let shape_type_1_built = ShapeType::ShapeTypeOptShapeOfZ(shape_type_1_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_1_built)?;
        self.push(ASTType::ShapeType(shape_type_1_built), context);
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// ShapeType: ShapeOfCross;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_2(
        &mut self,
        _shape_of_cross: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_cross = pop_item!(self, shape_of_cross, ShapeOfCross, context);
        let shape_type_2_built = ShapeTypeShapeOfCrossBuilder::default()
            .shape_of_cross(Box::new(shape_of_cross))
            .build()
            .into_diagnostic()?;
        let shape_type_2_built = ShapeType::ShapeOfCross(shape_type_2_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_2_built)?;
        self.push(ASTType::ShapeType(shape_type_2_built), context);
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// ShapeType: Size No ShapeOfSquare;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_3(
        &mut self,
        _size: &ParseTreeStackEntry<'t>,
        _no: &ParseTreeStackEntry<'t>,
        _shape_of_square: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_square = pop_item!(self, shape_of_square, ShapeOfSquare, context);
        let no = pop_item!(self, no, No, context);
        let size = pop_item!(self, size, Size, context);
        let shape_type_3_built = ShapeTypeSizeNoShapeOfSquareBuilder::default()
            .size(Box::new(size))
            .no(Box::new(no))
            .shape_of_square(Box::new(shape_of_square))
            .build()
            .into_diagnostic()?;
        let shape_type_3_built = ShapeType::SizeNoShapeOfSquare(shape_type_3_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_3_built)?;
        self.push(ASTType::ShapeType(shape_type_3_built), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// ShapeType: ShapeOfBoardPerimeter;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_4(
        &mut self,
        _shape_of_board_perimeter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_board_perimeter = pop_item!(
            self,
            shape_of_board_perimeter,
            ShapeOfBoardPerimeter,
            context
        );
        let shape_type_4_built = ShapeTypeShapeOfBoardPerimeterBuilder::default()
            .shape_of_board_perimeter(Box::new(shape_of_board_perimeter))
            .build()
            .into_diagnostic()?;
        let shape_type_4_built = ShapeType::ShapeOfBoardPerimeter(shape_type_4_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_4_built)?;
        self.push(ASTType::ShapeType(shape_type_4_built), context);
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// ShapeType: ShapeOfBoardCenter;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_5(
        &mut self,
        _shape_of_board_center: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_board_center =
            pop_item!(self, shape_of_board_center, ShapeOfBoardCenter, context);
        let shape_type_5_built = ShapeTypeShapeOfBoardCenterBuilder::default()
            .shape_of_board_center(Box::new(shape_of_board_center))
            .build()
            .into_diagnostic()?;
        let shape_type_5_built = ShapeType::ShapeOfBoardCenter(shape_type_5_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_5_built)?;
        self.push(ASTType::ShapeType(shape_type_5_built), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// ShapeType: ShapeOfBoardTop;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_6(
        &mut self,
        _shape_of_board_top: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_board_top = pop_item!(self, shape_of_board_top, ShapeOfBoardTop, context);
        let shape_type_6_built = ShapeTypeShapeOfBoardTopBuilder::default()
            .shape_of_board_top(Box::new(shape_of_board_top))
            .build()
            .into_diagnostic()?;
        let shape_type_6_built = ShapeType::ShapeOfBoardTop(shape_type_6_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_6_built)?;
        self.push(ASTType::ShapeType(shape_type_6_built), context);
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// ShapeType: ShapeOfBoardBottom;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_7(
        &mut self,
        _shape_of_board_bottom: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_board_bottom =
            pop_item!(self, shape_of_board_bottom, ShapeOfBoardBottom, context);
        let shape_type_7_built = ShapeTypeShapeOfBoardBottomBuilder::default()
            .shape_of_board_bottom(Box::new(shape_of_board_bottom))
            .build()
            .into_diagnostic()?;
        let shape_type_7_built = ShapeType::ShapeOfBoardBottom(shape_type_7_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_7_built)?;
        self.push(ASTType::ShapeType(shape_type_7_built), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// ShapeType: ShapeOfBoardCorners;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_8(
        &mut self,
        _shape_of_board_corners: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_board_corners =
            pop_item!(self, shape_of_board_corners, ShapeOfBoardCorners, context);
        let shape_type_8_built = ShapeTypeShapeOfBoardCornersBuilder::default()
            .shape_of_board_corners(Box::new(shape_of_board_corners))
            .build()
            .into_diagnostic()?;
        let shape_type_8_built = ShapeType::ShapeOfBoardCorners(shape_type_8_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_8_built)?;
        self.push(ASTType::ShapeType(shape_type_8_built), context);
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// ShapeType: ShapeOfSpiderweb;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_9(
        &mut self,
        _shape_of_spiderweb: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_spiderweb = pop_item!(self, shape_of_spiderweb, ShapeOfSpiderweb, context);
        let shape_type_9_built = ShapeTypeShapeOfSpiderwebBuilder::default()
            .shape_of_spiderweb(Box::new(shape_of_spiderweb))
            .build()
            .into_diagnostic()?;
        let shape_type_9_built = ShapeType::ShapeOfSpiderweb(shape_type_9_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_9_built)?;
        self.push(ASTType::ShapeType(shape_type_9_built), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// ShapeType: ShapeOfCrescentMoon;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_10(
        &mut self,
        _shape_of_crescent_moon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_crescent_moon =
            pop_item!(self, shape_of_crescent_moon, ShapeOfCrescentMoon, context);
        let shape_type_10_built = ShapeTypeShapeOfCrescentMoonBuilder::default()
            .shape_of_crescent_moon(Box::new(shape_of_crescent_moon))
            .build()
            .into_diagnostic()?;
        let shape_type_10_built = ShapeType::ShapeOfCrescentMoon(shape_type_10_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_10_built)?;
        self.push(ASTType::ShapeType(shape_type_10_built), context);
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// ShapeType: ShapeTypeOpt0 /* Option */ ShapeOfOblique;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_11(
        &mut self,
        _shape_type_opt0: &ParseTreeStackEntry<'t>,
        _shape_of_oblique: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_oblique = pop_item!(self, shape_of_oblique, ShapeOfOblique, context);
        let shape_type_opt0 = pop_item!(self, shape_type_opt0, ShapeTypeOpt0, context);
        let shape_type_11_built = ShapeTypeShapeTypeOpt0ShapeOfObliqueBuilder::default()
            .shape_type_opt0(shape_type_opt0)
            .shape_of_oblique(Box::new(shape_of_oblique))
            .build()
            .into_diagnostic()?;
        let shape_type_11_built = ShapeType::ShapeTypeOpt0ShapeOfOblique(shape_type_11_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_11_built)?;
        self.push(ASTType::ShapeType(shape_type_11_built), context);
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// ShapeType: PosInt ShapeOfSomeKind;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_12(
        &mut self,
        _pos_int: &ParseTreeStackEntry<'t>,
        _shape_of_some_kind: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_some_kind = pop_item!(self, shape_of_some_kind, ShapeOfSomeKind, context);
        let pos_int = pop_item!(self, pos_int, PosInt, context);
        let shape_type_12_built = ShapeTypePosIntShapeOfSomeKindBuilder::default()
            .pos_int(Box::new(pos_int))
            .shape_of_some_kind(Box::new(shape_of_some_kind))
            .build()
            .into_diagnostic()?;
        let shape_type_12_built = ShapeType::PosIntShapeOfSomeKind(shape_type_12_built);
        // Calling user action here
        self.user_grammar.shape_type(&shape_type_12_built)?;
        self.push(ASTType::ShapeType(shape_type_12_built), context);
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// ShapeTypeOpt0 /* Option<T>::Some */: OnBoard;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_opt0_0(
        &mut self,
        _on_board: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let on_board = pop_item!(self, on_board, OnBoard, context);
        let shape_type_opt0_0_built = ShapeTypeOpt0Builder::default()
            .on_board(Box::new(on_board))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ShapeTypeOpt0(Some(Box::new(shape_type_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// ShapeTypeOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ShapeTypeOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// ShapeTypeOpt /* Option<T>::Some */: OnBoard;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_opt_0(
        &mut self,
        _on_board: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let on_board = pop_item!(self, on_board, OnBoard, context);
        let shape_type_opt_0_built = ShapeTypeOptBuilder::default()
            .on_board(Box::new(on_board))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ShapeTypeOpt(Some(Box::new(shape_type_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// ShapeTypeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn shape_type_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ShapeTypeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// DropUnlockBlock: DropUnlockBlockOpt /* Option */ WordLock Wo WordRelease Si Camma;
    ///
    #[parol_runtime::function_name::named]
    fn drop_unlock_block(
        &mut self,
        _drop_unlock_block_opt: &ParseTreeStackEntry<'t>,
        _word_lock: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _word_release: &ParseTreeStackEntry<'t>,
        _si: &ParseTreeStackEntry<'t>,
        _camma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let camma = pop_item!(self, camma, Camma, context);
        let si = pop_item!(self, si, Si, context);
        let word_release = pop_item!(self, word_release, WordRelease, context);
        let wo = pop_item!(self, wo, Wo, context);
        let word_lock = pop_item!(self, word_lock, WordLock, context);
        let drop_unlock_block_opt =
            pop_item!(self, drop_unlock_block_opt, DropUnlockBlockOpt, context);
        let drop_unlock_block_built = DropUnlockBlockBuilder::default()
            .drop_unlock_block_opt(drop_unlock_block_opt)
            .word_lock(Box::new(word_lock))
            .wo(Box::new(wo))
            .word_release(Box::new(word_release))
            .si(Box::new(si))
            .camma(Box::new(camma))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .drop_unlock_block(&drop_unlock_block_built)?;
        self.push(ASTType::DropUnlockBlock(drop_unlock_block_built), context);
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// DropUnlockBlockOpt /* Option<T>::Some */: DropUnlockBlockOpt0 /* Option */ No;
    ///
    #[parol_runtime::function_name::named]
    fn drop_unlock_block_opt_0(
        &mut self,
        _drop_unlock_block_opt0: &ParseTreeStackEntry<'t>,
        _no: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let no = pop_item!(self, no, No, context);
        let drop_unlock_block_opt0 =
            pop_item!(self, drop_unlock_block_opt0, DropUnlockBlockOpt0, context);
        let drop_unlock_block_opt_0_built = DropUnlockBlockOptBuilder::default()
            .drop_unlock_block_opt0(drop_unlock_block_opt0)
            .no(Box::new(no))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::DropUnlockBlockOpt(Some(Box::new(drop_unlock_block_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// DropUnlockBlockOpt0 /* Option<T>::Some */: WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn drop_unlock_block_opt0_0(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let drop_unlock_block_opt0_0_built = DropUnlockBlockOpt0Builder::default()
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::DropUnlockBlockOpt0(Some(Box::new(drop_unlock_block_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// DropUnlockBlockOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drop_unlock_block_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropUnlockBlockOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// DropUnlockBlockOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drop_unlock_block_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropUnlockBlockOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// Drops: Drop DropsSuffix;
    ///
    #[parol_runtime::function_name::named]
    fn drops_0(
        &mut self,
        _drop: &ParseTreeStackEntry<'t>,
        _drops_suffix: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_suffix = pop_item!(self, drops_suffix, DropsSuffix, context);
        let drop = pop_item!(self, drop, Drop, context);
        let drops_0_built = DropsDropDropsSuffixBuilder::default()
            .drop(Box::new(drop))
            .drops_suffix(Box::new(drops_suffix))
            .build()
            .into_diagnostic()?;
        let drops_0_built = Drops::DropDropsSuffix(drops_0_built);
        // Calling user action here
        self.user_grammar.drops(&drops_0_built)?;
        self.push(ASTType::Drops(drops_0_built), context);
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// DropsSuffix: DropsList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn drops_suffix_0(
        &mut self,
        _drops_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list = pop_and_reverse_item!(self, drops_list, DropsList, context);
        let drops_suffix_0_built = DropsSuffixDropsListBuilder::default()
            .drops_list(drops_list)
            .build()
            .into_diagnostic()?;
        let drops_suffix_0_built = DropsSuffix::DropsList(drops_suffix_0_built);
        self.push(ASTType::DropsSuffix(drops_suffix_0_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// Drops: FiveAttribute DropsList0 /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn drops_1(
        &mut self,
        _five_attribute: &ParseTreeStackEntry<'t>,
        _drops_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list0 = pop_and_reverse_item!(self, drops_list0, DropsList0, context);
        let five_attribute = pop_item!(self, five_attribute, FiveAttribute, context);
        let drops_1_built = DropsFiveAttributeDropsList0Builder::default()
            .five_attribute(Box::new(five_attribute))
            .drops_list0(drops_list0)
            .build()
            .into_diagnostic()?;
        let drops_1_built = Drops::FiveAttributeDropsList0(drops_1_built);
        // Calling user action here
        self.user_grammar.drops(&drops_1_built)?;
        self.push(ASTType::Drops(drops_1_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// DropsSuffix: And Drop;
    ///
    #[parol_runtime::function_name::named]
    fn drops_suffix_1(
        &mut self,
        _and: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop = pop_item!(self, drop, Drop, context);
        let and = pop_item!(self, and, And, context);
        let drops_suffix_1_built = DropsSuffixAndDropBuilder::default()
            .and(Box::new(and))
            .drop(Box::new(drop))
            .build()
            .into_diagnostic()?;
        let drops_suffix_1_built = DropsSuffix::AndDrop(drops_suffix_1_built);
        self.push(ASTType::DropsSuffix(drops_suffix_1_built), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// DropsList /* Vec<T>::Push */: ManyDrop DropsList;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list_0(
        &mut self,
        _many_drop: &ParseTreeStackEntry<'t>,
        _drops_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut drops_list = pop_item!(self, drops_list, DropsList, context);
        let many_drop = pop_item!(self, many_drop, ManyDrop, context);
        let drops_list_0_built = DropsListBuilder::default()
            .many_drop(Box::new(many_drop))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        drops_list.push(drops_list_0_built);
        self.push(ASTType::DropsList(drops_list), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// DropsList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list_1_built = Vec::new();
        self.push(ASTType::DropsList(drops_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// DropsList0 /* Vec<T>::Push */: Plus Drop DropsList0;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list0_0(
        &mut self,
        _plus: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _drops_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut drops_list0 = pop_item!(self, drops_list0, DropsList0, context);
        let drop = pop_item!(self, drop, Drop, context);
        let plus = pop_item!(self, plus, Plus, context);
        let drops_list0_0_built = DropsList0Builder::default()
            .drop(Box::new(drop))
            .plus(Box::new(plus))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        drops_list0.push(drops_list0_0_built);
        self.push(ASTType::DropsList0(drops_list0), context);
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// DropsList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list0_1_built = Vec::new();
        self.push(ASTType::DropsList0(drops_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// ManyDrop: Camma Drop;
    ///
    #[parol_runtime::function_name::named]
    fn many_drop_0(
        &mut self,
        _camma: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop = pop_item!(self, drop, Drop, context);
        let camma = pop_item!(self, camma, Camma, context);
        let many_drop_0_built = ManyDropCammaDropBuilder::default()
            .camma(Box::new(camma))
            .drop(Box::new(drop))
            .build()
            .into_diagnostic()?;
        let many_drop_0_built = ManyDrop::CammaDrop(many_drop_0_built);
        // Calling user action here
        self.user_grammar.many_drop(&many_drop_0_built)?;
        self.push(ASTType::ManyDrop(many_drop_0_built), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// ManyDrop: Plus Drop;
    ///
    #[parol_runtime::function_name::named]
    fn many_drop_1(
        &mut self,
        _plus: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop = pop_item!(self, drop, Drop, context);
        let plus = pop_item!(self, plus, Plus, context);
        let many_drop_1_built = ManyDropPlusDropBuilder::default()
            .plus(Box::new(plus))
            .drop(Box::new(drop))
            .build()
            .into_diagnostic()?;
        let many_drop_1_built = ManyDrop::PlusDrop(many_drop_1_built);
        // Calling user action here
        self.user_grammar.many_drop(&many_drop_1_built)?;
        self.push(ASTType::ManyDrop(many_drop_1_built), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// AllDrops: WordAll WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn all_drops(
        &mut self,
        _word_all: &ParseTreeStackEntry<'t>,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let word_all = pop_item!(self, word_all, WordAll, context);
        let all_drops_built = AllDropsBuilder::default()
            .word_all(Box::new(word_all))
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.all_drops(&all_drops_built)?;
        self.push(ASTType::AllDrops(all_drops_built), context);
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// FiveAttribute: WordFiveAttribute FiveAttributeOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn five_attribute(
        &mut self,
        _word_five_attribute: &ParseTreeStackEntry<'t>,
        _five_attribute_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let five_attribute_opt = pop_item!(self, five_attribute_opt, FiveAttributeOpt, context);
        let word_five_attribute = pop_item!(self, word_five_attribute, WordFiveAttribute, context);
        let five_attribute_built = FiveAttributeBuilder::default()
            .word_five_attribute(Box::new(word_five_attribute))
            .five_attribute_opt(five_attribute_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.five_attribute(&five_attribute_built)?;
        self.push(ASTType::FiveAttribute(five_attribute_built), context);
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// FiveAttributeOpt /* Option<T>::Some */: WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn five_attribute_opt_0(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let five_attribute_opt_0_built = FiveAttributeOptBuilder::default()
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FiveAttributeOpt(Some(Box::new(five_attribute_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// FiveAttributeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn five_attribute_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FiveAttributeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// Quantity: PosInt WordCount QuantityOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn quantity(
        &mut self,
        _pos_int: &ParseTreeStackEntry<'t>,
        _word_count: &ParseTreeStackEntry<'t>,
        _quantity_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quantity_opt = pop_item!(self, quantity_opt, QuantityOpt, context);
        let word_count = pop_item!(self, word_count, WordCount, context);
        let pos_int = pop_item!(self, pos_int, PosInt, context);
        let quantity_built = QuantityBuilder::default()
            .pos_int(Box::new(pos_int))
            .word_count(Box::new(word_count))
            .quantity_opt(quantity_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.quantity(&quantity_built)?;
        self.push(ASTType::Quantity(quantity_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// QuantityOpt /* Option<T>::Some */: Each;
    ///
    #[parol_runtime::function_name::named]
    fn quantity_opt_0(
        &mut self,
        _each: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let each = pop_item!(self, each, Each, context);
        let quantity_opt_0_built = QuantityOptBuilder::default()
            .each(Box::new(each))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::QuantityOpt(Some(Box::new(quantity_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// QuantityOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn quantity_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::QuantityOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// Drop: Color DropOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn drop_0(
        &mut self,
        _color: &ParseTreeStackEntry<'t>,
        _drop_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_opt = pop_item!(self, drop_opt, DropOpt, context);
        let color = pop_item!(self, color, Color, context);
        let drop_0_built = DropColorDropOptBuilder::default()
            .color(Box::new(color))
            .drop_opt(drop_opt)
            .build()
            .into_diagnostic()?;
        let drop_0_built = Drop::ColorDropOpt(drop_0_built);
        // Calling user action here
        self.user_grammar.drop(&drop_0_built)?;
        self.push(ASTType::Drop(drop_0_built), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// Drop: NonColoredDrop DropOpt0 /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn drop_1(
        &mut self,
        _non_colored_drop: &ParseTreeStackEntry<'t>,
        _drop_opt0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_opt0 = pop_item!(self, drop_opt0, DropOpt0, context);
        let non_colored_drop = pop_item!(self, non_colored_drop, NonColoredDrop, context);
        let drop_1_built = DropNonColoredDropDropOpt0Builder::default()
            .non_colored_drop(Box::new(non_colored_drop))
            .drop_opt0(drop_opt0)
            .build()
            .into_diagnostic()?;
        let drop_1_built = Drop::NonColoredDropDropOpt0(drop_1_built);
        // Calling user action here
        self.user_grammar.drop(&drop_1_built)?;
        self.push(ASTType::Drop(drop_1_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// DropOpt0 /* Option<T>::Some */: WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt0_0(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let drop_opt0_0_built = DropOpt0Builder::default()
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::DropOpt0(Some(Box::new(drop_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// DropOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// DropOpt /* Option<T>::Some */: WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt_0(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let drop_opt_0_built = DropOptBuilder::default()
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        self.push(ASTType::DropOpt(Some(Box::new(drop_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// DropOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// NonColoredDrop: Recovery;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_0(
        &mut self,
        _recovery: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let recovery = pop_item!(self, recovery, Recovery, context);
        let non_colored_drop_0_built = NonColoredDropRecoveryBuilder::default()
            .recovery(Box::new(recovery))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_0_built = NonColoredDrop::Recovery(non_colored_drop_0_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_0_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_0_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// NonColoredDrop: Disturb;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_1(
        &mut self,
        _disturb: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disturb = pop_item!(self, disturb, Disturb, context);
        let non_colored_drop_1_built = NonColoredDropDisturbBuilder::default()
            .disturb(Box::new(disturb))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_1_built = NonColoredDrop::Disturb(non_colored_drop_1_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_1_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_1_built), context);
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// NonColoredDrop: Bomb;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_2(
        &mut self,
        _bomb: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bomb = pop_item!(self, bomb, Bomb, context);
        let non_colored_drop_2_built = NonColoredDropBombBuilder::default()
            .bomb(Box::new(bomb))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_2_built = NonColoredDrop::Bomb(non_colored_drop_2_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_2_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_2_built), context);
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// NonColoredDrop: Poison;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_3(
        &mut self,
        _poison: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let poison = pop_item!(self, poison, Poison, context);
        let non_colored_drop_3_built = NonColoredDropPoisonBuilder::default()
            .poison(Box::new(poison))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_3_built = NonColoredDrop::Poison(non_colored_drop_3_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_3_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_3_built), context);
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// NonColoredDrop: DeadlyPoison;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_4(
        &mut self,
        _deadly_poison: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let deadly_poison = pop_item!(self, deadly_poison, DeadlyPoison, context);
        let non_colored_drop_4_built = NonColoredDropDeadlyPoisonBuilder::default()
            .deadly_poison(Box::new(deadly_poison))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_4_built = NonColoredDrop::DeadlyPoison(non_colored_drop_4_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_4_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_4_built), context);
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// Color: Fire;
    ///
    #[parol_runtime::function_name::named]
    fn color_0(
        &mut self,
        _fire: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fire = pop_item!(self, fire, Fire, context);
        let color_0_built = ColorFireBuilder::default()
            .fire(Box::new(fire))
            .build()
            .into_diagnostic()?;
        let color_0_built = Color::Fire(color_0_built);
        // Calling user action here
        self.user_grammar.color(&color_0_built)?;
        self.push(ASTType::Color(color_0_built), context);
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// Color: Water;
    ///
    #[parol_runtime::function_name::named]
    fn color_1(
        &mut self,
        _water: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let water = pop_item!(self, water, Water, context);
        let color_1_built = ColorWaterBuilder::default()
            .water(Box::new(water))
            .build()
            .into_diagnostic()?;
        let color_1_built = Color::Water(color_1_built);
        // Calling user action here
        self.user_grammar.color(&color_1_built)?;
        self.push(ASTType::Color(color_1_built), context);
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// Color: Wood;
    ///
    #[parol_runtime::function_name::named]
    fn color_2(
        &mut self,
        _wood: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let wood = pop_item!(self, wood, Wood, context);
        let color_2_built = ColorWoodBuilder::default()
            .wood(Box::new(wood))
            .build()
            .into_diagnostic()?;
        let color_2_built = Color::Wood(color_2_built);
        // Calling user action here
        self.user_grammar.color(&color_2_built)?;
        self.push(ASTType::Color(color_2_built), context);
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// Color: Lightning;
    ///
    #[parol_runtime::function_name::named]
    fn color_3(
        &mut self,
        _lightning: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lightning = pop_item!(self, lightning, Lightning, context);
        let color_3_built = ColorLightningBuilder::default()
            .lightning(Box::new(lightning))
            .build()
            .into_diagnostic()?;
        let color_3_built = Color::Lightning(color_3_built);
        // Calling user action here
        self.user_grammar.color(&color_3_built)?;
        self.push(ASTType::Color(color_3_built), context);
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// Color: Dark;
    ///
    #[parol_runtime::function_name::named]
    fn color_4(
        &mut self,
        _dark: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dark = pop_item!(self, dark, Dark, context);
        let color_4_built = ColorDarkBuilder::default()
            .dark(Box::new(dark))
            .build()
            .into_diagnostic()?;
        let color_4_built = Color::Dark(color_4_built);
        // Calling user action here
        self.user_grammar.color(&color_4_built)?;
        self.push(ASTType::Color(color_4_built), context);
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// RandomSuffix: WordRandom So;
    ///
    #[parol_runtime::function_name::named]
    fn random_suffix(
        &mut self,
        _word_random: &ParseTreeStackEntry<'t>,
        _so: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let so = pop_item!(self, so, So, context);
        let word_random = pop_item!(self, word_random, WordRandom, context);
        let random_suffix_built = RandomSuffixBuilder::default()
            .word_random(Box::new(word_random))
            .so(Box::new(so))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.random_suffix(&random_suffix_built)?;
        self.push(ASTType::RandomSuffix(random_suffix_built), context);
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// Size: PosInt Multi PosInt;
    ///
    #[parol_runtime::function_name::named]
    fn size(
        &mut self,
        _pos_int: &ParseTreeStackEntry<'t>,
        _multi: &ParseTreeStackEntry<'t>,
        _pos_int0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pos_int0 = pop_item!(self, pos_int0, PosInt, context);
        let multi = pop_item!(self, multi, Multi, context);
        let pos_int = pop_item!(self, pos_int, PosInt, context);
        let size_built = SizeBuilder::default()
            .pos_int(Box::new(pos_int))
            .multi(Box::new(multi))
            .pos_int0(Box::new(pos_int0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.size(&size_built)?;
        self.push(ASTType::Size(size_built), context);
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// OnBoard: WordBoard WordTop Ni;
    ///
    #[parol_runtime::function_name::named]
    fn on_board(
        &mut self,
        _word_board: &ParseTreeStackEntry<'t>,
        _word_top: &ParseTreeStackEntry<'t>,
        _ni: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ni = pop_item!(self, ni, Ni, context);
        let word_top = pop_item!(self, word_top, WordTop, context);
        let word_board = pop_item!(self, word_board, WordBoard, context);
        let on_board_built = OnBoardBuilder::default()
            .word_board(Box::new(word_board))
            .word_top(Box::new(word_top))
            .ni(Box::new(ni))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.on_board(&on_board_built)?;
        self.push(ASTType::OnBoard(on_board_built), context);
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// Turns: PosInt WordTurn No WordBetween Camma;
    ///
    #[parol_runtime::function_name::named]
    fn turns(
        &mut self,
        _pos_int: &ParseTreeStackEntry<'t>,
        _word_turn: &ParseTreeStackEntry<'t>,
        _no: &ParseTreeStackEntry<'t>,
        _word_between: &ParseTreeStackEntry<'t>,
        _camma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let camma = pop_item!(self, camma, Camma, context);
        let word_between = pop_item!(self, word_between, WordBetween, context);
        let no = pop_item!(self, no, No, context);
        let word_turn = pop_item!(self, word_turn, WordTurn, context);
        let pos_int = pop_item!(self, pos_int, PosInt, context);
        let turns_built = TurnsBuilder::default()
            .pos_int(Box::new(pos_int))
            .word_turn(Box::new(word_turn))
            .no(Box::new(no))
            .word_between(Box::new(word_between))
            .camma(Box::new(camma))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.turns(&turns_built)?;
        self.push(ASTType::Turns(turns_built), context);
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// TurnsOfApplyBlock: DropsEasierToFalloff;
    ///
    #[parol_runtime::function_name::named]
    fn turns_of_apply_block(
        &mut self,
        _drops_easier_to_falloff: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_easier_to_falloff =
            pop_item!(self, drops_easier_to_falloff, DropsEasierToFalloff, context);
        let turns_of_apply_block_built = TurnsOfApplyBlockBuilder::default()
            .drops_easier_to_falloff(Box::new(drops_easier_to_falloff))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .turns_of_apply_block(&turns_of_apply_block_built)?;
        self.push(
            ASTType::TurnsOfApplyBlock(turns_of_apply_block_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// DropsEasierToFalloff: Drops DropsEasierToFalloffOpt /* Option */ DropsEasierToFalloffOpt0 /* Option */ DropsEasierToFalloffOpt1 /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn drops_easier_to_falloff(
        &mut self,
        _drops: &ParseTreeStackEntry<'t>,
        _drops_easier_to_falloff_opt: &ParseTreeStackEntry<'t>,
        _drops_easier_to_falloff_opt0: &ParseTreeStackEntry<'t>,
        _drops_easier_to_falloff_opt1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_easier_to_falloff_opt1 = pop_item!(
            self,
            drops_easier_to_falloff_opt1,
            DropsEasierToFalloffOpt1,
            context
        );
        let drops_easier_to_falloff_opt0 = pop_item!(
            self,
            drops_easier_to_falloff_opt0,
            DropsEasierToFalloffOpt0,
            context
        );
        let drops_easier_to_falloff_opt = pop_item!(
            self,
            drops_easier_to_falloff_opt,
            DropsEasierToFalloffOpt,
            context
        );
        let drops = pop_item!(self, drops, Drops, context);
        let drops_easier_to_falloff_built = DropsEasierToFalloffBuilder::default()
            .drops(Box::new(drops))
            .drops_easier_to_falloff_opt(drops_easier_to_falloff_opt)
            .drops_easier_to_falloff_opt0(drops_easier_to_falloff_opt0)
            .drops_easier_to_falloff_opt1(drops_easier_to_falloff_opt1)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .drops_easier_to_falloff(&drops_easier_to_falloff_built)?;
        self.push(
            ASTType::DropsEasierToFalloff(drops_easier_to_falloff_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// DropsEasierToFalloffOpt1 /* Option<T>::Some */: DropsEasierToFalloffOpt1Group;
    ///
    #[parol_runtime::function_name::named]
    fn drops_easier_to_falloff_opt1_0(
        &mut self,
        _drops_easier_to_falloff_opt1_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_easier_to_falloff_opt1_group = pop_item!(
            self,
            drops_easier_to_falloff_opt1_group,
            DropsEasierToFalloffOpt1Group,
            context
        );
        let drops_easier_to_falloff_opt1_0_built = DropsEasierToFalloffOpt1Builder::default()
            .drops_easier_to_falloff_opt1_group(Box::new(drops_easier_to_falloff_opt1_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::DropsEasierToFalloffOpt1(Some(Box::new(drops_easier_to_falloff_opt1_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// DropsEasierToFalloffOpt1Group: WordFalloff;
    ///
    #[parol_runtime::function_name::named]
    fn drops_easier_to_falloff_opt1_group_0(
        &mut self,
        _word_falloff: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_falloff = pop_item!(self, word_falloff, WordFalloff, context);
        let drops_easier_to_falloff_opt1_group_0_built =
            DropsEasierToFalloffOpt1GroupWordFalloffBuilder::default()
                .word_falloff(Box::new(word_falloff))
                .build()
                .into_diagnostic()?;
        let drops_easier_to_falloff_opt1_group_0_built =
            DropsEasierToFalloffOpt1Group::WordFalloff(drops_easier_to_falloff_opt1_group_0_built);
        self.push(
            ASTType::DropsEasierToFalloffOpt1Group(drops_easier_to_falloff_opt1_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// DropsEasierToFalloffOpt1Group: WordFall;
    ///
    #[parol_runtime::function_name::named]
    fn drops_easier_to_falloff_opt1_group_1(
        &mut self,
        _word_fall: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_fall = pop_item!(self, word_fall, WordFall, context);
        let drops_easier_to_falloff_opt1_group_1_built =
            DropsEasierToFalloffOpt1GroupWordFallBuilder::default()
                .word_fall(Box::new(word_fall))
                .build()
                .into_diagnostic()?;
        let drops_easier_to_falloff_opt1_group_1_built =
            DropsEasierToFalloffOpt1Group::WordFall(drops_easier_to_falloff_opt1_group_1_built);
        self.push(
            ASTType::DropsEasierToFalloffOpt1Group(drops_easier_to_falloff_opt1_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// DropsEasierToFalloffOpt1 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drops_easier_to_falloff_opt1_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropsEasierToFalloffOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// DropsEasierToFalloffOpt0 /* Option<T>::Some */: SkillVolumeVariation;
    ///
    #[parol_runtime::function_name::named]
    fn drops_easier_to_falloff_opt0_0(
        &mut self,
        _skill_volume_variation: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let skill_volume_variation =
            pop_item!(self, skill_volume_variation, SkillVolumeVariation, context);
        let drops_easier_to_falloff_opt0_0_built = DropsEasierToFalloffOpt0Builder::default()
            .skill_volume_variation(Box::new(skill_volume_variation))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::DropsEasierToFalloffOpt0(Some(Box::new(drops_easier_to_falloff_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// DropsEasierToFalloffOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drops_easier_to_falloff_opt0_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropsEasierToFalloffOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// DropsEasierToFalloffOpt /* Option<T>::Some */: Ga;
    ///
    #[parol_runtime::function_name::named]
    fn drops_easier_to_falloff_opt_0(
        &mut self,
        _ga: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ga = pop_item!(self, ga, Ga, context);
        let drops_easier_to_falloff_opt_0_built = DropsEasierToFalloffOptBuilder::default()
            .ga(Box::new(ga))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::DropsEasierToFalloffOpt(Some(Box::new(drops_easier_to_falloff_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 176:
    ///
    /// DropsEasierToFalloffOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drops_easier_to_falloff_opt_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropsEasierToFalloffOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 177:
    ///
    /// SkillVolumeVariation: WordLittleMore;
    ///
    #[parol_runtime::function_name::named]
    fn skill_volume_variation_0(
        &mut self,
        _word_little_more: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_little_more = pop_item!(self, word_little_more, WordLittleMore, context);
        let skill_volume_variation_0_built = SkillVolumeVariationWordLittleMoreBuilder::default()
            .word_little_more(Box::new(word_little_more))
            .build()
            .into_diagnostic()?;
        let skill_volume_variation_0_built =
            SkillVolumeVariation::WordLittleMore(skill_volume_variation_0_built);
        // Calling user action here
        self.user_grammar
            .skill_volume_variation(&skill_volume_variation_0_built)?;
        self.push(
            ASTType::SkillVolumeVariation(skill_volume_variation_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 178:
    ///
    /// SkillVolumeVariation: WordLittle;
    ///
    #[parol_runtime::function_name::named]
    fn skill_volume_variation_1(
        &mut self,
        _word_little: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_little = pop_item!(self, word_little, WordLittle, context);
        let skill_volume_variation_1_built = SkillVolumeVariationWordLittleBuilder::default()
            .word_little(Box::new(word_little))
            .build()
            .into_diagnostic()?;
        let skill_volume_variation_1_built =
            SkillVolumeVariation::WordLittle(skill_volume_variation_1_built);
        // Calling user action here
        self.user_grammar
            .skill_volume_variation(&skill_volume_variation_1_built)?;
        self.push(
            ASTType::SkillVolumeVariation(skill_volume_variation_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 179:
    ///
    /// SkillVolumeVariation: WordOnly;
    ///
    #[parol_runtime::function_name::named]
    fn skill_volume_variation_2(
        &mut self,
        _word_only: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_only = pop_item!(self, word_only, WordOnly, context);
        let skill_volume_variation_2_built = SkillVolumeVariationWordOnlyBuilder::default()
            .word_only(Box::new(word_only))
            .build()
            .into_diagnostic()?;
        let skill_volume_variation_2_built =
            SkillVolumeVariation::WordOnly(skill_volume_variation_2_built);
        // Calling user action here
        self.user_grammar
            .skill_volume_variation(&skill_volume_variation_2_built)?;
        self.push(
            ASTType::SkillVolumeVariation(skill_volume_variation_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 180:
    ///
    /// Fire: '火';
    ///
    #[parol_runtime::function_name::named]
    fn fire(
        &mut self,
        fire: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fire = fire.token(parse_tree)?.clone();
        let fire_built = FireBuilder::default()
            .fire(fire)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.fire(&fire_built)?;
        self.push(ASTType::Fire(fire_built), context);
        Ok(())
    }

    /// Semantic action for production 181:
    ///
    /// Water: '水';
    ///
    #[parol_runtime::function_name::named]
    fn water(
        &mut self,
        water: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let water = water.token(parse_tree)?.clone();
        let water_built = WaterBuilder::default()
            .water(water)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.water(&water_built)?;
        self.push(ASTType::Water(water_built), context);
        Ok(())
    }

    /// Semantic action for production 182:
    ///
    /// Wood: '木';
    ///
    #[parol_runtime::function_name::named]
    fn wood(
        &mut self,
        wood: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let wood = wood.token(parse_tree)?.clone();
        let wood_built = WoodBuilder::default()
            .wood(wood)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.wood(&wood_built)?;
        self.push(ASTType::Wood(wood_built), context);
        Ok(())
    }

    /// Semantic action for production 183:
    ///
    /// Lightning: '光';
    ///
    #[parol_runtime::function_name::named]
    fn lightning(
        &mut self,
        lightning: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lightning = lightning.token(parse_tree)?.clone();
        let lightning_built = LightningBuilder::default()
            .lightning(lightning)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.lightning(&lightning_built)?;
        self.push(ASTType::Lightning(lightning_built), context);
        Ok(())
    }

    /// Semantic action for production 184:
    ///
    /// Dark: '闇';
    ///
    #[parol_runtime::function_name::named]
    fn dark(
        &mut self,
        dark: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dark = dark.token(parse_tree)?.clone();
        let dark_built = DarkBuilder::default()
            .dark(dark)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dark(&dark_built)?;
        self.push(ASTType::Dark(dark_built), context);
        Ok(())
    }

    /// Semantic action for production 185:
    ///
    /// Recovery: '回復';
    ///
    #[parol_runtime::function_name::named]
    fn recovery(
        &mut self,
        recovery: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let recovery = recovery.token(parse_tree)?.clone();
        let recovery_built = RecoveryBuilder::default()
            .recovery(recovery)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.recovery(&recovery_built)?;
        self.push(ASTType::Recovery(recovery_built), context);
        Ok(())
    }

    /// Semantic action for production 186:
    ///
    /// Disturb: 'お邪魔';
    ///
    #[parol_runtime::function_name::named]
    fn disturb(
        &mut self,
        disturb: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disturb = disturb.token(parse_tree)?.clone();
        let disturb_built = DisturbBuilder::default()
            .disturb(disturb)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.disturb(&disturb_built)?;
        self.push(ASTType::Disturb(disturb_built), context);
        Ok(())
    }

    /// Semantic action for production 187:
    ///
    /// Bomb: '爆弾';
    ///
    #[parol_runtime::function_name::named]
    fn bomb(
        &mut self,
        bomb: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bomb = bomb.token(parse_tree)?.clone();
        let bomb_built = BombBuilder::default()
            .bomb(bomb)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bomb(&bomb_built)?;
        self.push(ASTType::Bomb(bomb_built), context);
        Ok(())
    }

    /// Semantic action for production 188:
    ///
    /// DeadlyPoison: '猛毒';
    ///
    #[parol_runtime::function_name::named]
    fn deadly_poison(
        &mut self,
        deadly_poison: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let deadly_poison = deadly_poison.token(parse_tree)?.clone();
        let deadly_poison_built = DeadlyPoisonBuilder::default()
            .deadly_poison(deadly_poison)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.deadly_poison(&deadly_poison_built)?;
        self.push(ASTType::DeadlyPoison(deadly_poison_built), context);
        Ok(())
    }

    /// Semantic action for production 189:
    ///
    /// Poison: '毒';
    ///
    #[parol_runtime::function_name::named]
    fn poison(
        &mut self,
        poison: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let poison = poison.token(parse_tree)?.clone();
        let poison_built = PoisonBuilder::default()
            .poison(poison)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.poison(&poison_built)?;
        self.push(ASTType::Poison(poison_built), context);
        Ok(())
    }

    /// Semantic action for production 190:
    ///
    /// ShapeOfL: 'L字型';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_l(
        &mut self,
        shape_of_l: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_l = shape_of_l.token(parse_tree)?.clone();
        let shape_of_l_built = ShapeOfLBuilder::default()
            .shape_of_l(shape_of_l)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.shape_of_l(&shape_of_l_built)?;
        self.push(ASTType::ShapeOfL(shape_of_l_built), context);
        Ok(())
    }

    /// Semantic action for production 191:
    ///
    /// ShapeOfZ: 'Z字型';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_z(
        &mut self,
        shape_of_z: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_z = shape_of_z.token(parse_tree)?.clone();
        let shape_of_z_built = ShapeOfZBuilder::default()
            .shape_of_z(shape_of_z)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.shape_of_z(&shape_of_z_built)?;
        self.push(ASTType::ShapeOfZ(shape_of_z_built), context);
        Ok(())
    }

    /// Semantic action for production 192:
    ///
    /// ShapeOfCross: '十字型';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_cross(
        &mut self,
        shape_of_cross: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_cross = shape_of_cross.token(parse_tree)?.clone();
        let shape_of_cross_built = ShapeOfCrossBuilder::default()
            .shape_of_cross(shape_of_cross)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.shape_of_cross(&shape_of_cross_built)?;
        self.push(ASTType::ShapeOfCross(shape_of_cross_built), context);
        Ok(())
    }

    /// Semantic action for production 193:
    ///
    /// ShapeOfSquare: '正方形';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_square(
        &mut self,
        shape_of_square: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_square = shape_of_square.token(parse_tree)?.clone();
        let shape_of_square_built = ShapeOfSquareBuilder::default()
            .shape_of_square(shape_of_square)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.shape_of_square(&shape_of_square_built)?;
        self.push(ASTType::ShapeOfSquare(shape_of_square_built), context);
        Ok(())
    }

    /// Semantic action for production 194:
    ///
    /// ShapeOfBoardPerimeter: '盤面外周';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_board_perimeter(
        &mut self,
        shape_of_board_perimeter: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_board_perimeter = shape_of_board_perimeter.token(parse_tree)?.clone();
        let shape_of_board_perimeter_built = ShapeOfBoardPerimeterBuilder::default()
            .shape_of_board_perimeter(shape_of_board_perimeter)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .shape_of_board_perimeter(&shape_of_board_perimeter_built)?;
        self.push(
            ASTType::ShapeOfBoardPerimeter(shape_of_board_perimeter_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 195:
    ///
    /// ShapeOfBoardCenter: '盤面中央';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_board_center(
        &mut self,
        shape_of_board_center: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_board_center = shape_of_board_center.token(parse_tree)?.clone();
        let shape_of_board_center_built = ShapeOfBoardCenterBuilder::default()
            .shape_of_board_center(shape_of_board_center)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .shape_of_board_center(&shape_of_board_center_built)?;
        self.push(
            ASTType::ShapeOfBoardCenter(shape_of_board_center_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 196:
    ///
    /// ShapeOfBoardTop: '盤面上部';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_board_top(
        &mut self,
        shape_of_board_top: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_board_top = shape_of_board_top.token(parse_tree)?.clone();
        let shape_of_board_top_built = ShapeOfBoardTopBuilder::default()
            .shape_of_board_top(shape_of_board_top)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .shape_of_board_top(&shape_of_board_top_built)?;
        self.push(ASTType::ShapeOfBoardTop(shape_of_board_top_built), context);
        Ok(())
    }

    /// Semantic action for production 197:
    ///
    /// ShapeOfBoardBottom: '盤面下部';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_board_bottom(
        &mut self,
        shape_of_board_bottom: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_board_bottom = shape_of_board_bottom.token(parse_tree)?.clone();
        let shape_of_board_bottom_built = ShapeOfBoardBottomBuilder::default()
            .shape_of_board_bottom(shape_of_board_bottom)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .shape_of_board_bottom(&shape_of_board_bottom_built)?;
        self.push(
            ASTType::ShapeOfBoardBottom(shape_of_board_bottom_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 198:
    ///
    /// ShapeOfBoardCorners: '盤面4隅';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_board_corners(
        &mut self,
        shape_of_board_corners: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_board_corners = shape_of_board_corners.token(parse_tree)?.clone();
        let shape_of_board_corners_built = ShapeOfBoardCornersBuilder::default()
            .shape_of_board_corners(shape_of_board_corners)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .shape_of_board_corners(&shape_of_board_corners_built)?;
        self.push(
            ASTType::ShapeOfBoardCorners(shape_of_board_corners_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 199:
    ///
    /// ShapeOfSpiderweb: '蜘蛛の巣状';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_spiderweb(
        &mut self,
        shape_of_spiderweb: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_spiderweb = shape_of_spiderweb.token(parse_tree)?.clone();
        let shape_of_spiderweb_built = ShapeOfSpiderwebBuilder::default()
            .shape_of_spiderweb(shape_of_spiderweb)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .shape_of_spiderweb(&shape_of_spiderweb_built)?;
        self.push(ASTType::ShapeOfSpiderweb(shape_of_spiderweb_built), context);
        Ok(())
    }

    /// Semantic action for production 200:
    ///
    /// ShapeOfCrescentMoon: '三日月状';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_crescent_moon(
        &mut self,
        shape_of_crescent_moon: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_crescent_moon = shape_of_crescent_moon.token(parse_tree)?.clone();
        let shape_of_crescent_moon_built = ShapeOfCrescentMoonBuilder::default()
            .shape_of_crescent_moon(shape_of_crescent_moon)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .shape_of_crescent_moon(&shape_of_crescent_moon_built)?;
        self.push(
            ASTType::ShapeOfCrescentMoon(shape_of_crescent_moon_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 201:
    ///
    /// ShapeOfOblique: '斜め';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_oblique(
        &mut self,
        shape_of_oblique: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_oblique = shape_of_oblique.token(parse_tree)?.clone();
        let shape_of_oblique_built = ShapeOfObliqueBuilder::default()
            .shape_of_oblique(shape_of_oblique)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .shape_of_oblique(&shape_of_oblique_built)?;
        self.push(ASTType::ShapeOfOblique(shape_of_oblique_built), context);
        Ok(())
    }

    /// Semantic action for production 202:
    ///
    /// ShapeOfSomeKind: 'の形';
    ///
    #[parol_runtime::function_name::named]
    fn shape_of_some_kind(
        &mut self,
        shape_of_some_kind: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let shape_of_some_kind = shape_of_some_kind.token(parse_tree)?.clone();
        let shape_of_some_kind_built = ShapeOfSomeKindBuilder::default()
            .shape_of_some_kind(shape_of_some_kind)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .shape_of_some_kind(&shape_of_some_kind_built)?;
        self.push(ASTType::ShapeOfSomeKind(shape_of_some_kind_built), context);
        Ok(())
    }

    /// Semantic action for production 203:
    ///
    /// WordChange: '変化';
    ///
    #[parol_runtime::function_name::named]
    fn word_change(
        &mut self,
        word_change: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_change = word_change.token(parse_tree)?.clone();
        let word_change_built = WordChangeBuilder::default()
            .word_change(word_change)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_change(&word_change_built)?;
        self.push(ASTType::WordChange(word_change_built), context);
        Ok(())
    }

    /// Semantic action for production 204:
    ///
    /// WordDrop: 'ドロップ';
    ///
    #[parol_runtime::function_name::named]
    fn word_drop(
        &mut self,
        word_drop: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = word_drop.token(parse_tree)?.clone();
        let word_drop_built = WordDropBuilder::default()
            .word_drop(word_drop)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_drop(&word_drop_built)?;
        self.push(ASTType::WordDrop(word_drop_built), context);
        Ok(())
    }

    /// Semantic action for production 205:
    ///
    /// WordAll: '全';
    ///
    #[parol_runtime::function_name::named]
    fn word_all(
        &mut self,
        word_all: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_all = word_all.token(parse_tree)?.clone();
        let word_all_built = WordAllBuilder::default()
            .word_all(word_all)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_all(&word_all_built)?;
        self.push(ASTType::WordAll(word_all_built), context);
        Ok(())
    }

    /// Semantic action for production 206:
    ///
    /// WordFiveAttribute: '5属性';
    ///
    #[parol_runtime::function_name::named]
    fn word_five_attribute(
        &mut self,
        word_five_attribute: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_five_attribute = word_five_attribute.token(parse_tree)?.clone();
        let word_five_attribute_built = WordFiveAttributeBuilder::default()
            .word_five_attribute(word_five_attribute)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .word_five_attribute(&word_five_attribute_built)?;
        self.push(
            ASTType::WordFiveAttribute(word_five_attribute_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 207:
    ///
    /// WordRandom: 'ランダム';
    ///
    #[parol_runtime::function_name::named]
    fn word_random(
        &mut self,
        word_random: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_random = word_random.token(parse_tree)?.clone();
        let word_random_built = WordRandomBuilder::default()
            .word_random(word_random)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_random(&word_random_built)?;
        self.push(ASTType::WordRandom(word_random_built), context);
        Ok(())
    }

    /// Semantic action for production 208:
    ///
    /// WordReplace: '入れ替える';
    ///
    #[parol_runtime::function_name::named]
    fn word_replace(
        &mut self,
        word_replace: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_replace = word_replace.token(parse_tree)?.clone();
        let word_replace_built = WordReplaceBuilder::default()
            .word_replace(word_replace)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_replace(&word_replace_built)?;
        self.push(ASTType::WordReplace(word_replace_built), context);
        Ok(())
    }

    /// Semantic action for production 209:
    ///
    /// WordCount: WordCountOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn word_count(
        &mut self,
        _word_count_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_count_opt = pop_item!(self, word_count_opt, WordCountOpt, context);
        let word_count_built = WordCountBuilder::default()
            .word_count_opt(word_count_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_count(&word_count_built)?;
        self.push(ASTType::WordCount(word_count_built), context);
        Ok(())
    }

    /// Semantic action for production 210:
    ///
    /// WordCountOpt /* Option<T>::Some */: WordCountOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn word_count_opt_0(
        &mut self,
        _word_count_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_count_opt_group =
            pop_item!(self, word_count_opt_group, WordCountOptGroup, context);
        let word_count_opt_0_built = WordCountOptBuilder::default()
            .word_count_opt_group(Box::new(word_count_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::WordCountOpt(Some(Box::new(word_count_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 211:
    ///
    /// WordCountOptGroup: '個';
    ///
    #[parol_runtime::function_name::named]
    fn word_count_opt_group_0(
        &mut self,
        個: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let 個 = 個.token(parse_tree)?.clone();
        let word_count_opt_group_0_built = WordCountOptGroup個Builder::default()
            .個(個)
            .build()
            .into_diagnostic()?;
        let word_count_opt_group_0_built = WordCountOptGroup::個(word_count_opt_group_0_built);
        self.push(
            ASTType::WordCountOptGroup(word_count_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 212:
    ///
    /// WordCountOptGroup: 'つ';
    ///
    #[parol_runtime::function_name::named]
    fn word_count_opt_group_1(
        &mut self,
        つ: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let つ = つ.token(parse_tree)?.clone();
        let word_count_opt_group_1_built = WordCountOptGroupつBuilder::default()
            .つ(つ)
            .build()
            .into_diagnostic()?;
        let word_count_opt_group_1_built = WordCountOptGroup::つ(word_count_opt_group_1_built);
        self.push(
            ASTType::WordCountOptGroup(word_count_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 213:
    ///
    /// WordCountOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn word_count_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WordCountOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 214:
    ///
    /// WordGen: '生成';
    ///
    #[parol_runtime::function_name::named]
    fn word_gen(
        &mut self,
        word_gen: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_gen = word_gen.token(parse_tree)?.clone();
        let word_gen_built = WordGenBuilder::default()
            .word_gen(word_gen)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_gen(&word_gen_built)?;
        self.push(ASTType::WordGen(word_gen_built), context);
        Ok(())
    }

    /// Semantic action for production 215:
    ///
    /// WordOther: '以外';
    ///
    #[parol_runtime::function_name::named]
    fn word_other(
        &mut self,
        word_other: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_other = word_other.token(parse_tree)?.clone();
        let word_other_built = WordOtherBuilder::default()
            .word_other(word_other)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_other(&word_other_built)?;
        self.push(ASTType::WordOther(word_other_built), context);
        Ok(())
    }

    /// Semantic action for production 216:
    ///
    /// WordVertical: '縦';
    ///
    #[parol_runtime::function_name::named]
    fn word_vertical(
        &mut self,
        word_vertical: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_vertical = word_vertical.token(parse_tree)?.clone();
        let word_vertical_built = WordVerticalBuilder::default()
            .word_vertical(word_vertical)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_vertical(&word_vertical_built)?;
        self.push(ASTType::WordVertical(word_vertical_built), context);
        Ok(())
    }

    /// Semantic action for production 217:
    ///
    /// WordHorizon: '横';
    ///
    #[parol_runtime::function_name::named]
    fn word_horizon(
        &mut self,
        word_horizon: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_horizon = word_horizon.token(parse_tree)?.clone();
        let word_horizon_built = WordHorizonBuilder::default()
            .word_horizon(word_horizon)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_horizon(&word_horizon_built)?;
        self.push(ASTType::WordHorizon(word_horizon_built), context);
        Ok(())
    }

    /// Semantic action for production 218:
    ///
    /// WordRow: '段';
    ///
    #[parol_runtime::function_name::named]
    fn word_row(
        &mut self,
        word_row: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_row = word_row.token(parse_tree)?.clone();
        let word_row_built = WordRowBuilder::default()
            .word_row(word_row)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_row(&word_row_built)?;
        self.push(ASTType::WordRow(word_row_built), context);
        Ok(())
    }

    /// Semantic action for production 219:
    ///
    /// WordCol: '列';
    ///
    #[parol_runtime::function_name::named]
    fn word_col(
        &mut self,
        word_col: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_col = word_col.token(parse_tree)?.clone();
        let word_col_built = WordColBuilder::default()
            .word_col(word_col)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_col(&word_col_built)?;
        self.push(ASTType::WordCol(word_col_built), context);
        Ok(())
    }

    /// Semantic action for production 220:
    ///
    /// WordSide: '端';
    ///
    #[parol_runtime::function_name::named]
    fn word_side(
        &mut self,
        word_side: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_side = word_side.token(parse_tree)?.clone();
        let word_side_built = WordSideBuilder::default()
            .word_side(word_side)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_side(&word_side_built)?;
        self.push(ASTType::WordSide(word_side_built), context);
        Ok(())
    }

    /// Semantic action for production 221:
    ///
    /// WordLeftAndRight: '両';
    ///
    #[parol_runtime::function_name::named]
    fn word_left_and_right(
        &mut self,
        word_left_and_right: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_left_and_right = word_left_and_right.token(parse_tree)?.clone();
        let word_left_and_right_built = WordLeftAndRightBuilder::default()
            .word_left_and_right(word_left_and_right)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .word_left_and_right(&word_left_and_right_built)?;
        self.push(
            ASTType::WordLeftAndRight(word_left_and_right_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 222:
    ///
    /// WordLeft: '左';
    ///
    #[parol_runtime::function_name::named]
    fn word_left(
        &mut self,
        word_left: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_left = word_left.token(parse_tree)?.clone();
        let word_left_built = WordLeftBuilder::default()
            .word_left(word_left)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_left(&word_left_built)?;
        self.push(ASTType::WordLeft(word_left_built), context);
        Ok(())
    }

    /// Semantic action for production 223:
    ///
    /// WordRight: '右';
    ///
    #[parol_runtime::function_name::named]
    fn word_right(
        &mut self,
        word_right: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_right = word_right.token(parse_tree)?.clone();
        let word_right_built = WordRightBuilder::default()
            .word_right(word_right)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_right(&word_right_built)?;
        self.push(ASTType::WordRight(word_right_built), context);
        Ok(())
    }

    /// Semantic action for production 224:
    ///
    /// WordTop: '上';
    ///
    #[parol_runtime::function_name::named]
    fn word_top(
        &mut self,
        word_top: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_top = word_top.token(parse_tree)?.clone();
        let word_top_built = WordTopBuilder::default()
            .word_top(word_top)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_top(&word_top_built)?;
        self.push(ASTType::WordTop(word_top_built), context);
        Ok(())
    }

    /// Semantic action for production 225:
    ///
    /// WordBottom: '下';
    ///
    #[parol_runtime::function_name::named]
    fn word_bottom(
        &mut self,
        word_bottom: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_bottom = word_bottom.token(parse_tree)?.clone();
        let word_bottom_built = WordBottomBuilder::default()
            .word_bottom(word_bottom)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_bottom(&word_bottom_built)?;
        self.push(ASTType::WordBottom(word_bottom_built), context);
        Ok(())
    }

    /// Semantic action for production 226:
    ///
    /// WordMost: '最';
    ///
    #[parol_runtime::function_name::named]
    fn word_most(
        &mut self,
        word_most: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_most = word_most.token(parse_tree)?.clone();
        let word_most_built = WordMostBuilder::default()
            .word_most(word_most)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_most(&word_most_built)?;
        self.push(ASTType::WordMost(word_most_built), context);
        Ok(())
    }

    /// Semantic action for production 227:
    ///
    /// WordLook: '目';
    ///
    #[parol_runtime::function_name::named]
    fn word_look(
        &mut self,
        word_look: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_look = word_look.token(parse_tree)?.clone();
        let word_look_built = WordLookBuilder::default()
            .word_look(word_look)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_look(&word_look_built)?;
        self.push(ASTType::WordLook(word_look_built), context);
        Ok(())
    }

    /// Semantic action for production 228:
    ///
    /// WordBoard: '盤面';
    ///
    #[parol_runtime::function_name::named]
    fn word_board(
        &mut self,
        word_board: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_board = word_board.token(parse_tree)?.clone();
        let word_board_built = WordBoardBuilder::default()
            .word_board(word_board)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_board(&word_board_built)?;
        self.push(ASTType::WordBoard(word_board_built), context);
        Ok(())
    }

    /// Semantic action for production 229:
    ///
    /// WordRelease: '解除';
    ///
    #[parol_runtime::function_name::named]
    fn word_release(
        &mut self,
        word_release: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_release = word_release.token(parse_tree)?.clone();
        let word_release_built = WordReleaseBuilder::default()
            .word_release(word_release)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_release(&word_release_built)?;
        self.push(ASTType::WordRelease(word_release_built), context);
        Ok(())
    }

    /// Semantic action for production 230:
    ///
    /// WordLock: 'ロック';
    ///
    #[parol_runtime::function_name::named]
    fn word_lock(
        &mut self,
        word_lock: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_lock = word_lock.token(parse_tree)?.clone();
        let word_lock_built = WordLockBuilder::default()
            .word_lock(word_lock)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_lock(&word_lock_built)?;
        self.push(ASTType::WordLock(word_lock_built), context);
        Ok(())
    }

    /// Semantic action for production 231:
    ///
    /// WordState: '状態';
    ///
    #[parol_runtime::function_name::named]
    fn word_state(
        &mut self,
        word_state: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_state = word_state.token(parse_tree)?.clone();
        let word_state_built = WordStateBuilder::default()
            .word_state(word_state)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_state(&word_state_built)?;
        self.push(ASTType::WordState(word_state_built), context);
        Ok(())
    }

    /// Semantic action for production 232:
    ///
    /// WordPowerUp: '強化';
    ///
    #[parol_runtime::function_name::named]
    fn word_power_up(
        &mut self,
        word_power_up: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_power_up = word_power_up.token(parse_tree)?.clone();
        let word_power_up_built = WordPowerUpBuilder::default()
            .word_power_up(word_power_up)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_power_up(&word_power_up_built)?;
        self.push(ASTType::WordPowerUp(word_power_up_built), context);
        Ok(())
    }

    /// Semantic action for production 233:
    ///
    /// WordTurn: 'ターン';
    ///
    #[parol_runtime::function_name::named]
    fn word_turn(
        &mut self,
        word_turn: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_turn = word_turn.token(parse_tree)?.clone();
        let word_turn_built = WordTurnBuilder::default()
            .word_turn(word_turn)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_turn(&word_turn_built)?;
        self.push(ASTType::WordTurn(word_turn_built), context);
        Ok(())
    }

    /// Semantic action for production 234:
    ///
    /// WordBetween: '間';
    ///
    #[parol_runtime::function_name::named]
    fn word_between(
        &mut self,
        word_between: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_between = word_between.token(parse_tree)?.clone();
        let word_between_built = WordBetweenBuilder::default()
            .word_between(word_between)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_between(&word_between_built)?;
        self.push(ASTType::WordBetween(word_between_built), context);
        Ok(())
    }

    /// Semantic action for production 235:
    ///
    /// WordLittleMore: 'ほんの少し';
    ///
    #[parol_runtime::function_name::named]
    fn word_little_more(
        &mut self,
        word_little_more: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_little_more = word_little_more.token(parse_tree)?.clone();
        let word_little_more_built = WordLittleMoreBuilder::default()
            .word_little_more(word_little_more)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .word_little_more(&word_little_more_built)?;
        self.push(ASTType::WordLittleMore(word_little_more_built), context);
        Ok(())
    }

    /// Semantic action for production 236:
    ///
    /// WordLittle: '少し';
    ///
    #[parol_runtime::function_name::named]
    fn word_little(
        &mut self,
        word_little: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_little = word_little.token(parse_tree)?.clone();
        let word_little_built = WordLittleBuilder::default()
            .word_little(word_little)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_little(&word_little_built)?;
        self.push(ASTType::WordLittle(word_little_built), context);
        Ok(())
    }

    /// Semantic action for production 237:
    ///
    /// WordOnly: 'のみ';
    ///
    #[parol_runtime::function_name::named]
    fn word_only(
        &mut self,
        word_only: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_only = word_only.token(parse_tree)?.clone();
        let word_only_built = WordOnlyBuilder::default()
            .word_only(word_only)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_only(&word_only_built)?;
        self.push(ASTType::WordOnly(word_only_built), context);
        Ok(())
    }

    /// Semantic action for production 238:
    ///
    /// WordFalloff: '落ちやすくなる';
    ///
    #[parol_runtime::function_name::named]
    fn word_falloff(
        &mut self,
        word_falloff: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_falloff = word_falloff.token(parse_tree)?.clone();
        let word_falloff_built = WordFalloffBuilder::default()
            .word_falloff(word_falloff)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_falloff(&word_falloff_built)?;
        self.push(ASTType::WordFalloff(word_falloff_built), context);
        Ok(())
    }

    /// Semantic action for production 239:
    ///
    /// WordFall: '落ちてくる';
    ///
    #[parol_runtime::function_name::named]
    fn word_fall(
        &mut self,
        word_fall: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_fall = word_fall.token(parse_tree)?.clone();
        let word_fall_built = WordFallBuilder::default()
            .word_fall(word_fall)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_fall(&word_fall_built)?;
        self.push(ASTType::WordFall(word_fall_built), context);
        Ok(())
    }

    /// Semantic action for production 240:
    ///
    /// Wo: 'を';
    ///
    #[parol_runtime::function_name::named]
    fn wo(
        &mut self,
        wo: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let wo = wo.token(parse_tree)?.clone();
        let wo_built = WoBuilder::default().wo(wo).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.wo(&wo_built)?;
        self.push(ASTType::Wo(wo_built), context);
        Ok(())
    }

    /// Semantic action for production 241:
    ///
    /// Ni: 'に';
    ///
    #[parol_runtime::function_name::named]
    fn ni(
        &mut self,
        ni: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ni = ni.token(parse_tree)?.clone();
        let ni_built = NiBuilder::default().ni(ni).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ni(&ni_built)?;
        self.push(ASTType::Ni(ni_built), context);
        Ok(())
    }

    /// Semantic action for production 242:
    ///
    /// No: 'の';
    ///
    #[parol_runtime::function_name::named]
    fn no(
        &mut self,
        no: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let no = no.token(parse_tree)?.clone();
        let no_built = NoBuilder::default().no(no).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.no(&no_built)?;
        self.push(ASTType::No(no_built), context);
        Ok(())
    }

    /// Semantic action for production 243:
    ///
    /// So: 'で';
    ///
    #[parol_runtime::function_name::named]
    fn so(
        &mut self,
        so: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let so = so.token(parse_tree)?.clone();
        let so_built = SoBuilder::default().so(so).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.so(&so_built)?;
        self.push(ASTType::So(so_built), context);
        Ok(())
    }

    /// Semantic action for production 244:
    ///
    /// And: 'と';
    ///
    #[parol_runtime::function_name::named]
    fn and(
        &mut self,
        and: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let and = and.token(parse_tree)?.clone();
        let and_built = AndBuilder::default().and(and).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.and(&and_built)?;
        self.push(ASTType::And(and_built), context);
        Ok(())
    }

    /// Semantic action for production 245:
    ///
    /// Si: 'し';
    ///
    #[parol_runtime::function_name::named]
    fn si(
        &mut self,
        si: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let si = si.token(parse_tree)?.clone();
        let si_built = SiBuilder::default().si(si).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.si(&si_built)?;
        self.push(ASTType::Si(si_built), context);
        Ok(())
    }

    /// Semantic action for production 246:
    ///
    /// Ga: 'が';
    ///
    #[parol_runtime::function_name::named]
    fn ga(
        &mut self,
        ga: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ga = ga.token(parse_tree)?.clone();
        let ga_built = GaBuilder::default().ga(ga).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ga(&ga_built)?;
        self.push(ASTType::Ga(ga_built), context);
        Ok(())
    }

    /// Semantic action for production 247:
    ///
    /// Each: 'ずつ';
    ///
    #[parol_runtime::function_name::named]
    fn each(
        &mut self,
        each: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let each = each.token(parse_tree)?.clone();
        let each_built = EachBuilder::default()
            .each(each)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.each(&each_built)?;
        self.push(ASTType::Each(each_built), context);
        Ok(())
    }

    /// Semantic action for production 248:
    ///
    /// From: 'から';
    ///
    #[parol_runtime::function_name::named]
    fn from(
        &mut self,
        from: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let from = from.token(parse_tree)?.clone();
        let from_built = FromBuilder::default()
            .from(from)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.from(&from_built)?;
        self.push(ASTType::From(from_built), context);
        Ok(())
    }

    /// Semantic action for production 249:
    ///
    /// Plus: '+';
    ///
    #[parol_runtime::function_name::named]
    fn plus(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token(parse_tree)?.clone();
        let plus_built = PlusBuilder::default()
            .plus(plus)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(&plus_built)?;
        self.push(ASTType::Plus(plus_built), context);
        Ok(())
    }

    /// Semantic action for production 250:
    ///
    /// Multi: '×';
    ///
    #[parol_runtime::function_name::named]
    fn multi(
        &mut self,
        multi: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let multi = multi.token(parse_tree)?.clone();
        let multi_built = MultiBuilder::default()
            .multi(multi)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.multi(&multi_built)?;
        self.push(ASTType::Multi(multi_built), context);
        Ok(())
    }

    /// Semantic action for production 251:
    ///
    /// Camma: '、';
    ///
    #[parol_runtime::function_name::named]
    fn camma(
        &mut self,
        camma: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let camma = camma.token(parse_tree)?.clone();
        let camma_built = CammaBuilder::default()
            .camma(camma)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.camma(&camma_built)?;
        self.push(ASTType::Camma(camma_built), context);
        Ok(())
    }

    /// Semantic action for production 252:
    ///
    /// Period: '。';
    ///
    #[parol_runtime::function_name::named]
    fn period(
        &mut self,
        period: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let period = period.token(parse_tree)?.clone();
        let period_built = PeriodBuilder::default()
            .period(period)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.period(&period_built)?;
        self.push(ASTType::Period(period_built), context);
        Ok(())
    }

    /// Semantic action for production 253:
    ///
    /// PosInt: "[1-9]([0-9])*";
    ///
    #[parol_runtime::function_name::named]
    fn pos_int(
        &mut self,
        pos_int: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pos_int = pos_int.token(parse_tree)?.clone();
        let pos_int_built = PosIntBuilder::default()
            .pos_int(pos_int)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.pos_int(&pos_int_built)?;
        self.push(ASTType::PosInt(pos_int_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for SkillGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item SkillGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.skill_lines(&children[0], &children[1], parse_tree),
            1 => self.line_0(&children[0], parse_tree),
            2 => self.line_1(&children[0], parse_tree),
            3 => self.line_2(&children[0], parse_tree),
            4 => self.line_3(&children[0], parse_tree),
            5 => self.group_of_drop_change_0(&children[0], &children[1], parse_tree),
            6 => self.group_of_drop_change_1(&children[0], parse_tree),
            7 => self.group_of_drop_change_opt0_0(&children[0], parse_tree),
            8 => self.group_of_drop_change_opt0_group_0(&children[0], parse_tree),
            9 => self.group_of_drop_change_opt0_group_1(&children[0], parse_tree),
            10 => self.group_of_drop_change_opt0_group_2(&children[0], parse_tree),
            11 => self.group_of_drop_change_opt0_1(parse_tree),
            12 => self.group_of_drop_change_opt_0(&children[0], parse_tree),
            13 => self.group_of_drop_change_opt_1(parse_tree),
            14 => self.change_drop_with_drop_unlock_line(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            15 => self.change_drop_with_drop_unlock_line_opt0_0(&children[0], parse_tree),
            16 => self.change_drop_with_drop_unlock_line_opt0_group_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            17 => self.change_drop_with_drop_unlock_line_opt0_group_1(&children[0], parse_tree),
            18 => self.change_drop_with_drop_unlock_line_opt0_group_2(&children[0], parse_tree),
            19 => self.change_drop_with_drop_unlock_line_opt0_group_3(&children[0], parse_tree),
            20 => self.change_drop_with_drop_unlock_line_opt1_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            21 => self.change_drop_with_drop_unlock_line_opt1_1(parse_tree),
            22 => self.change_drop_with_drop_unlock_line_opt0_1(parse_tree),
            23 => self.change_drop_with_drop_unlock_line_opt_0(&children[0], parse_tree),
            24 => self.change_drop_with_drop_unlock_line_opt_group_0(&children[0], parse_tree),
            25 => self.change_drop_with_drop_unlock_line_opt_group_1(&children[0], parse_tree),
            26 => self.change_drop_with_drop_unlock_line_opt_1(parse_tree),
            27 => self.starts_with_drop_line(&children[0], &children[1], parse_tree),
            28 => self.starts_with_drop_line_suffix0_0(&children[0], &children[1], parse_tree),
            29 => self.starts_with_drop_line_suffix0_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            30 => self.starts_with_drop_line_suffix_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            31 => self.starts_with_drop_line_suffix_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            32 => self.starts_with_drop_line_suffix_2(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            33 => self.starts_with_drop_line_suffix_3(&children[0], parse_tree),
            34 => self.starts_with_drop_line_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            35 => self.starts_with_drop_line_list_1(parse_tree),
            36 => self.starts_with_drop_line_list0_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            37 => self.starts_with_drop_line_list0_1(parse_tree),
            38 => self.starts_with_drop_line_opt_0(&children[0], parse_tree),
            39 => self.starts_with_drop_line_opt_group_0(&children[0], parse_tree),
            40 => self.starts_with_drop_line_opt_group_1(&children[0], parse_tree),
            41 => self.starts_with_drop_line_opt_1(parse_tree),
            42 => self.gen_random_drop_stmt(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            43 => self.gen_random_drop_stmt_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            44 => self.gen_random_drop_stmt_list_1(parse_tree),
            45 => self.gen_random_drop_block(&children[0], &children[1], &children[2], parse_tree),
            46 => self.gen_shape_stmt(&children[0], &children[1], parse_tree),
            47 => self.gen_shape_stmt_opt_0(&children[0], parse_tree),
            48 => self.gen_shape_stmt_opt_group_0(&children[0], parse_tree),
            49 => self.gen_shape_stmt_opt_group_1(&children[0], parse_tree),
            50 => self.gen_shape_stmt_opt_1(parse_tree),
            51 => self.drop_refresh_stmt(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            52 => self.drop_un_lock_stmt(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            53 => self.turns_of_apply_stmt(&children[0], &children[1], parse_tree),
            54 => self.change_drop_block_other_first(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            55 => self.gen_shape_block_0(&children[0], &children[1], parse_tree),
            56 => self.gen_shape_block_list_0(&children[0], &children[1], &children[2], parse_tree),
            57 => self.gen_shape_block_list_1(parse_tree),
            58 => self.gen_shape_block_1(&children[0], parse_tree),
            59 => self.gen_shape_block_row_col(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            60 => self.gen_shape_block_other_row_col(&children[0], &children[1], parse_tree),
            61 => self.gen_shape_block_other_row_col_suffix_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            62 => self.gen_shape_block_other_row_col_suffix_1(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            63 => self.gen_shape_block_other_row_col_opt_0(&children[0], parse_tree),
            64 => self.gen_shape_block_other_row_col_opt_1(parse_tree),
            65 => self.g_s_start_position_0(&children[0], parse_tree),
            66 => self.g_s_start_position_1(&children[0], parse_tree),
            67 => self.g_s_s_p_side(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            68 => self.g_s_s_p_side_opt0_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            69 => self.g_s_s_p_side_opt1_0(&children[0], parse_tree),
            70 => self.g_s_s_p_side_opt1_1(parse_tree),
            71 => self.g_s_s_p_side_opt0_1(parse_tree),
            72 => self.g_s_s_p_side_opt_0(&children[0], parse_tree),
            73 => self.g_s_s_p_side_opt_1(parse_tree),
            74 => self.g_s_s_p_center(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            75 => self.g_s_s_p_center_opt0_0(&children[0], parse_tree),
            76 => self.g_s_s_p_center_opt0_group_0(&children[0], parse_tree),
            77 => self.g_s_s_p_center_opt0_group_1(&children[0], parse_tree),
            78 => self.g_s_s_p_center_opt0_1(parse_tree),
            79 => self.g_s_s_p_center_opt_0(&children[0], parse_tree),
            80 => self.g_s_s_p_center_opt_1(parse_tree),
            81 => self.g_s_s_p_center_blocks(&children[0], &children[1], parse_tree),
            82 => self.g_s_s_p_center_blocks_opt_0(&children[0], &children[1], parse_tree),
            83 => self.g_s_s_p_center_blocks_opt_1(parse_tree),
            84 => self.g_s_s_p_center_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            85 => self.g_s_s_p_center_block_opt_0(&children[0], parse_tree),
            86 => self.g_s_s_p_center_block_opt_group_0(&children[0], parse_tree),
            87 => self.g_s_s_p_center_block_opt_group_1(&children[0], parse_tree),
            88 => self.g_s_s_p_center_block_opt_1(parse_tree),
            89 => self.position_0(&children[0], &children[1], parse_tree),
            90 => self.position_1(&children[0], parse_tree),
            91 => self.g_s_s_p_side_write_width_0(&children[0], &children[1], parse_tree),
            92 => self.g_s_s_p_side_write_width_1(&children[0], parse_tree),
            93 => self.g_s_s_p_side_write_width_opt_0(&children[0], parse_tree),
            94 => self.g_s_s_p_side_write_width_opt_1(parse_tree),
            95 => self.position_l_r_t_b_0(&children[0], parse_tree),
            96 => self.position_l_r_t_b_1(&children[0], parse_tree),
            97 => self.position_l_r_t_b_2(&children[0], parse_tree),
            98 => self.position_l_r_t_b_3(&children[0], parse_tree),
            99 => self.position_l_r_0(&children[0], parse_tree),
            100 => self.position_l_r_1(&children[0], parse_tree),
            101 => self.position_l_r_2(&children[0], parse_tree),
            102 => self.position_t_b(&children[0], &children[1], &children[2], parse_tree),
            103 => self.position_t_b_opt_0(&children[0], parse_tree),
            104 => self.position_t_b_opt_1(parse_tree),
            105 => self.position_t_or_b_0(&children[0], parse_tree),
            106 => self.position_t_or_b_1(&children[0], parse_tree),
            107 => self.gen_shape_num_of_gen(&children[0], &children[1], parse_tree),
            108 => self.shape_type_0(&children[0], parse_tree),
            109 => self.shape_type_1(&children[0], &children[1], parse_tree),
            110 => self.shape_type_2(&children[0], parse_tree),
            111 => self.shape_type_3(&children[0], &children[1], &children[2], parse_tree),
            112 => self.shape_type_4(&children[0], parse_tree),
            113 => self.shape_type_5(&children[0], parse_tree),
            114 => self.shape_type_6(&children[0], parse_tree),
            115 => self.shape_type_7(&children[0], parse_tree),
            116 => self.shape_type_8(&children[0], parse_tree),
            117 => self.shape_type_9(&children[0], parse_tree),
            118 => self.shape_type_10(&children[0], parse_tree),
            119 => self.shape_type_11(&children[0], &children[1], parse_tree),
            120 => self.shape_type_12(&children[0], &children[1], parse_tree),
            121 => self.shape_type_opt0_0(&children[0], parse_tree),
            122 => self.shape_type_opt0_1(parse_tree),
            123 => self.shape_type_opt_0(&children[0], parse_tree),
            124 => self.shape_type_opt_1(parse_tree),
            125 => self.drop_unlock_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            126 => self.drop_unlock_block_opt_0(&children[0], &children[1], parse_tree),
            127 => self.drop_unlock_block_opt0_0(&children[0], parse_tree),
            128 => self.drop_unlock_block_opt0_1(parse_tree),
            129 => self.drop_unlock_block_opt_1(parse_tree),
            130 => self.drops_0(&children[0], &children[1], parse_tree),
            131 => self.drops_suffix_0(&children[0], parse_tree),
            132 => self.drops_1(&children[0], &children[1], parse_tree),
            133 => self.drops_suffix_1(&children[0], &children[1], parse_tree),
            134 => self.drops_list_0(&children[0], &children[1], parse_tree),
            135 => self.drops_list_1(parse_tree),
            136 => self.drops_list0_0(&children[0], &children[1], &children[2], parse_tree),
            137 => self.drops_list0_1(parse_tree),
            138 => self.many_drop_0(&children[0], &children[1], parse_tree),
            139 => self.many_drop_1(&children[0], &children[1], parse_tree),
            140 => self.all_drops(&children[0], &children[1], parse_tree),
            141 => self.five_attribute(&children[0], &children[1], parse_tree),
            142 => self.five_attribute_opt_0(&children[0], parse_tree),
            143 => self.five_attribute_opt_1(parse_tree),
            144 => self.quantity(&children[0], &children[1], &children[2], parse_tree),
            145 => self.quantity_opt_0(&children[0], parse_tree),
            146 => self.quantity_opt_1(parse_tree),
            147 => self.drop_0(&children[0], &children[1], parse_tree),
            148 => self.drop_1(&children[0], &children[1], parse_tree),
            149 => self.drop_opt0_0(&children[0], parse_tree),
            150 => self.drop_opt0_1(parse_tree),
            151 => self.drop_opt_0(&children[0], parse_tree),
            152 => self.drop_opt_1(parse_tree),
            153 => self.non_colored_drop_0(&children[0], parse_tree),
            154 => self.non_colored_drop_1(&children[0], parse_tree),
            155 => self.non_colored_drop_2(&children[0], parse_tree),
            156 => self.non_colored_drop_3(&children[0], parse_tree),
            157 => self.non_colored_drop_4(&children[0], parse_tree),
            158 => self.color_0(&children[0], parse_tree),
            159 => self.color_1(&children[0], parse_tree),
            160 => self.color_2(&children[0], parse_tree),
            161 => self.color_3(&children[0], parse_tree),
            162 => self.color_4(&children[0], parse_tree),
            163 => self.random_suffix(&children[0], &children[1], parse_tree),
            164 => self.size(&children[0], &children[1], &children[2], parse_tree),
            165 => self.on_board(&children[0], &children[1], &children[2], parse_tree),
            166 => self.turns(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            167 => self.turns_of_apply_block(&children[0], parse_tree),
            168 => self.drops_easier_to_falloff(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            169 => self.drops_easier_to_falloff_opt1_0(&children[0], parse_tree),
            170 => self.drops_easier_to_falloff_opt1_group_0(&children[0], parse_tree),
            171 => self.drops_easier_to_falloff_opt1_group_1(&children[0], parse_tree),
            172 => self.drops_easier_to_falloff_opt1_1(parse_tree),
            173 => self.drops_easier_to_falloff_opt0_0(&children[0], parse_tree),
            174 => self.drops_easier_to_falloff_opt0_1(parse_tree),
            175 => self.drops_easier_to_falloff_opt_0(&children[0], parse_tree),
            176 => self.drops_easier_to_falloff_opt_1(parse_tree),
            177 => self.skill_volume_variation_0(&children[0], parse_tree),
            178 => self.skill_volume_variation_1(&children[0], parse_tree),
            179 => self.skill_volume_variation_2(&children[0], parse_tree),
            180 => self.fire(&children[0], parse_tree),
            181 => self.water(&children[0], parse_tree),
            182 => self.wood(&children[0], parse_tree),
            183 => self.lightning(&children[0], parse_tree),
            184 => self.dark(&children[0], parse_tree),
            185 => self.recovery(&children[0], parse_tree),
            186 => self.disturb(&children[0], parse_tree),
            187 => self.bomb(&children[0], parse_tree),
            188 => self.deadly_poison(&children[0], parse_tree),
            189 => self.poison(&children[0], parse_tree),
            190 => self.shape_of_l(&children[0], parse_tree),
            191 => self.shape_of_z(&children[0], parse_tree),
            192 => self.shape_of_cross(&children[0], parse_tree),
            193 => self.shape_of_square(&children[0], parse_tree),
            194 => self.shape_of_board_perimeter(&children[0], parse_tree),
            195 => self.shape_of_board_center(&children[0], parse_tree),
            196 => self.shape_of_board_top(&children[0], parse_tree),
            197 => self.shape_of_board_bottom(&children[0], parse_tree),
            198 => self.shape_of_board_corners(&children[0], parse_tree),
            199 => self.shape_of_spiderweb(&children[0], parse_tree),
            200 => self.shape_of_crescent_moon(&children[0], parse_tree),
            201 => self.shape_of_oblique(&children[0], parse_tree),
            202 => self.shape_of_some_kind(&children[0], parse_tree),
            203 => self.word_change(&children[0], parse_tree),
            204 => self.word_drop(&children[0], parse_tree),
            205 => self.word_all(&children[0], parse_tree),
            206 => self.word_five_attribute(&children[0], parse_tree),
            207 => self.word_random(&children[0], parse_tree),
            208 => self.word_replace(&children[0], parse_tree),
            209 => self.word_count(&children[0], parse_tree),
            210 => self.word_count_opt_0(&children[0], parse_tree),
            211 => self.word_count_opt_group_0(&children[0], parse_tree),
            212 => self.word_count_opt_group_1(&children[0], parse_tree),
            213 => self.word_count_opt_1(parse_tree),
            214 => self.word_gen(&children[0], parse_tree),
            215 => self.word_other(&children[0], parse_tree),
            216 => self.word_vertical(&children[0], parse_tree),
            217 => self.word_horizon(&children[0], parse_tree),
            218 => self.word_row(&children[0], parse_tree),
            219 => self.word_col(&children[0], parse_tree),
            220 => self.word_side(&children[0], parse_tree),
            221 => self.word_left_and_right(&children[0], parse_tree),
            222 => self.word_left(&children[0], parse_tree),
            223 => self.word_right(&children[0], parse_tree),
            224 => self.word_top(&children[0], parse_tree),
            225 => self.word_bottom(&children[0], parse_tree),
            226 => self.word_most(&children[0], parse_tree),
            227 => self.word_look(&children[0], parse_tree),
            228 => self.word_board(&children[0], parse_tree),
            229 => self.word_release(&children[0], parse_tree),
            230 => self.word_lock(&children[0], parse_tree),
            231 => self.word_state(&children[0], parse_tree),
            232 => self.word_power_up(&children[0], parse_tree),
            233 => self.word_turn(&children[0], parse_tree),
            234 => self.word_between(&children[0], parse_tree),
            235 => self.word_little_more(&children[0], parse_tree),
            236 => self.word_little(&children[0], parse_tree),
            237 => self.word_only(&children[0], parse_tree),
            238 => self.word_falloff(&children[0], parse_tree),
            239 => self.word_fall(&children[0], parse_tree),
            240 => self.wo(&children[0], parse_tree),
            241 => self.ni(&children[0], parse_tree),
            242 => self.no(&children[0], parse_tree),
            243 => self.so(&children[0], parse_tree),
            244 => self.and(&children[0], parse_tree),
            245 => self.si(&children[0], parse_tree),
            246 => self.ga(&children[0], parse_tree),
            247 => self.each(&children[0], parse_tree),
            248 => self.from(&children[0], parse_tree),
            249 => self.plus(&children[0], parse_tree),
            250 => self.multi(&children[0], parse_tree),
            251 => self.camma(&children[0], parse_tree),
            252 => self.period(&children[0], parse_tree),
            253 => self.pos_int(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
