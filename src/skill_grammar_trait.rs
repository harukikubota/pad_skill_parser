// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use derive_builder::Builder;
use parol_runtime::id_tree::Tree;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
#[allow(unused_imports)]
use parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait SkillGrammarTrait<'t> {
    /// Semantic action for non-terminal 'SkillLines'
    fn skill_lines(&mut self, _arg: &SkillLines<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Line'
    fn line(&mut self, _arg: &Line<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ChangeDropStmt'
    fn change_drop_stmt(&mut self, _arg: &ChangeDropStmt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ChangeDropBlock'
    fn change_drop_block(&mut self, _arg: &ChangeDropBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Drops'
    fn drops(&mut self, _arg: &Drops<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Drop'
    fn drop(&mut self, _arg: &Drop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NonColoredDrop'
    fn non_colored_drop(&mut self, _arg: &NonColoredDrop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Color'
    fn color(&mut self, _arg: &Color<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Fire'
    fn fire(&mut self, _arg: &Fire<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Water'
    fn water(&mut self, _arg: &Water<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Wood'
    fn wood(&mut self, _arg: &Wood<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Lightning'
    fn lightning(&mut self, _arg: &Lightning<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dark'
    fn dark(&mut self, _arg: &Dark<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Recovery'
    fn recovery(&mut self, _arg: &Recovery<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Disturb'
    fn disturb(&mut self, _arg: &Disturb<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bomb'
    fn bomb(&mut self, _arg: &Bomb<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Poison'
    fn poison(&mut self, _arg: &Poison<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DeadlyPoison'
    fn deadly_poison(&mut self, _arg: &DeadlyPoison<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordChange'
    fn word_change(&mut self, _arg: &WordChange<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordDrop'
    fn word_drop(&mut self, _arg: &WordDrop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'From'
    fn from(&mut self, _arg: &From<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'To'
    fn to(&mut self, _arg: &To<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Camma'
    fn camma(&mut self, _arg: &Camma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Period'
    fn period(&mut self, _arg: &Period<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 9
///
/// Drop: Color DropOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropColorDropOpt<'t> {
    pub color: Box<Color<'t>>,
    pub drop_opt: Option<Box<DropOpt<'t>>>,
}

///
/// Type derived for production 10
///
/// Drop: NonColoredDrop DropOpt0 /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropNonColoredDropDropOpt0<'t> {
    pub non_colored_drop: Box<NonColoredDrop<'t>>,
    pub drop_opt0: Option<Box<DropOpt0<'t>>>,
}

///
/// Type derived for production 15
///
/// NonColoredDrop: Recovery;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropRecovery<'t> {
    pub recovery: Box<Recovery<'t>>,
}

///
/// Type derived for production 16
///
/// NonColoredDrop: Disturb;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropDisturb<'t> {
    pub disturb: Box<Disturb<'t>>,
}

///
/// Type derived for production 17
///
/// NonColoredDrop: Bomb;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropBomb<'t> {
    pub bomb: Box<Bomb<'t>>,
}

///
/// Type derived for production 18
///
/// NonColoredDrop: Poison;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropPoison<'t> {
    pub poison: Box<Poison<'t>>,
}

///
/// Type derived for production 19
///
/// NonColoredDrop: DeadlyPoison;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropDeadlyPoison<'t> {
    pub deadly_poison: Box<DeadlyPoison<'t>>,
}

///
/// Type derived for production 20
///
/// Color: Fire;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorFire<'t> {
    pub fire: Box<Fire<'t>>,
}

///
/// Type derived for production 21
///
/// Color: Water;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorWater<'t> {
    pub water: Box<Water<'t>>,
}

///
/// Type derived for production 22
///
/// Color: Wood;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorWood<'t> {
    pub wood: Box<Wood<'t>>,
}

///
/// Type derived for production 23
///
/// Color: Lightning;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorLightning<'t> {
    pub lightning: Box<Lightning<'t>>,
}

///
/// Type derived for production 24
///
/// Color: Dark;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorDark<'t> {
    pub dark: Box<Dark<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Bomb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Bomb<'t> {
    pub bomb: Token<'t>, /* 爆弾 */
}

///
/// Type derived for non-terminal Camma
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Camma<'t> {
    pub camma: Token<'t>, /* 、 */
}

///
/// Type derived for non-terminal ChangeDropBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropBlock<'t> {
    pub drops: Box<Drops<'t>>,
    pub from: Box<From<'t>>,
    pub drop: Box<Drop<'t>>,
    pub to: Box<To<'t>>,
}

///
/// Type derived for non-terminal ChangeDropStmt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropStmt<'t> {
    pub change_drop_block: Box<ChangeDropBlock<'t>>,
    pub change_drop_stmt_list: Vec<ChangeDropStmtList<'t>>,
    pub word_change: Box<WordChange<'t>>,
}

///
/// Type derived for non-terminal ChangeDropStmtList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropStmtList<'t> {
    pub camma: Box<Camma<'t>>,
    pub change_drop_block: Box<ChangeDropBlock<'t>>,
}

///
/// Type derived for non-terminal Color
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Color<'t> {
    Fire(ColorFire<'t>),
    Water(ColorWater<'t>),
    Wood(ColorWood<'t>),
    Lightning(ColorLightning<'t>),
    Dark(ColorDark<'t>),
}

///
/// Type derived for non-terminal Dark
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Dark<'t> {
    pub dark: Token<'t>, /* 闇 */
}

///
/// Type derived for non-terminal DeadlyPoison
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DeadlyPoison<'t> {
    pub deadly_poison: Token<'t>, /* 猛毒 */
}

///
/// Type derived for non-terminal Disturb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Disturb<'t> {
    pub disturb: Token<'t>, /* お邪魔 */
}

///
/// Type derived for non-terminal Drop
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Drop<'t> {
    ColorDropOpt(DropColorDropOpt<'t>),
    NonColoredDropDropOpt0(DropNonColoredDropDropOpt0<'t>),
}

///
/// Type derived for non-terminal DropOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropOpt<'t> {
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal DropOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropOpt0<'t> {
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal Drops
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Drops<'t> {
    pub drop: Box<Drop<'t>>,
    pub drops_list: Vec<DropsList<'t>>,
}

///
/// Type derived for non-terminal DropsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsList<'t> {
    pub camma: Box<Camma<'t>>,
    pub drop: Box<Drop<'t>>,
}

///
/// Type derived for non-terminal Fire
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Fire<'t> {
    pub fire: Token<'t>, /* 火 */
}

///
/// Type derived for non-terminal From
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct From<'t> {
    pub from: Token<'t>, /* を */
}

///
/// Type derived for non-terminal Lightning
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Lightning<'t> {
    pub lightning: Token<'t>, /* 光 */
}

///
/// Type derived for non-terminal Line
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Line<'t> {
    pub change_drop_stmt: Box<ChangeDropStmt<'t>>,
}

///
/// Type derived for non-terminal NonColoredDrop
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum NonColoredDrop<'t> {
    Recovery(NonColoredDropRecovery<'t>),
    Disturb(NonColoredDropDisturb<'t>),
    Bomb(NonColoredDropBomb<'t>),
    Poison(NonColoredDropPoison<'t>),
    DeadlyPoison(NonColoredDropDeadlyPoison<'t>),
}

///
/// Type derived for non-terminal Period
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Period<'t> {
    pub period: Token<'t>, /* 。 */
}

///
/// Type derived for non-terminal Poison
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Poison<'t> {
    pub poison: Token<'t>, /* 毒 */
}

///
/// Type derived for non-terminal Recovery
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Recovery<'t> {
    pub recovery: Token<'t>, /* 回復 */
}

///
/// Type derived for non-terminal SkillLines
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct SkillLines<'t> {
    pub line: Box<Line<'t>>,
    pub period: Box<Period<'t>>,
}

///
/// Type derived for non-terminal To
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct To<'t> {
    pub to: Token<'t>, /* に */
}

///
/// Type derived for non-terminal Water
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Water<'t> {
    pub water: Token<'t>, /* 水 */
}

///
/// Type derived for non-terminal Wood
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Wood<'t> {
    pub wood: Token<'t>, /* 木 */
}

///
/// Type derived for non-terminal WordChange
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordChange<'t> {
    pub word_change: Token<'t>, /* 変化 */
}

///
/// Type derived for non-terminal WordDrop
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordDrop<'t> {
    pub word_drop: Token<'t>, /* ドロップ */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Bomb(Bomb<'t>),
    Camma(Camma<'t>),
    ChangeDropBlock(ChangeDropBlock<'t>),
    ChangeDropStmt(ChangeDropStmt<'t>),
    ChangeDropStmtList(Vec<ChangeDropStmtList<'t>>),
    Color(Color<'t>),
    Dark(Dark<'t>),
    DeadlyPoison(DeadlyPoison<'t>),
    Disturb(Disturb<'t>),
    Drop(Drop<'t>),
    DropOpt(Option<Box<DropOpt<'t>>>),
    DropOpt0(Option<Box<DropOpt0<'t>>>),
    Drops(Drops<'t>),
    DropsList(Vec<DropsList<'t>>),
    Fire(Fire<'t>),
    From(From<'t>),
    Lightning(Lightning<'t>),
    Line(Line<'t>),
    NonColoredDrop(NonColoredDrop<'t>),
    Period(Period<'t>),
    Poison(Poison<'t>),
    Recovery(Recovery<'t>),
    SkillLines(SkillLines<'t>),
    To(To<'t>),
    Water(Water<'t>),
    Wood(Wood<'t>),
    WordChange(WordChange<'t>),
    WordDrop(WordDrop<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct SkillGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn SkillGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `SkillGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> SkillGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn SkillGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// SkillLines: Line Period;
    ///
    #[parol_runtime::function_name::named]
    fn skill_lines(
        &mut self,
        _line: &ParseTreeStackEntry<'t>,
        _period: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let period = pop_item!(self, period, Period, context);
        let line = pop_item!(self, line, Line, context);
        let skill_lines_built = SkillLinesBuilder::default()
            .line(Box::new(line))
            .period(Box::new(period))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.skill_lines(&skill_lines_built)?;
        self.push(ASTType::SkillLines(skill_lines_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Line: ChangeDropStmt;
    ///
    #[parol_runtime::function_name::named]
    fn line(
        &mut self,
        _change_drop_stmt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_stmt = pop_item!(self, change_drop_stmt, ChangeDropStmt, context);
        let line_built = LineBuilder::default()
            .change_drop_stmt(Box::new(change_drop_stmt))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line(&line_built)?;
        self.push(ASTType::Line(line_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// ChangeDropStmt: ChangeDropBlock ChangeDropStmtList /* Vec */ WordChange;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt(
        &mut self,
        _change_drop_block: &ParseTreeStackEntry<'t>,
        _change_drop_stmt_list: &ParseTreeStackEntry<'t>,
        _word_change: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_change = pop_item!(self, word_change, WordChange, context);
        let change_drop_stmt_list =
            pop_and_reverse_item!(self, change_drop_stmt_list, ChangeDropStmtList, context);
        let change_drop_block = pop_item!(self, change_drop_block, ChangeDropBlock, context);
        let change_drop_stmt_built = ChangeDropStmtBuilder::default()
            .change_drop_block(Box::new(change_drop_block))
            .change_drop_stmt_list(change_drop_stmt_list)
            .word_change(Box::new(word_change))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .change_drop_stmt(&change_drop_stmt_built)?;
        self.push(ASTType::ChangeDropStmt(change_drop_stmt_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// ChangeDropStmtList /* Vec<T>::Push */: Camma ChangeDropBlock ChangeDropStmtList;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt_list_0(
        &mut self,
        _camma: &ParseTreeStackEntry<'t>,
        _change_drop_block: &ParseTreeStackEntry<'t>,
        _change_drop_stmt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut change_drop_stmt_list =
            pop_item!(self, change_drop_stmt_list, ChangeDropStmtList, context);
        let change_drop_block = pop_item!(self, change_drop_block, ChangeDropBlock, context);
        let camma = pop_item!(self, camma, Camma, context);
        let change_drop_stmt_list_0_built = ChangeDropStmtListBuilder::default()
            .change_drop_block(Box::new(change_drop_block))
            .camma(Box::new(camma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        change_drop_stmt_list.push(change_drop_stmt_list_0_built);
        self.push(ASTType::ChangeDropStmtList(change_drop_stmt_list), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// ChangeDropStmtList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_stmt_list_1_built = Vec::new();
        self.push(
            ASTType::ChangeDropStmtList(change_drop_stmt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// ChangeDropBlock: Drops From Drop To;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_block(
        &mut self,
        _drops: &ParseTreeStackEntry<'t>,
        _from: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _to: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let to = pop_item!(self, to, To, context);
        let drop = pop_item!(self, drop, Drop, context);
        let from = pop_item!(self, from, From, context);
        let drops = pop_item!(self, drops, Drops, context);
        let change_drop_block_built = ChangeDropBlockBuilder::default()
            .drops(Box::new(drops))
            .from(Box::new(from))
            .drop(Box::new(drop))
            .to(Box::new(to))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .change_drop_block(&change_drop_block_built)?;
        self.push(ASTType::ChangeDropBlock(change_drop_block_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// Drops: Drop DropsList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn drops(
        &mut self,
        _drop: &ParseTreeStackEntry<'t>,
        _drops_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list = pop_and_reverse_item!(self, drops_list, DropsList, context);
        let drop = pop_item!(self, drop, Drop, context);
        let drops_built = DropsBuilder::default()
            .drop(Box::new(drop))
            .drops_list(drops_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.drops(&drops_built)?;
        self.push(ASTType::Drops(drops_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// DropsList /* Vec<T>::Push */: Camma Drop DropsList;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list_0(
        &mut self,
        _camma: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _drops_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut drops_list = pop_item!(self, drops_list, DropsList, context);
        let drop = pop_item!(self, drop, Drop, context);
        let camma = pop_item!(self, camma, Camma, context);
        let drops_list_0_built = DropsListBuilder::default()
            .drop(Box::new(drop))
            .camma(Box::new(camma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        drops_list.push(drops_list_0_built);
        self.push(ASTType::DropsList(drops_list), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// DropsList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list_1_built = Vec::new();
        self.push(ASTType::DropsList(drops_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// Drop: Color DropOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn drop_0(
        &mut self,
        _color: &ParseTreeStackEntry<'t>,
        _drop_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_opt = pop_item!(self, drop_opt, DropOpt, context);
        let color = pop_item!(self, color, Color, context);
        let drop_0_built = DropColorDropOptBuilder::default()
            .color(Box::new(color))
            .drop_opt(drop_opt)
            .build()
            .into_diagnostic()?;
        let drop_0_built = Drop::ColorDropOpt(drop_0_built);
        // Calling user action here
        self.user_grammar.drop(&drop_0_built)?;
        self.push(ASTType::Drop(drop_0_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// Drop: NonColoredDrop DropOpt0 /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn drop_1(
        &mut self,
        _non_colored_drop: &ParseTreeStackEntry<'t>,
        _drop_opt0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_opt0 = pop_item!(self, drop_opt0, DropOpt0, context);
        let non_colored_drop = pop_item!(self, non_colored_drop, NonColoredDrop, context);
        let drop_1_built = DropNonColoredDropDropOpt0Builder::default()
            .non_colored_drop(Box::new(non_colored_drop))
            .drop_opt0(drop_opt0)
            .build()
            .into_diagnostic()?;
        let drop_1_built = Drop::NonColoredDropDropOpt0(drop_1_built);
        // Calling user action here
        self.user_grammar.drop(&drop_1_built)?;
        self.push(ASTType::Drop(drop_1_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// DropOpt0 /* Option<T>::Some */: WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt0_0(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let drop_opt0_0_built = DropOpt0Builder::default()
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::DropOpt0(Some(Box::new(drop_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// DropOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// DropOpt /* Option<T>::Some */: WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt_0(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let drop_opt_0_built = DropOptBuilder::default()
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        self.push(ASTType::DropOpt(Some(Box::new(drop_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// DropOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// NonColoredDrop: Recovery;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_0(
        &mut self,
        _recovery: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let recovery = pop_item!(self, recovery, Recovery, context);
        let non_colored_drop_0_built = NonColoredDropRecoveryBuilder::default()
            .recovery(Box::new(recovery))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_0_built = NonColoredDrop::Recovery(non_colored_drop_0_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_0_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_0_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// NonColoredDrop: Disturb;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_1(
        &mut self,
        _disturb: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disturb = pop_item!(self, disturb, Disturb, context);
        let non_colored_drop_1_built = NonColoredDropDisturbBuilder::default()
            .disturb(Box::new(disturb))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_1_built = NonColoredDrop::Disturb(non_colored_drop_1_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_1_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_1_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// NonColoredDrop: Bomb;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_2(
        &mut self,
        _bomb: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bomb = pop_item!(self, bomb, Bomb, context);
        let non_colored_drop_2_built = NonColoredDropBombBuilder::default()
            .bomb(Box::new(bomb))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_2_built = NonColoredDrop::Bomb(non_colored_drop_2_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_2_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_2_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// NonColoredDrop: Poison;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_3(
        &mut self,
        _poison: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let poison = pop_item!(self, poison, Poison, context);
        let non_colored_drop_3_built = NonColoredDropPoisonBuilder::default()
            .poison(Box::new(poison))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_3_built = NonColoredDrop::Poison(non_colored_drop_3_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_3_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_3_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// NonColoredDrop: DeadlyPoison;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_4(
        &mut self,
        _deadly_poison: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let deadly_poison = pop_item!(self, deadly_poison, DeadlyPoison, context);
        let non_colored_drop_4_built = NonColoredDropDeadlyPoisonBuilder::default()
            .deadly_poison(Box::new(deadly_poison))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_4_built = NonColoredDrop::DeadlyPoison(non_colored_drop_4_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_4_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_4_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Color: Fire;
    ///
    #[parol_runtime::function_name::named]
    fn color_0(
        &mut self,
        _fire: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fire = pop_item!(self, fire, Fire, context);
        let color_0_built = ColorFireBuilder::default()
            .fire(Box::new(fire))
            .build()
            .into_diagnostic()?;
        let color_0_built = Color::Fire(color_0_built);
        // Calling user action here
        self.user_grammar.color(&color_0_built)?;
        self.push(ASTType::Color(color_0_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// Color: Water;
    ///
    #[parol_runtime::function_name::named]
    fn color_1(
        &mut self,
        _water: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let water = pop_item!(self, water, Water, context);
        let color_1_built = ColorWaterBuilder::default()
            .water(Box::new(water))
            .build()
            .into_diagnostic()?;
        let color_1_built = Color::Water(color_1_built);
        // Calling user action here
        self.user_grammar.color(&color_1_built)?;
        self.push(ASTType::Color(color_1_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// Color: Wood;
    ///
    #[parol_runtime::function_name::named]
    fn color_2(
        &mut self,
        _wood: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let wood = pop_item!(self, wood, Wood, context);
        let color_2_built = ColorWoodBuilder::default()
            .wood(Box::new(wood))
            .build()
            .into_diagnostic()?;
        let color_2_built = Color::Wood(color_2_built);
        // Calling user action here
        self.user_grammar.color(&color_2_built)?;
        self.push(ASTType::Color(color_2_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// Color: Lightning;
    ///
    #[parol_runtime::function_name::named]
    fn color_3(
        &mut self,
        _lightning: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lightning = pop_item!(self, lightning, Lightning, context);
        let color_3_built = ColorLightningBuilder::default()
            .lightning(Box::new(lightning))
            .build()
            .into_diagnostic()?;
        let color_3_built = Color::Lightning(color_3_built);
        // Calling user action here
        self.user_grammar.color(&color_3_built)?;
        self.push(ASTType::Color(color_3_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// Color: Dark;
    ///
    #[parol_runtime::function_name::named]
    fn color_4(
        &mut self,
        _dark: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dark = pop_item!(self, dark, Dark, context);
        let color_4_built = ColorDarkBuilder::default()
            .dark(Box::new(dark))
            .build()
            .into_diagnostic()?;
        let color_4_built = Color::Dark(color_4_built);
        // Calling user action here
        self.user_grammar.color(&color_4_built)?;
        self.push(ASTType::Color(color_4_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// Fire: "火";
    ///
    #[parol_runtime::function_name::named]
    fn fire(
        &mut self,
        fire: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fire = fire.token(parse_tree)?.clone();
        let fire_built = FireBuilder::default()
            .fire(fire)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.fire(&fire_built)?;
        self.push(ASTType::Fire(fire_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// Water: "水";
    ///
    #[parol_runtime::function_name::named]
    fn water(
        &mut self,
        water: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let water = water.token(parse_tree)?.clone();
        let water_built = WaterBuilder::default()
            .water(water)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.water(&water_built)?;
        self.push(ASTType::Water(water_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// Wood: "木";
    ///
    #[parol_runtime::function_name::named]
    fn wood(
        &mut self,
        wood: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let wood = wood.token(parse_tree)?.clone();
        let wood_built = WoodBuilder::default()
            .wood(wood)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.wood(&wood_built)?;
        self.push(ASTType::Wood(wood_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// Lightning: "光";
    ///
    #[parol_runtime::function_name::named]
    fn lightning(
        &mut self,
        lightning: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lightning = lightning.token(parse_tree)?.clone();
        let lightning_built = LightningBuilder::default()
            .lightning(lightning)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.lightning(&lightning_built)?;
        self.push(ASTType::Lightning(lightning_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// Dark: "闇";
    ///
    #[parol_runtime::function_name::named]
    fn dark(
        &mut self,
        dark: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dark = dark.token(parse_tree)?.clone();
        let dark_built = DarkBuilder::default()
            .dark(dark)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dark(&dark_built)?;
        self.push(ASTType::Dark(dark_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// Recovery: "回復";
    ///
    #[parol_runtime::function_name::named]
    fn recovery(
        &mut self,
        recovery: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let recovery = recovery.token(parse_tree)?.clone();
        let recovery_built = RecoveryBuilder::default()
            .recovery(recovery)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.recovery(&recovery_built)?;
        self.push(ASTType::Recovery(recovery_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// Disturb: "お邪魔";
    ///
    #[parol_runtime::function_name::named]
    fn disturb(
        &mut self,
        disturb: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disturb = disturb.token(parse_tree)?.clone();
        let disturb_built = DisturbBuilder::default()
            .disturb(disturb)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.disturb(&disturb_built)?;
        self.push(ASTType::Disturb(disturb_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// Bomb: "爆弾";
    ///
    #[parol_runtime::function_name::named]
    fn bomb(
        &mut self,
        bomb: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bomb = bomb.token(parse_tree)?.clone();
        let bomb_built = BombBuilder::default()
            .bomb(bomb)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bomb(&bomb_built)?;
        self.push(ASTType::Bomb(bomb_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// Poison: "毒";
    ///
    #[parol_runtime::function_name::named]
    fn poison(
        &mut self,
        poison: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let poison = poison.token(parse_tree)?.clone();
        let poison_built = PoisonBuilder::default()
            .poison(poison)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.poison(&poison_built)?;
        self.push(ASTType::Poison(poison_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// DeadlyPoison: "猛毒";
    ///
    #[parol_runtime::function_name::named]
    fn deadly_poison(
        &mut self,
        deadly_poison: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let deadly_poison = deadly_poison.token(parse_tree)?.clone();
        let deadly_poison_built = DeadlyPoisonBuilder::default()
            .deadly_poison(deadly_poison)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.deadly_poison(&deadly_poison_built)?;
        self.push(ASTType::DeadlyPoison(deadly_poison_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// WordChange: "変化";
    ///
    #[parol_runtime::function_name::named]
    fn word_change(
        &mut self,
        word_change: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_change = word_change.token(parse_tree)?.clone();
        let word_change_built = WordChangeBuilder::default()
            .word_change(word_change)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_change(&word_change_built)?;
        self.push(ASTType::WordChange(word_change_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// WordDrop: "ドロップ";
    ///
    #[parol_runtime::function_name::named]
    fn word_drop(
        &mut self,
        word_drop: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = word_drop.token(parse_tree)?.clone();
        let word_drop_built = WordDropBuilder::default()
            .word_drop(word_drop)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_drop(&word_drop_built)?;
        self.push(ASTType::WordDrop(word_drop_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// From: "を";
    ///
    #[parol_runtime::function_name::named]
    fn from(
        &mut self,
        from: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let from = from.token(parse_tree)?.clone();
        let from_built = FromBuilder::default()
            .from(from)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.from(&from_built)?;
        self.push(ASTType::From(from_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// To: "に";
    ///
    #[parol_runtime::function_name::named]
    fn to(
        &mut self,
        to: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let to = to.token(parse_tree)?.clone();
        let to_built = ToBuilder::default().to(to).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.to(&to_built)?;
        self.push(ASTType::To(to_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// Camma: "、";
    ///
    #[parol_runtime::function_name::named]
    fn camma(
        &mut self,
        camma: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let camma = camma.token(parse_tree)?.clone();
        let camma_built = CammaBuilder::default()
            .camma(camma)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.camma(&camma_built)?;
        self.push(ASTType::Camma(camma_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// Period: "。";
    ///
    #[parol_runtime::function_name::named]
    fn period(
        &mut self,
        period: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let period = period.token(parse_tree)?.clone();
        let period_built = PeriodBuilder::default()
            .period(period)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.period(&period_built)?;
        self.push(ASTType::Period(period_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for SkillGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item SkillGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.skill_lines(&children[0], &children[1], parse_tree),
            1 => self.line(&children[0], parse_tree),
            2 => self.change_drop_stmt(&children[0], &children[1], &children[2], parse_tree),
            3 => self.change_drop_stmt_list_0(&children[0], &children[1], &children[2], parse_tree),
            4 => self.change_drop_stmt_list_1(parse_tree),
            5 => self.change_drop_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            6 => self.drops(&children[0], &children[1], parse_tree),
            7 => self.drops_list_0(&children[0], &children[1], &children[2], parse_tree),
            8 => self.drops_list_1(parse_tree),
            9 => self.drop_0(&children[0], &children[1], parse_tree),
            10 => self.drop_1(&children[0], &children[1], parse_tree),
            11 => self.drop_opt0_0(&children[0], parse_tree),
            12 => self.drop_opt0_1(parse_tree),
            13 => self.drop_opt_0(&children[0], parse_tree),
            14 => self.drop_opt_1(parse_tree),
            15 => self.non_colored_drop_0(&children[0], parse_tree),
            16 => self.non_colored_drop_1(&children[0], parse_tree),
            17 => self.non_colored_drop_2(&children[0], parse_tree),
            18 => self.non_colored_drop_3(&children[0], parse_tree),
            19 => self.non_colored_drop_4(&children[0], parse_tree),
            20 => self.color_0(&children[0], parse_tree),
            21 => self.color_1(&children[0], parse_tree),
            22 => self.color_2(&children[0], parse_tree),
            23 => self.color_3(&children[0], parse_tree),
            24 => self.color_4(&children[0], parse_tree),
            25 => self.fire(&children[0], parse_tree),
            26 => self.water(&children[0], parse_tree),
            27 => self.wood(&children[0], parse_tree),
            28 => self.lightning(&children[0], parse_tree),
            29 => self.dark(&children[0], parse_tree),
            30 => self.recovery(&children[0], parse_tree),
            31 => self.disturb(&children[0], parse_tree),
            32 => self.bomb(&children[0], parse_tree),
            33 => self.poison(&children[0], parse_tree),
            34 => self.deadly_poison(&children[0], parse_tree),
            35 => self.word_change(&children[0], parse_tree),
            36 => self.word_drop(&children[0], parse_tree),
            37 => self.from(&children[0], parse_tree),
            38 => self.to(&children[0], parse_tree),
            39 => self.camma(&children[0], parse_tree),
            40 => self.period(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
