// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use derive_builder::Builder;
#[allow(unused_imports)]
use parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::id_tree::Tree;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait SkillGrammarTrait<'t> {
    /// Semantic action for non-terminal 'SkillLines'
    fn skill_lines(&mut self, _arg: &SkillLines<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Line'
    fn line(&mut self, _arg: &Line<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ChangeDropStmtIncGenRandomDrop'
    fn change_drop_stmt_inc_gen_random_drop(
        &mut self,
        _arg: &ChangeDropStmtIncGenRandomDrop<'t>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ChangeAllOfBoradStmt'
    fn change_all_of_borad_stmt(&mut self, _arg: &ChangeAllOfBoradStmt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DropRefreshStmt'
    fn drop_refresh_stmt(&mut self, _arg: &DropRefreshStmt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ChangeDropBlockOtherFirst'
    fn change_drop_block_other_first(
        &mut self,
        _arg: &ChangeDropBlockOtherFirst<'t>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenRandomDropStmt1'
    fn gen_random_drop_stmt1(&mut self, _arg: &GenRandomDropStmt1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Drops'
    fn drops(&mut self, _arg: &Drops<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ManyDrop'
    fn many_drop(&mut self, _arg: &ManyDrop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllDrops'
    fn all_drops(&mut self, _arg: &AllDrops<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FiveAttribute'
    fn five_attribute(&mut self, _arg: &FiveAttribute<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Quantity'
    fn quantity(&mut self, _arg: &Quantity<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Drop'
    fn drop(&mut self, _arg: &Drop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NonColoredDrop'
    fn non_colored_drop(&mut self, _arg: &NonColoredDrop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Color'
    fn color(&mut self, _arg: &Color<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RandomSuffix'
    fn random_suffix(&mut self, _arg: &RandomSuffix<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Fire'
    fn fire(&mut self, _arg: &Fire<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Water'
    fn water(&mut self, _arg: &Water<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Wood'
    fn wood(&mut self, _arg: &Wood<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Lightning'
    fn lightning(&mut self, _arg: &Lightning<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dark'
    fn dark(&mut self, _arg: &Dark<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Recovery'
    fn recovery(&mut self, _arg: &Recovery<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Disturb'
    fn disturb(&mut self, _arg: &Disturb<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bomb'
    fn bomb(&mut self, _arg: &Bomb<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DeadlyPoison'
    fn deadly_poison(&mut self, _arg: &DeadlyPoison<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Poison'
    fn poison(&mut self, _arg: &Poison<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordChange'
    fn word_change(&mut self, _arg: &WordChange<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordDrop'
    fn word_drop(&mut self, _arg: &WordDrop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordAll'
    fn word_all(&mut self, _arg: &WordAll<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordFiveAttribute'
    fn word_five_attribute(&mut self, _arg: &WordFiveAttribute<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordRandom'
    fn word_random(&mut self, _arg: &WordRandom<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordReplace'
    fn word_replace(&mut self, _arg: &WordReplace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordCount'
    fn word_count(&mut self, _arg: &WordCount<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordGen'
    fn word_gen(&mut self, _arg: &WordGen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordOther'
    fn word_other(&mut self, _arg: &WordOther<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Wo'
    fn wo(&mut self, _arg: &Wo<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ni'
    fn ni(&mut self, _arg: &Ni<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'So'
    fn so(&mut self, _arg: &So<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'And'
    fn and(&mut self, _arg: &And<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Each'
    fn each(&mut self, _arg: &Each<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'From'
    fn from(&mut self, _arg: &From<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Camma'
    fn camma(&mut self, _arg: &Camma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Period'
    fn period(&mut self, _arg: &Period<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PosInt'
    fn pos_int(&mut self, _arg: &PosInt<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 1
///
/// Line: ChangeDropStmtIncGenRandomDrop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct LineChangeDropStmtIncGenRandomDrop<'t> {
    pub change_drop_stmt_inc_gen_random_drop: Box<ChangeDropStmtIncGenRandomDrop<'t>>,
}

///
/// Type derived for production 2
///
/// Line: ChangeAllOfBoradStmt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct LineChangeAllOfBoradStmt<'t> {
    pub change_all_of_borad_stmt: Box<ChangeAllOfBoradStmt<'t>>,
}

///
/// Type derived for production 3
///
/// Line: GenRandomDropStmt1;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct LineGenRandomDropStmt1<'t> {
    pub gen_random_drop_stmt1: Box<GenRandomDropStmt1<'t>>,
}

///
/// Type derived for production 4
///
/// Line: DropRefreshStmt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct LineDropRefreshStmt<'t> {
    pub drop_refresh_stmt: Box<DropRefreshStmt<'t>>,
}

///
/// Type derived for production 6
///
/// ChangeDropStmtIncGenRandomDropSuffix0: Wo ChangeDropStmtIncGenRandomDropSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropStmtIncGenRandomDropSuffix0WoChangeDropStmtIncGenRandomDropSuffix<'t> {
    pub wo: Box<Wo<'t>>,
    pub change_drop_stmt_inc_gen_random_drop_suffix: Box<ChangeDropStmtIncGenRandomDropSuffix<'t>>,
}

///
/// Type derived for production 7
///
/// ChangeDropStmtIncGenRandomDropSuffix0: WordOther From Drops Wo Quantity WordGen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropStmtIncGenRandomDropSuffix0WordOtherFromDropsWoQuantityWordGen<'t> {
    pub word_other: Box<WordOther<'t>>,
    pub from: Box<From<'t>>,
    pub drops: Box<Drops<'t>>,
    pub wo: Box<Wo<'t>>,
    pub quantity: Box<Quantity<'t>>,
    pub word_gen: Box<WordGen<'t>>,
}

///
/// Type derived for production 8
///
/// ChangeDropStmtIncGenRandomDropSuffix: Drop Ni ChangeDropStmtIncGenRandomDropList /* Vec */ WordChange;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropStmtIncGenRandomDropSuffixDropNiChangeDropStmtIncGenRandomDropListWordChange<
    't,
> {
    pub drop: Box<Drop<'t>>,
    pub ni: Box<Ni<'t>>,
    pub change_drop_stmt_inc_gen_random_drop_list: Vec<ChangeDropStmtIncGenRandomDropList<'t>>,
    pub word_change: Box<WordChange<'t>>,
}

///
/// Type derived for production 9
///
/// ChangeDropStmtIncGenRandomDropSuffix: Quantity WordGen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropStmtIncGenRandomDropSuffixQuantityWordGen<'t> {
    pub quantity: Box<Quantity<'t>>,
    pub word_gen: Box<WordGen<'t>>,
}

///
/// Type derived for production 16
///
/// Drops: Drop DropsSuffix;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsDropDropsSuffix<'t> {
    pub drop: Box<Drop<'t>>,
    pub drops_suffix: Box<DropsSuffix<'t>>,
}

///
/// Type derived for production 17
///
/// DropsSuffix: DropsList /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsSuffixDropsList<'t> {
    pub drops_list: Vec<DropsList<'t>>,
}

///
/// Type derived for production 18
///
/// Drops: FiveAttribute DropsList0 /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsFiveAttributeDropsList0<'t> {
    pub five_attribute: Box<FiveAttribute<'t>>,
    pub drops_list0: Vec<DropsList0<'t>>,
}

///
/// Type derived for production 19
///
/// DropsSuffix: And Drop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsSuffixAndDrop<'t> {
    pub and: Box<And<'t>>,
    pub drop: Box<Drop<'t>>,
}

///
/// Type derived for production 24
///
/// ManyDrop: Camma Drop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ManyDropCammaDrop<'t> {
    pub camma: Box<Camma<'t>>,
    pub drop: Box<Drop<'t>>,
}

///
/// Type derived for production 25
///
/// ManyDrop: Plus Drop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ManyDropPlusDrop<'t> {
    pub plus: Box<Plus<'t>>,
    pub drop: Box<Drop<'t>>,
}

///
/// Type derived for production 33
///
/// Drop: Color DropOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropColorDropOpt<'t> {
    pub color: Box<Color<'t>>,
    pub drop_opt: Option<Box<DropOpt<'t>>>,
}

///
/// Type derived for production 34
///
/// Drop: NonColoredDrop DropOpt0 /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropNonColoredDropDropOpt0<'t> {
    pub non_colored_drop: Box<NonColoredDrop<'t>>,
    pub drop_opt0: Option<Box<DropOpt0<'t>>>,
}

///
/// Type derived for production 39
///
/// NonColoredDrop: Recovery;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropRecovery<'t> {
    pub recovery: Box<Recovery<'t>>,
}

///
/// Type derived for production 40
///
/// NonColoredDrop: Disturb;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropDisturb<'t> {
    pub disturb: Box<Disturb<'t>>,
}

///
/// Type derived for production 41
///
/// NonColoredDrop: Bomb;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropBomb<'t> {
    pub bomb: Box<Bomb<'t>>,
}

///
/// Type derived for production 42
///
/// NonColoredDrop: Poison;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropPoison<'t> {
    pub poison: Box<Poison<'t>>,
}

///
/// Type derived for production 43
///
/// NonColoredDrop: DeadlyPoison;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropDeadlyPoison<'t> {
    pub deadly_poison: Box<DeadlyPoison<'t>>,
}

///
/// Type derived for production 44
///
/// Color: Fire;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorFire<'t> {
    pub fire: Box<Fire<'t>>,
}

///
/// Type derived for production 45
///
/// Color: Water;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorWater<'t> {
    pub water: Box<Water<'t>>,
}

///
/// Type derived for production 46
///
/// Color: Wood;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorWood<'t> {
    pub wood: Box<Wood<'t>>,
}

///
/// Type derived for production 47
///
/// Color: Lightning;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorLightning<'t> {
    pub lightning: Box<Lightning<'t>>,
}

///
/// Type derived for production 48
///
/// Color: Dark;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorDark<'t> {
    pub dark: Box<Dark<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AllDrops
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct AllDrops<'t> {
    pub word_all: Box<WordAll<'t>>,
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal And
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct And<'t> {
    pub and: Token<'t>, /* と */
}

///
/// Type derived for non-terminal Bomb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Bomb<'t> {
    pub bomb: Token<'t>, /* 爆弾 */
}

///
/// Type derived for non-terminal Camma
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Camma<'t> {
    pub camma: Token<'t>, /* 、 */
}

///
/// Type derived for non-terminal ChangeAllOfBoradStmt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeAllOfBoradStmt<'t> {
    pub all_drops: Box<AllDrops<'t>>,
    pub wo: Box<Wo<'t>>,
    pub drops: Box<Drops<'t>>,
    pub ni: Box<Ni<'t>>,
    pub word_change: Box<WordChange<'t>>,
}

///
/// Type derived for non-terminal ChangeDropBlockOtherFirst
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropBlockOtherFirst<'t> {
    pub drops: Box<Drops<'t>>,
    pub wo: Box<Wo<'t>>,
    pub drop: Box<Drop<'t>>,
    pub ni: Box<Ni<'t>>,
}

///
/// Type derived for non-terminal ChangeDropStmtIncGenRandomDrop
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropStmtIncGenRandomDrop<'t> {
    pub drops: Box<Drops<'t>>,
    pub change_drop_stmt_inc_gen_random_drop_suffix0:
        Box<ChangeDropStmtIncGenRandomDropSuffix0<'t>>,
}

///
/// Type derived for non-terminal ChangeDropStmtIncGenRandomDropList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropStmtIncGenRandomDropList<'t> {
    pub camma: Box<Camma<'t>>,
    pub change_drop_block_other_first: Box<ChangeDropBlockOtherFirst<'t>>,
}

///
/// Type derived for non-terminal ChangeDropStmtIncGenRandomDropSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ChangeDropStmtIncGenRandomDropSuffix<'t> {
    DropNiChangeDropStmtIncGenRandomDropListWordChange(
        ChangeDropStmtIncGenRandomDropSuffixDropNiChangeDropStmtIncGenRandomDropListWordChange<'t>,
    ),
    QuantityWordGen(ChangeDropStmtIncGenRandomDropSuffixQuantityWordGen<'t>),
}

///
/// Type derived for non-terminal ChangeDropStmtIncGenRandomDropSuffix0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ChangeDropStmtIncGenRandomDropSuffix0<'t> {
    WoChangeDropStmtIncGenRandomDropSuffix(
        ChangeDropStmtIncGenRandomDropSuffix0WoChangeDropStmtIncGenRandomDropSuffix<'t>,
    ),
    WordOtherFromDropsWoQuantityWordGen(
        ChangeDropStmtIncGenRandomDropSuffix0WordOtherFromDropsWoQuantityWordGen<'t>,
    ),
}

///
/// Type derived for non-terminal Color
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Color<'t> {
    Fire(ColorFire<'t>),
    Water(ColorWater<'t>),
    Wood(ColorWood<'t>),
    Lightning(ColorLightning<'t>),
    Dark(ColorDark<'t>),
}

///
/// Type derived for non-terminal Dark
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Dark<'t> {
    pub dark: Token<'t>, /* 闇 */
}

///
/// Type derived for non-terminal DeadlyPoison
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DeadlyPoison<'t> {
    pub deadly_poison: Token<'t>, /* 猛毒 */
}

///
/// Type derived for non-terminal Disturb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Disturb<'t> {
    pub disturb: Token<'t>, /* お邪魔 */
}

///
/// Type derived for non-terminal Drop
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Drop<'t> {
    ColorDropOpt(DropColorDropOpt<'t>),
    NonColoredDropDropOpt0(DropNonColoredDropDropOpt0<'t>),
}

///
/// Type derived for non-terminal DropOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropOpt<'t> {
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal DropOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropOpt0<'t> {
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal DropRefreshStmt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropRefreshStmt<'t> {
    pub random_suffix: Box<RandomSuffix<'t>>,
    pub word_drop: Box<WordDrop<'t>>,
    pub wo: Box<Wo<'t>>,
    pub word_replace: Box<WordReplace<'t>>,
}

///
/// Type derived for non-terminal Drops
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Drops<'t> {
    DropDropsSuffix(DropsDropDropsSuffix<'t>),
    FiveAttributeDropsList0(DropsFiveAttributeDropsList0<'t>),
}

///
/// Type derived for non-terminal DropsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsList<'t> {
    pub many_drop: Box<ManyDrop<'t>>,
}

///
/// Type derived for non-terminal DropsList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsList0<'t> {
    pub plus: Box<Plus<'t>>,
    pub drop: Box<Drop<'t>>,
}

///
/// Type derived for non-terminal DropsSuffix
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DropsSuffix<'t> {
    DropsList(DropsSuffixDropsList<'t>),
    AndDrop(DropsSuffixAndDrop<'t>),
}

///
/// Type derived for non-terminal Each
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Each<'t> {
    pub each: Token<'t>, /* ずつ */
}

///
/// Type derived for non-terminal Fire
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Fire<'t> {
    pub fire: Token<'t>, /* 火 */
}

///
/// Type derived for non-terminal FiveAttribute
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct FiveAttribute<'t> {
    pub word_five_attribute: Box<WordFiveAttribute<'t>>,
    pub five_attribute_opt: Option<Box<FiveAttributeOpt<'t>>>,
}

///
/// Type derived for non-terminal FiveAttributeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct FiveAttributeOpt<'t> {
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal From
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct From<'t> {
    pub from: Token<'t>, /* から */
}

///
/// Type derived for non-terminal GenRandomDropStmt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct GenRandomDropStmt1<'t> {
    pub random_suffix: Box<RandomSuffix<'t>>,
    pub drops: Box<Drops<'t>>,
    pub wo: Box<Wo<'t>>,
    pub quantity: Box<Quantity<'t>>,
    pub word_gen: Box<WordGen<'t>>,
}

///
/// Type derived for non-terminal Lightning
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Lightning<'t> {
    pub lightning: Token<'t>, /* 光 */
}

///
/// Type derived for non-terminal Line
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Line<'t> {
    ChangeDropStmtIncGenRandomDrop(LineChangeDropStmtIncGenRandomDrop<'t>),
    ChangeAllOfBoradStmt(LineChangeAllOfBoradStmt<'t>),
    GenRandomDropStmt1(LineGenRandomDropStmt1<'t>),
    DropRefreshStmt(LineDropRefreshStmt<'t>),
}

///
/// Type derived for non-terminal ManyDrop
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ManyDrop<'t> {
    CammaDrop(ManyDropCammaDrop<'t>),
    PlusDrop(ManyDropPlusDrop<'t>),
}

///
/// Type derived for non-terminal Ni
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Ni<'t> {
    pub ni: Token<'t>, /* に */
}

///
/// Type derived for non-terminal NonColoredDrop
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum NonColoredDrop<'t> {
    Recovery(NonColoredDropRecovery<'t>),
    Disturb(NonColoredDropDisturb<'t>),
    Bomb(NonColoredDropBomb<'t>),
    Poison(NonColoredDropPoison<'t>),
    DeadlyPoison(NonColoredDropDeadlyPoison<'t>),
}

///
/// Type derived for non-terminal Period
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Period<'t> {
    pub period: Token<'t>, /* 。 */
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Plus<'t> {
    pub plus: Token<'t>, /* + */
}

///
/// Type derived for non-terminal Poison
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Poison<'t> {
    pub poison: Token<'t>, /* 毒 */
}

///
/// Type derived for non-terminal PosInt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct PosInt<'t> {
    pub pos_int: Token<'t>, /* [1-9]([0-9])* */
}

///
/// Type derived for non-terminal Quantity
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Quantity<'t> {
    pub pos_int: Box<PosInt<'t>>,
    pub word_count: Box<WordCount<'t>>,
    pub quantity_opt: Option<Box<QuantityOpt<'t>>>,
}

///
/// Type derived for non-terminal QuantityOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct QuantityOpt<'t> {
    pub each: Box<Each<'t>>,
}

///
/// Type derived for non-terminal RandomSuffix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct RandomSuffix<'t> {
    pub word_random: Box<WordRandom<'t>>,
    pub so: Box<So<'t>>,
}

///
/// Type derived for non-terminal Recovery
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Recovery<'t> {
    pub recovery: Token<'t>, /* 回復 */
}

///
/// Type derived for non-terminal SkillLines
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct SkillLines<'t> {
    pub line: Box<Line<'t>>,
    pub period: Box<Period<'t>>,
}

///
/// Type derived for non-terminal So
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct So<'t> {
    pub so: Token<'t>, /* で */
}

///
/// Type derived for non-terminal Water
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Water<'t> {
    pub water: Token<'t>, /* 水 */
}

///
/// Type derived for non-terminal Wo
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Wo<'t> {
    pub wo: Token<'t>, /* を */
}

///
/// Type derived for non-terminal Wood
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Wood<'t> {
    pub wood: Token<'t>, /* 木 */
}

///
/// Type derived for non-terminal WordAll
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordAll<'t> {
    pub word_all: Token<'t>, /* 全 */
}

///
/// Type derived for non-terminal WordChange
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordChange<'t> {
    pub word_change: Token<'t>, /* 変化 */
}

///
/// Type derived for non-terminal WordCount
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordCount<'t> {
    pub word_count: Token<'t>, /* 個 */
}

///
/// Type derived for non-terminal WordDrop
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordDrop<'t> {
    pub word_drop: Token<'t>, /* ドロップ */
}

///
/// Type derived for non-terminal WordFiveAttribute
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordFiveAttribute<'t> {
    pub word_five_attribute: Token<'t>, /* 5属性 */
}

///
/// Type derived for non-terminal WordGen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordGen<'t> {
    pub word_gen: Token<'t>, /* 生成 */
}

///
/// Type derived for non-terminal WordOther
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordOther<'t> {
    pub word_other: Token<'t>, /* 以外 */
}

///
/// Type derived for non-terminal WordRandom
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordRandom<'t> {
    pub word_random: Token<'t>, /* ランダム */
}

///
/// Type derived for non-terminal WordReplace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordReplace<'t> {
    pub word_replace: Token<'t>, /* 入れ替える */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AllDrops(AllDrops<'t>),
    And(And<'t>),
    Bomb(Bomb<'t>),
    Camma(Camma<'t>),
    ChangeAllOfBoradStmt(ChangeAllOfBoradStmt<'t>),
    ChangeDropBlockOtherFirst(ChangeDropBlockOtherFirst<'t>),
    ChangeDropStmtIncGenRandomDrop(ChangeDropStmtIncGenRandomDrop<'t>),
    ChangeDropStmtIncGenRandomDropList(Vec<ChangeDropStmtIncGenRandomDropList<'t>>),
    ChangeDropStmtIncGenRandomDropSuffix(ChangeDropStmtIncGenRandomDropSuffix<'t>),
    ChangeDropStmtIncGenRandomDropSuffix0(ChangeDropStmtIncGenRandomDropSuffix0<'t>),
    Color(Color<'t>),
    Dark(Dark<'t>),
    DeadlyPoison(DeadlyPoison<'t>),
    Disturb(Disturb<'t>),
    Drop(Drop<'t>),
    DropOpt(Option<Box<DropOpt<'t>>>),
    DropOpt0(Option<Box<DropOpt0<'t>>>),
    DropRefreshStmt(DropRefreshStmt<'t>),
    Drops(Drops<'t>),
    DropsList(Vec<DropsList<'t>>),
    DropsList0(Vec<DropsList0<'t>>),
    DropsSuffix(DropsSuffix<'t>),
    Each(Each<'t>),
    Fire(Fire<'t>),
    FiveAttribute(FiveAttribute<'t>),
    FiveAttributeOpt(Option<Box<FiveAttributeOpt<'t>>>),
    From(From<'t>),
    GenRandomDropStmt1(GenRandomDropStmt1<'t>),
    Lightning(Lightning<'t>),
    Line(Line<'t>),
    ManyDrop(ManyDrop<'t>),
    Ni(Ni<'t>),
    NonColoredDrop(NonColoredDrop<'t>),
    Period(Period<'t>),
    Plus(Plus<'t>),
    Poison(Poison<'t>),
    PosInt(PosInt<'t>),
    Quantity(Quantity<'t>),
    QuantityOpt(Option<Box<QuantityOpt<'t>>>),
    RandomSuffix(RandomSuffix<'t>),
    Recovery(Recovery<'t>),
    SkillLines(SkillLines<'t>),
    So(So<'t>),
    Water(Water<'t>),
    Wo(Wo<'t>),
    Wood(Wood<'t>),
    WordAll(WordAll<'t>),
    WordChange(WordChange<'t>),
    WordCount(WordCount<'t>),
    WordDrop(WordDrop<'t>),
    WordFiveAttribute(WordFiveAttribute<'t>),
    WordGen(WordGen<'t>),
    WordOther(WordOther<'t>),
    WordRandom(WordRandom<'t>),
    WordReplace(WordReplace<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct SkillGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn SkillGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `SkillGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> SkillGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn SkillGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// SkillLines: Line Period;
    ///
    #[parol_runtime::function_name::named]
    fn skill_lines(
        &mut self,
        _line: &ParseTreeStackEntry<'t>,
        _period: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let period = pop_item!(self, period, Period, context);
        let line = pop_item!(self, line, Line, context);
        let skill_lines_built = SkillLinesBuilder::default()
            .line(Box::new(line))
            .period(Box::new(period))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.skill_lines(&skill_lines_built)?;
        self.push(ASTType::SkillLines(skill_lines_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Line: ChangeDropStmtIncGenRandomDrop;
    ///
    #[parol_runtime::function_name::named]
    fn line_0(
        &mut self,
        _change_drop_stmt_inc_gen_random_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_stmt_inc_gen_random_drop = pop_item!(
            self,
            change_drop_stmt_inc_gen_random_drop,
            ChangeDropStmtIncGenRandomDrop,
            context
        );
        let line_0_built = LineChangeDropStmtIncGenRandomDropBuilder::default()
            .change_drop_stmt_inc_gen_random_drop(Box::new(change_drop_stmt_inc_gen_random_drop))
            .build()
            .into_diagnostic()?;
        let line_0_built = Line::ChangeDropStmtIncGenRandomDrop(line_0_built);
        // Calling user action here
        self.user_grammar.line(&line_0_built)?;
        self.push(ASTType::Line(line_0_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// Line: ChangeAllOfBoradStmt;
    ///
    #[parol_runtime::function_name::named]
    fn line_1(
        &mut self,
        _change_all_of_borad_stmt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_all_of_borad_stmt = pop_item!(
            self,
            change_all_of_borad_stmt,
            ChangeAllOfBoradStmt,
            context
        );
        let line_1_built = LineChangeAllOfBoradStmtBuilder::default()
            .change_all_of_borad_stmt(Box::new(change_all_of_borad_stmt))
            .build()
            .into_diagnostic()?;
        let line_1_built = Line::ChangeAllOfBoradStmt(line_1_built);
        // Calling user action here
        self.user_grammar.line(&line_1_built)?;
        self.push(ASTType::Line(line_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// Line: GenRandomDropStmt1;
    ///
    #[parol_runtime::function_name::named]
    fn line_2(
        &mut self,
        _gen_random_drop_stmt1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gen_random_drop_stmt1 =
            pop_item!(self, gen_random_drop_stmt1, GenRandomDropStmt1, context);
        let line_2_built = LineGenRandomDropStmt1Builder::default()
            .gen_random_drop_stmt1(Box::new(gen_random_drop_stmt1))
            .build()
            .into_diagnostic()?;
        let line_2_built = Line::GenRandomDropStmt1(line_2_built);
        // Calling user action here
        self.user_grammar.line(&line_2_built)?;
        self.push(ASTType::Line(line_2_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// Line: DropRefreshStmt;
    ///
    #[parol_runtime::function_name::named]
    fn line_3(
        &mut self,
        _drop_refresh_stmt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_refresh_stmt = pop_item!(self, drop_refresh_stmt, DropRefreshStmt, context);
        let line_3_built = LineDropRefreshStmtBuilder::default()
            .drop_refresh_stmt(Box::new(drop_refresh_stmt))
            .build()
            .into_diagnostic()?;
        let line_3_built = Line::DropRefreshStmt(line_3_built);
        // Calling user action here
        self.user_grammar.line(&line_3_built)?;
        self.push(ASTType::Line(line_3_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// ChangeDropStmtIncGenRandomDrop: Drops ChangeDropStmtIncGenRandomDropSuffix0;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt_inc_gen_random_drop(
        &mut self,
        _drops: &ParseTreeStackEntry<'t>,
        _change_drop_stmt_inc_gen_random_drop_suffix0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_stmt_inc_gen_random_drop_suffix0 = pop_item!(
            self,
            change_drop_stmt_inc_gen_random_drop_suffix0,
            ChangeDropStmtIncGenRandomDropSuffix0,
            context
        );
        let drops = pop_item!(self, drops, Drops, context);
        let change_drop_stmt_inc_gen_random_drop_built =
            ChangeDropStmtIncGenRandomDropBuilder::default()
                .drops(Box::new(drops))
                .change_drop_stmt_inc_gen_random_drop_suffix0(Box::new(
                    change_drop_stmt_inc_gen_random_drop_suffix0,
                ))
                .build()
                .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .change_drop_stmt_inc_gen_random_drop(&change_drop_stmt_inc_gen_random_drop_built)?;
        self.push(
            ASTType::ChangeDropStmtIncGenRandomDrop(change_drop_stmt_inc_gen_random_drop_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// ChangeDropStmtIncGenRandomDropSuffix0: Wo ChangeDropStmtIncGenRandomDropSuffix;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt_inc_gen_random_drop_suffix0_0(
        &mut self,
        _wo: &ParseTreeStackEntry<'t>,
        _change_drop_stmt_inc_gen_random_drop_suffix: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_stmt_inc_gen_random_drop_suffix = pop_item!(
            self,
            change_drop_stmt_inc_gen_random_drop_suffix,
            ChangeDropStmtIncGenRandomDropSuffix,
            context
        );
        let wo = pop_item!(self, wo, Wo, context);
        let change_drop_stmt_inc_gen_random_drop_suffix0_0_built = ChangeDropStmtIncGenRandomDropSuffix0WoChangeDropStmtIncGenRandomDropSuffixBuilder::default()
            .wo(Box::new(wo))
            .change_drop_stmt_inc_gen_random_drop_suffix(Box::new(change_drop_stmt_inc_gen_random_drop_suffix))
            .build()
            .into_diagnostic()?;
        let change_drop_stmt_inc_gen_random_drop_suffix0_0_built =
            ChangeDropStmtIncGenRandomDropSuffix0::WoChangeDropStmtIncGenRandomDropSuffix(
                change_drop_stmt_inc_gen_random_drop_suffix0_0_built,
            );
        self.push(
            ASTType::ChangeDropStmtIncGenRandomDropSuffix0(
                change_drop_stmt_inc_gen_random_drop_suffix0_0_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// ChangeDropStmtIncGenRandomDropSuffix0: WordOther From Drops Wo Quantity WordGen;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt_inc_gen_random_drop_suffix0_1(
        &mut self,
        _word_other: &ParseTreeStackEntry<'t>,
        _from: &ParseTreeStackEntry<'t>,
        _drops: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _quantity: &ParseTreeStackEntry<'t>,
        _word_gen: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_gen = pop_item!(self, word_gen, WordGen, context);
        let quantity = pop_item!(self, quantity, Quantity, context);
        let wo = pop_item!(self, wo, Wo, context);
        let drops = pop_item!(self, drops, Drops, context);
        let from = pop_item!(self, from, From, context);
        let word_other = pop_item!(self, word_other, WordOther, context);
        let change_drop_stmt_inc_gen_random_drop_suffix0_1_built = ChangeDropStmtIncGenRandomDropSuffix0WordOtherFromDropsWoQuantityWordGenBuilder::default()
            .word_other(Box::new(word_other))
            .from(Box::new(from))
            .drops(Box::new(drops))
            .wo(Box::new(wo))
            .quantity(Box::new(quantity))
            .word_gen(Box::new(word_gen))
            .build()
            .into_diagnostic()?;
        let change_drop_stmt_inc_gen_random_drop_suffix0_1_built =
            ChangeDropStmtIncGenRandomDropSuffix0::WordOtherFromDropsWoQuantityWordGen(
                change_drop_stmt_inc_gen_random_drop_suffix0_1_built,
            );
        self.push(
            ASTType::ChangeDropStmtIncGenRandomDropSuffix0(
                change_drop_stmt_inc_gen_random_drop_suffix0_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// ChangeDropStmtIncGenRandomDropSuffix: Drop Ni ChangeDropStmtIncGenRandomDropList /* Vec */ WordChange;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt_inc_gen_random_drop_suffix_0(
        &mut self,
        _drop: &ParseTreeStackEntry<'t>,
        _ni: &ParseTreeStackEntry<'t>,
        _change_drop_stmt_inc_gen_random_drop_list: &ParseTreeStackEntry<'t>,
        _word_change: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_change = pop_item!(self, word_change, WordChange, context);
        let change_drop_stmt_inc_gen_random_drop_list = pop_and_reverse_item!(
            self,
            change_drop_stmt_inc_gen_random_drop_list,
            ChangeDropStmtIncGenRandomDropList,
            context
        );
        let ni = pop_item!(self, ni, Ni, context);
        let drop = pop_item!(self, drop, Drop, context);
        let change_drop_stmt_inc_gen_random_drop_suffix_0_built = ChangeDropStmtIncGenRandomDropSuffixDropNiChangeDropStmtIncGenRandomDropListWordChangeBuilder::default()
            .drop(Box::new(drop))
            .ni(Box::new(ni))
            .change_drop_stmt_inc_gen_random_drop_list(change_drop_stmt_inc_gen_random_drop_list)
            .word_change(Box::new(word_change))
            .build()
            .into_diagnostic()?;
        let change_drop_stmt_inc_gen_random_drop_suffix_0_built = ChangeDropStmtIncGenRandomDropSuffix::DropNiChangeDropStmtIncGenRandomDropListWordChange(change_drop_stmt_inc_gen_random_drop_suffix_0_built);
        self.push(
            ASTType::ChangeDropStmtIncGenRandomDropSuffix(
                change_drop_stmt_inc_gen_random_drop_suffix_0_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// ChangeDropStmtIncGenRandomDropSuffix: Quantity WordGen;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt_inc_gen_random_drop_suffix_1(
        &mut self,
        _quantity: &ParseTreeStackEntry<'t>,
        _word_gen: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_gen = pop_item!(self, word_gen, WordGen, context);
        let quantity = pop_item!(self, quantity, Quantity, context);
        let change_drop_stmt_inc_gen_random_drop_suffix_1_built =
            ChangeDropStmtIncGenRandomDropSuffixQuantityWordGenBuilder::default()
                .quantity(Box::new(quantity))
                .word_gen(Box::new(word_gen))
                .build()
                .into_diagnostic()?;
        let change_drop_stmt_inc_gen_random_drop_suffix_1_built =
            ChangeDropStmtIncGenRandomDropSuffix::QuantityWordGen(
                change_drop_stmt_inc_gen_random_drop_suffix_1_built,
            );
        self.push(
            ASTType::ChangeDropStmtIncGenRandomDropSuffix(
                change_drop_stmt_inc_gen_random_drop_suffix_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// ChangeDropStmtIncGenRandomDropList /* Vec<T>::Push */: Camma ChangeDropBlockOtherFirst ChangeDropStmtIncGenRandomDropList;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt_inc_gen_random_drop_list_0(
        &mut self,
        _camma: &ParseTreeStackEntry<'t>,
        _change_drop_block_other_first: &ParseTreeStackEntry<'t>,
        _change_drop_stmt_inc_gen_random_drop_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut change_drop_stmt_inc_gen_random_drop_list = pop_item!(
            self,
            change_drop_stmt_inc_gen_random_drop_list,
            ChangeDropStmtIncGenRandomDropList,
            context
        );
        let change_drop_block_other_first = pop_item!(
            self,
            change_drop_block_other_first,
            ChangeDropBlockOtherFirst,
            context
        );
        let camma = pop_item!(self, camma, Camma, context);
        let change_drop_stmt_inc_gen_random_drop_list_0_built =
            ChangeDropStmtIncGenRandomDropListBuilder::default()
                .change_drop_block_other_first(Box::new(change_drop_block_other_first))
                .camma(Box::new(camma))
                .build()
                .into_diagnostic()?;
        // Add an element to the vector
        change_drop_stmt_inc_gen_random_drop_list
            .push(change_drop_stmt_inc_gen_random_drop_list_0_built);
        self.push(
            ASTType::ChangeDropStmtIncGenRandomDropList(change_drop_stmt_inc_gen_random_drop_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// ChangeDropStmtIncGenRandomDropList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt_inc_gen_random_drop_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_stmt_inc_gen_random_drop_list_1_built = Vec::new();
        self.push(
            ASTType::ChangeDropStmtIncGenRandomDropList(
                change_drop_stmt_inc_gen_random_drop_list_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// ChangeAllOfBoradStmt: AllDrops Wo Drops Ni WordChange;
    ///
    #[parol_runtime::function_name::named]
    fn change_all_of_borad_stmt(
        &mut self,
        _all_drops: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _drops: &ParseTreeStackEntry<'t>,
        _ni: &ParseTreeStackEntry<'t>,
        _word_change: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_change = pop_item!(self, word_change, WordChange, context);
        let ni = pop_item!(self, ni, Ni, context);
        let drops = pop_item!(self, drops, Drops, context);
        let wo = pop_item!(self, wo, Wo, context);
        let all_drops = pop_item!(self, all_drops, AllDrops, context);
        let change_all_of_borad_stmt_built = ChangeAllOfBoradStmtBuilder::default()
            .all_drops(Box::new(all_drops))
            .wo(Box::new(wo))
            .drops(Box::new(drops))
            .ni(Box::new(ni))
            .word_change(Box::new(word_change))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .change_all_of_borad_stmt(&change_all_of_borad_stmt_built)?;
        self.push(
            ASTType::ChangeAllOfBoradStmt(change_all_of_borad_stmt_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// DropRefreshStmt: RandomSuffix WordDrop Wo WordReplace;
    ///
    #[parol_runtime::function_name::named]
    fn drop_refresh_stmt(
        &mut self,
        _random_suffix: &ParseTreeStackEntry<'t>,
        _word_drop: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _word_replace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_replace = pop_item!(self, word_replace, WordReplace, context);
        let wo = pop_item!(self, wo, Wo, context);
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let random_suffix = pop_item!(self, random_suffix, RandomSuffix, context);
        let drop_refresh_stmt_built = DropRefreshStmtBuilder::default()
            .random_suffix(Box::new(random_suffix))
            .word_drop(Box::new(word_drop))
            .wo(Box::new(wo))
            .word_replace(Box::new(word_replace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .drop_refresh_stmt(&drop_refresh_stmt_built)?;
        self.push(ASTType::DropRefreshStmt(drop_refresh_stmt_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// ChangeDropBlockOtherFirst: Drops Wo Drop Ni;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_block_other_first(
        &mut self,
        _drops: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _ni: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ni = pop_item!(self, ni, Ni, context);
        let drop = pop_item!(self, drop, Drop, context);
        let wo = pop_item!(self, wo, Wo, context);
        let drops = pop_item!(self, drops, Drops, context);
        let change_drop_block_other_first_built = ChangeDropBlockOtherFirstBuilder::default()
            .drops(Box::new(drops))
            .wo(Box::new(wo))
            .drop(Box::new(drop))
            .ni(Box::new(ni))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .change_drop_block_other_first(&change_drop_block_other_first_built)?;
        self.push(
            ASTType::ChangeDropBlockOtherFirst(change_drop_block_other_first_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// GenRandomDropStmt1: RandomSuffix Drops Wo Quantity WordGen;
    ///
    #[parol_runtime::function_name::named]
    fn gen_random_drop_stmt1(
        &mut self,
        _random_suffix: &ParseTreeStackEntry<'t>,
        _drops: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _quantity: &ParseTreeStackEntry<'t>,
        _word_gen: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_gen = pop_item!(self, word_gen, WordGen, context);
        let quantity = pop_item!(self, quantity, Quantity, context);
        let wo = pop_item!(self, wo, Wo, context);
        let drops = pop_item!(self, drops, Drops, context);
        let random_suffix = pop_item!(self, random_suffix, RandomSuffix, context);
        let gen_random_drop_stmt1_built = GenRandomDropStmt1Builder::default()
            .random_suffix(Box::new(random_suffix))
            .drops(Box::new(drops))
            .wo(Box::new(wo))
            .quantity(Box::new(quantity))
            .word_gen(Box::new(word_gen))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .gen_random_drop_stmt1(&gen_random_drop_stmt1_built)?;
        self.push(
            ASTType::GenRandomDropStmt1(gen_random_drop_stmt1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Drops: Drop DropsSuffix;
    ///
    #[parol_runtime::function_name::named]
    fn drops_0(
        &mut self,
        _drop: &ParseTreeStackEntry<'t>,
        _drops_suffix: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_suffix = pop_item!(self, drops_suffix, DropsSuffix, context);
        let drop = pop_item!(self, drop, Drop, context);
        let drops_0_built = DropsDropDropsSuffixBuilder::default()
            .drop(Box::new(drop))
            .drops_suffix(Box::new(drops_suffix))
            .build()
            .into_diagnostic()?;
        let drops_0_built = Drops::DropDropsSuffix(drops_0_built);
        // Calling user action here
        self.user_grammar.drops(&drops_0_built)?;
        self.push(ASTType::Drops(drops_0_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// DropsSuffix: DropsList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn drops_suffix_0(
        &mut self,
        _drops_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list = pop_and_reverse_item!(self, drops_list, DropsList, context);
        let drops_suffix_0_built = DropsSuffixDropsListBuilder::default()
            .drops_list(drops_list)
            .build()
            .into_diagnostic()?;
        let drops_suffix_0_built = DropsSuffix::DropsList(drops_suffix_0_built);
        self.push(ASTType::DropsSuffix(drops_suffix_0_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Drops: FiveAttribute DropsList0 /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn drops_1(
        &mut self,
        _five_attribute: &ParseTreeStackEntry<'t>,
        _drops_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list0 = pop_and_reverse_item!(self, drops_list0, DropsList0, context);
        let five_attribute = pop_item!(self, five_attribute, FiveAttribute, context);
        let drops_1_built = DropsFiveAttributeDropsList0Builder::default()
            .five_attribute(Box::new(five_attribute))
            .drops_list0(drops_list0)
            .build()
            .into_diagnostic()?;
        let drops_1_built = Drops::FiveAttributeDropsList0(drops_1_built);
        // Calling user action here
        self.user_grammar.drops(&drops_1_built)?;
        self.push(ASTType::Drops(drops_1_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// DropsSuffix: And Drop;
    ///
    #[parol_runtime::function_name::named]
    fn drops_suffix_1(
        &mut self,
        _and: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop = pop_item!(self, drop, Drop, context);
        let and = pop_item!(self, and, And, context);
        let drops_suffix_1_built = DropsSuffixAndDropBuilder::default()
            .and(Box::new(and))
            .drop(Box::new(drop))
            .build()
            .into_diagnostic()?;
        let drops_suffix_1_built = DropsSuffix::AndDrop(drops_suffix_1_built);
        self.push(ASTType::DropsSuffix(drops_suffix_1_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// DropsList /* Vec<T>::Push */: ManyDrop DropsList;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list_0(
        &mut self,
        _many_drop: &ParseTreeStackEntry<'t>,
        _drops_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut drops_list = pop_item!(self, drops_list, DropsList, context);
        let many_drop = pop_item!(self, many_drop, ManyDrop, context);
        let drops_list_0_built = DropsListBuilder::default()
            .many_drop(Box::new(many_drop))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        drops_list.push(drops_list_0_built);
        self.push(ASTType::DropsList(drops_list), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// DropsList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list_1_built = Vec::new();
        self.push(ASTType::DropsList(drops_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// DropsList0 /* Vec<T>::Push */: Plus Drop DropsList0;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list0_0(
        &mut self,
        _plus: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _drops_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut drops_list0 = pop_item!(self, drops_list0, DropsList0, context);
        let drop = pop_item!(self, drop, Drop, context);
        let plus = pop_item!(self, plus, Plus, context);
        let drops_list0_0_built = DropsList0Builder::default()
            .drop(Box::new(drop))
            .plus(Box::new(plus))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        drops_list0.push(drops_list0_0_built);
        self.push(ASTType::DropsList0(drops_list0), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// DropsList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list0_1_built = Vec::new();
        self.push(ASTType::DropsList0(drops_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// ManyDrop: Camma Drop;
    ///
    #[parol_runtime::function_name::named]
    fn many_drop_0(
        &mut self,
        _camma: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop = pop_item!(self, drop, Drop, context);
        let camma = pop_item!(self, camma, Camma, context);
        let many_drop_0_built = ManyDropCammaDropBuilder::default()
            .camma(Box::new(camma))
            .drop(Box::new(drop))
            .build()
            .into_diagnostic()?;
        let many_drop_0_built = ManyDrop::CammaDrop(many_drop_0_built);
        // Calling user action here
        self.user_grammar.many_drop(&many_drop_0_built)?;
        self.push(ASTType::ManyDrop(many_drop_0_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// ManyDrop: Plus Drop;
    ///
    #[parol_runtime::function_name::named]
    fn many_drop_1(
        &mut self,
        _plus: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop = pop_item!(self, drop, Drop, context);
        let plus = pop_item!(self, plus, Plus, context);
        let many_drop_1_built = ManyDropPlusDropBuilder::default()
            .plus(Box::new(plus))
            .drop(Box::new(drop))
            .build()
            .into_diagnostic()?;
        let many_drop_1_built = ManyDrop::PlusDrop(many_drop_1_built);
        // Calling user action here
        self.user_grammar.many_drop(&many_drop_1_built)?;
        self.push(ASTType::ManyDrop(many_drop_1_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// AllDrops: WordAll WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn all_drops(
        &mut self,
        _word_all: &ParseTreeStackEntry<'t>,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let word_all = pop_item!(self, word_all, WordAll, context);
        let all_drops_built = AllDropsBuilder::default()
            .word_all(Box::new(word_all))
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.all_drops(&all_drops_built)?;
        self.push(ASTType::AllDrops(all_drops_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// FiveAttribute: WordFiveAttribute FiveAttributeOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn five_attribute(
        &mut self,
        _word_five_attribute: &ParseTreeStackEntry<'t>,
        _five_attribute_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let five_attribute_opt = pop_item!(self, five_attribute_opt, FiveAttributeOpt, context);
        let word_five_attribute = pop_item!(self, word_five_attribute, WordFiveAttribute, context);
        let five_attribute_built = FiveAttributeBuilder::default()
            .word_five_attribute(Box::new(word_five_attribute))
            .five_attribute_opt(five_attribute_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.five_attribute(&five_attribute_built)?;
        self.push(ASTType::FiveAttribute(five_attribute_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// FiveAttributeOpt /* Option<T>::Some */: WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn five_attribute_opt_0(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let five_attribute_opt_0_built = FiveAttributeOptBuilder::default()
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FiveAttributeOpt(Some(Box::new(five_attribute_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// FiveAttributeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn five_attribute_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FiveAttributeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// Quantity: PosInt WordCount QuantityOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn quantity(
        &mut self,
        _pos_int: &ParseTreeStackEntry<'t>,
        _word_count: &ParseTreeStackEntry<'t>,
        _quantity_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quantity_opt = pop_item!(self, quantity_opt, QuantityOpt, context);
        let word_count = pop_item!(self, word_count, WordCount, context);
        let pos_int = pop_item!(self, pos_int, PosInt, context);
        let quantity_built = QuantityBuilder::default()
            .pos_int(Box::new(pos_int))
            .word_count(Box::new(word_count))
            .quantity_opt(quantity_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.quantity(&quantity_built)?;
        self.push(ASTType::Quantity(quantity_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// QuantityOpt /* Option<T>::Some */: Each;
    ///
    #[parol_runtime::function_name::named]
    fn quantity_opt_0(
        &mut self,
        _each: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let each = pop_item!(self, each, Each, context);
        let quantity_opt_0_built = QuantityOptBuilder::default()
            .each(Box::new(each))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::QuantityOpt(Some(Box::new(quantity_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// QuantityOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn quantity_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::QuantityOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// Drop: Color DropOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn drop_0(
        &mut self,
        _color: &ParseTreeStackEntry<'t>,
        _drop_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_opt = pop_item!(self, drop_opt, DropOpt, context);
        let color = pop_item!(self, color, Color, context);
        let drop_0_built = DropColorDropOptBuilder::default()
            .color(Box::new(color))
            .drop_opt(drop_opt)
            .build()
            .into_diagnostic()?;
        let drop_0_built = Drop::ColorDropOpt(drop_0_built);
        // Calling user action here
        self.user_grammar.drop(&drop_0_built)?;
        self.push(ASTType::Drop(drop_0_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// Drop: NonColoredDrop DropOpt0 /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn drop_1(
        &mut self,
        _non_colored_drop: &ParseTreeStackEntry<'t>,
        _drop_opt0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_opt0 = pop_item!(self, drop_opt0, DropOpt0, context);
        let non_colored_drop = pop_item!(self, non_colored_drop, NonColoredDrop, context);
        let drop_1_built = DropNonColoredDropDropOpt0Builder::default()
            .non_colored_drop(Box::new(non_colored_drop))
            .drop_opt0(drop_opt0)
            .build()
            .into_diagnostic()?;
        let drop_1_built = Drop::NonColoredDropDropOpt0(drop_1_built);
        // Calling user action here
        self.user_grammar.drop(&drop_1_built)?;
        self.push(ASTType::Drop(drop_1_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// DropOpt0 /* Option<T>::Some */: WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt0_0(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let drop_opt0_0_built = DropOpt0Builder::default()
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::DropOpt0(Some(Box::new(drop_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// DropOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// DropOpt /* Option<T>::Some */: WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt_0(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let drop_opt_0_built = DropOptBuilder::default()
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        self.push(ASTType::DropOpt(Some(Box::new(drop_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// DropOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// NonColoredDrop: Recovery;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_0(
        &mut self,
        _recovery: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let recovery = pop_item!(self, recovery, Recovery, context);
        let non_colored_drop_0_built = NonColoredDropRecoveryBuilder::default()
            .recovery(Box::new(recovery))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_0_built = NonColoredDrop::Recovery(non_colored_drop_0_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_0_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_0_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// NonColoredDrop: Disturb;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_1(
        &mut self,
        _disturb: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disturb = pop_item!(self, disturb, Disturb, context);
        let non_colored_drop_1_built = NonColoredDropDisturbBuilder::default()
            .disturb(Box::new(disturb))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_1_built = NonColoredDrop::Disturb(non_colored_drop_1_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_1_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_1_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// NonColoredDrop: Bomb;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_2(
        &mut self,
        _bomb: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bomb = pop_item!(self, bomb, Bomb, context);
        let non_colored_drop_2_built = NonColoredDropBombBuilder::default()
            .bomb(Box::new(bomb))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_2_built = NonColoredDrop::Bomb(non_colored_drop_2_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_2_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_2_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// NonColoredDrop: Poison;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_3(
        &mut self,
        _poison: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let poison = pop_item!(self, poison, Poison, context);
        let non_colored_drop_3_built = NonColoredDropPoisonBuilder::default()
            .poison(Box::new(poison))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_3_built = NonColoredDrop::Poison(non_colored_drop_3_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_3_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_3_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// NonColoredDrop: DeadlyPoison;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_4(
        &mut self,
        _deadly_poison: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let deadly_poison = pop_item!(self, deadly_poison, DeadlyPoison, context);
        let non_colored_drop_4_built = NonColoredDropDeadlyPoisonBuilder::default()
            .deadly_poison(Box::new(deadly_poison))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_4_built = NonColoredDrop::DeadlyPoison(non_colored_drop_4_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_4_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_4_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// Color: Fire;
    ///
    #[parol_runtime::function_name::named]
    fn color_0(
        &mut self,
        _fire: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fire = pop_item!(self, fire, Fire, context);
        let color_0_built = ColorFireBuilder::default()
            .fire(Box::new(fire))
            .build()
            .into_diagnostic()?;
        let color_0_built = Color::Fire(color_0_built);
        // Calling user action here
        self.user_grammar.color(&color_0_built)?;
        self.push(ASTType::Color(color_0_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// Color: Water;
    ///
    #[parol_runtime::function_name::named]
    fn color_1(
        &mut self,
        _water: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let water = pop_item!(self, water, Water, context);
        let color_1_built = ColorWaterBuilder::default()
            .water(Box::new(water))
            .build()
            .into_diagnostic()?;
        let color_1_built = Color::Water(color_1_built);
        // Calling user action here
        self.user_grammar.color(&color_1_built)?;
        self.push(ASTType::Color(color_1_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// Color: Wood;
    ///
    #[parol_runtime::function_name::named]
    fn color_2(
        &mut self,
        _wood: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let wood = pop_item!(self, wood, Wood, context);
        let color_2_built = ColorWoodBuilder::default()
            .wood(Box::new(wood))
            .build()
            .into_diagnostic()?;
        let color_2_built = Color::Wood(color_2_built);
        // Calling user action here
        self.user_grammar.color(&color_2_built)?;
        self.push(ASTType::Color(color_2_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// Color: Lightning;
    ///
    #[parol_runtime::function_name::named]
    fn color_3(
        &mut self,
        _lightning: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lightning = pop_item!(self, lightning, Lightning, context);
        let color_3_built = ColorLightningBuilder::default()
            .lightning(Box::new(lightning))
            .build()
            .into_diagnostic()?;
        let color_3_built = Color::Lightning(color_3_built);
        // Calling user action here
        self.user_grammar.color(&color_3_built)?;
        self.push(ASTType::Color(color_3_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// Color: Dark;
    ///
    #[parol_runtime::function_name::named]
    fn color_4(
        &mut self,
        _dark: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dark = pop_item!(self, dark, Dark, context);
        let color_4_built = ColorDarkBuilder::default()
            .dark(Box::new(dark))
            .build()
            .into_diagnostic()?;
        let color_4_built = Color::Dark(color_4_built);
        // Calling user action here
        self.user_grammar.color(&color_4_built)?;
        self.push(ASTType::Color(color_4_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// RandomSuffix: WordRandom So;
    ///
    #[parol_runtime::function_name::named]
    fn random_suffix(
        &mut self,
        _word_random: &ParseTreeStackEntry<'t>,
        _so: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let so = pop_item!(self, so, So, context);
        let word_random = pop_item!(self, word_random, WordRandom, context);
        let random_suffix_built = RandomSuffixBuilder::default()
            .word_random(Box::new(word_random))
            .so(Box::new(so))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.random_suffix(&random_suffix_built)?;
        self.push(ASTType::RandomSuffix(random_suffix_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// Fire: '火';
    ///
    #[parol_runtime::function_name::named]
    fn fire(
        &mut self,
        fire: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fire = fire.token(parse_tree)?.clone();
        let fire_built = FireBuilder::default()
            .fire(fire)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.fire(&fire_built)?;
        self.push(ASTType::Fire(fire_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// Water: '水';
    ///
    #[parol_runtime::function_name::named]
    fn water(
        &mut self,
        water: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let water = water.token(parse_tree)?.clone();
        let water_built = WaterBuilder::default()
            .water(water)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.water(&water_built)?;
        self.push(ASTType::Water(water_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// Wood: '木';
    ///
    #[parol_runtime::function_name::named]
    fn wood(
        &mut self,
        wood: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let wood = wood.token(parse_tree)?.clone();
        let wood_built = WoodBuilder::default()
            .wood(wood)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.wood(&wood_built)?;
        self.push(ASTType::Wood(wood_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// Lightning: '光';
    ///
    #[parol_runtime::function_name::named]
    fn lightning(
        &mut self,
        lightning: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lightning = lightning.token(parse_tree)?.clone();
        let lightning_built = LightningBuilder::default()
            .lightning(lightning)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.lightning(&lightning_built)?;
        self.push(ASTType::Lightning(lightning_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// Dark: '闇';
    ///
    #[parol_runtime::function_name::named]
    fn dark(
        &mut self,
        dark: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dark = dark.token(parse_tree)?.clone();
        let dark_built = DarkBuilder::default()
            .dark(dark)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dark(&dark_built)?;
        self.push(ASTType::Dark(dark_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// Recovery: '回復';
    ///
    #[parol_runtime::function_name::named]
    fn recovery(
        &mut self,
        recovery: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let recovery = recovery.token(parse_tree)?.clone();
        let recovery_built = RecoveryBuilder::default()
            .recovery(recovery)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.recovery(&recovery_built)?;
        self.push(ASTType::Recovery(recovery_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// Disturb: 'お邪魔';
    ///
    #[parol_runtime::function_name::named]
    fn disturb(
        &mut self,
        disturb: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disturb = disturb.token(parse_tree)?.clone();
        let disturb_built = DisturbBuilder::default()
            .disturb(disturb)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.disturb(&disturb_built)?;
        self.push(ASTType::Disturb(disturb_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// Bomb: '爆弾';
    ///
    #[parol_runtime::function_name::named]
    fn bomb(
        &mut self,
        bomb: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bomb = bomb.token(parse_tree)?.clone();
        let bomb_built = BombBuilder::default()
            .bomb(bomb)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bomb(&bomb_built)?;
        self.push(ASTType::Bomb(bomb_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// DeadlyPoison: '猛毒';
    ///
    #[parol_runtime::function_name::named]
    fn deadly_poison(
        &mut self,
        deadly_poison: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let deadly_poison = deadly_poison.token(parse_tree)?.clone();
        let deadly_poison_built = DeadlyPoisonBuilder::default()
            .deadly_poison(deadly_poison)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.deadly_poison(&deadly_poison_built)?;
        self.push(ASTType::DeadlyPoison(deadly_poison_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// Poison: '毒';
    ///
    #[parol_runtime::function_name::named]
    fn poison(
        &mut self,
        poison: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let poison = poison.token(parse_tree)?.clone();
        let poison_built = PoisonBuilder::default()
            .poison(poison)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.poison(&poison_built)?;
        self.push(ASTType::Poison(poison_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// WordChange: '変化';
    ///
    #[parol_runtime::function_name::named]
    fn word_change(
        &mut self,
        word_change: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_change = word_change.token(parse_tree)?.clone();
        let word_change_built = WordChangeBuilder::default()
            .word_change(word_change)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_change(&word_change_built)?;
        self.push(ASTType::WordChange(word_change_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// WordDrop: 'ドロップ';
    ///
    #[parol_runtime::function_name::named]
    fn word_drop(
        &mut self,
        word_drop: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = word_drop.token(parse_tree)?.clone();
        let word_drop_built = WordDropBuilder::default()
            .word_drop(word_drop)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_drop(&word_drop_built)?;
        self.push(ASTType::WordDrop(word_drop_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// WordAll: '全';
    ///
    #[parol_runtime::function_name::named]
    fn word_all(
        &mut self,
        word_all: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_all = word_all.token(parse_tree)?.clone();
        let word_all_built = WordAllBuilder::default()
            .word_all(word_all)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_all(&word_all_built)?;
        self.push(ASTType::WordAll(word_all_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// WordFiveAttribute: '5属性';
    ///
    #[parol_runtime::function_name::named]
    fn word_five_attribute(
        &mut self,
        word_five_attribute: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_five_attribute = word_five_attribute.token(parse_tree)?.clone();
        let word_five_attribute_built = WordFiveAttributeBuilder::default()
            .word_five_attribute(word_five_attribute)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .word_five_attribute(&word_five_attribute_built)?;
        self.push(
            ASTType::WordFiveAttribute(word_five_attribute_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// WordRandom: 'ランダム';
    ///
    #[parol_runtime::function_name::named]
    fn word_random(
        &mut self,
        word_random: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_random = word_random.token(parse_tree)?.clone();
        let word_random_built = WordRandomBuilder::default()
            .word_random(word_random)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_random(&word_random_built)?;
        self.push(ASTType::WordRandom(word_random_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// WordReplace: '入れ替える';
    ///
    #[parol_runtime::function_name::named]
    fn word_replace(
        &mut self,
        word_replace: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_replace = word_replace.token(parse_tree)?.clone();
        let word_replace_built = WordReplaceBuilder::default()
            .word_replace(word_replace)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_replace(&word_replace_built)?;
        self.push(ASTType::WordReplace(word_replace_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// WordCount: '個';
    ///
    #[parol_runtime::function_name::named]
    fn word_count(
        &mut self,
        word_count: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_count = word_count.token(parse_tree)?.clone();
        let word_count_built = WordCountBuilder::default()
            .word_count(word_count)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_count(&word_count_built)?;
        self.push(ASTType::WordCount(word_count_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// WordGen: '生成';
    ///
    #[parol_runtime::function_name::named]
    fn word_gen(
        &mut self,
        word_gen: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_gen = word_gen.token(parse_tree)?.clone();
        let word_gen_built = WordGenBuilder::default()
            .word_gen(word_gen)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_gen(&word_gen_built)?;
        self.push(ASTType::WordGen(word_gen_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// WordOther: '以外';
    ///
    #[parol_runtime::function_name::named]
    fn word_other(
        &mut self,
        word_other: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_other = word_other.token(parse_tree)?.clone();
        let word_other_built = WordOtherBuilder::default()
            .word_other(word_other)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_other(&word_other_built)?;
        self.push(ASTType::WordOther(word_other_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// Wo: 'を';
    ///
    #[parol_runtime::function_name::named]
    fn wo(
        &mut self,
        wo: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let wo = wo.token(parse_tree)?.clone();
        let wo_built = WoBuilder::default().wo(wo).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.wo(&wo_built)?;
        self.push(ASTType::Wo(wo_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// Ni: 'に';
    ///
    #[parol_runtime::function_name::named]
    fn ni(
        &mut self,
        ni: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ni = ni.token(parse_tree)?.clone();
        let ni_built = NiBuilder::default().ni(ni).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ni(&ni_built)?;
        self.push(ASTType::Ni(ni_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// So: 'で';
    ///
    #[parol_runtime::function_name::named]
    fn so(
        &mut self,
        so: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let so = so.token(parse_tree)?.clone();
        let so_built = SoBuilder::default().so(so).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.so(&so_built)?;
        self.push(ASTType::So(so_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// And: 'と';
    ///
    #[parol_runtime::function_name::named]
    fn and(
        &mut self,
        and: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let and = and.token(parse_tree)?.clone();
        let and_built = AndBuilder::default().and(and).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.and(&and_built)?;
        self.push(ASTType::And(and_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// Each: 'ずつ';
    ///
    #[parol_runtime::function_name::named]
    fn each(
        &mut self,
        each: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let each = each.token(parse_tree)?.clone();
        let each_built = EachBuilder::default()
            .each(each)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.each(&each_built)?;
        self.push(ASTType::Each(each_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// From: 'から';
    ///
    #[parol_runtime::function_name::named]
    fn from(
        &mut self,
        from: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let from = from.token(parse_tree)?.clone();
        let from_built = FromBuilder::default()
            .from(from)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.from(&from_built)?;
        self.push(ASTType::From(from_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// Plus: '+';
    ///
    #[parol_runtime::function_name::named]
    fn plus(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token(parse_tree)?.clone();
        let plus_built = PlusBuilder::default()
            .plus(plus)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(&plus_built)?;
        self.push(ASTType::Plus(plus_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// Camma: '、';
    ///
    #[parol_runtime::function_name::named]
    fn camma(
        &mut self,
        camma: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let camma = camma.token(parse_tree)?.clone();
        let camma_built = CammaBuilder::default()
            .camma(camma)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.camma(&camma_built)?;
        self.push(ASTType::Camma(camma_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// Period: '。';
    ///
    #[parol_runtime::function_name::named]
    fn period(
        &mut self,
        period: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let period = period.token(parse_tree)?.clone();
        let period_built = PeriodBuilder::default()
            .period(period)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.period(&period_built)?;
        self.push(ASTType::Period(period_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// PosInt: "[1-9]([0-9])*";
    ///
    #[parol_runtime::function_name::named]
    fn pos_int(
        &mut self,
        pos_int: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pos_int = pos_int.token(parse_tree)?.clone();
        let pos_int_built = PosIntBuilder::default()
            .pos_int(pos_int)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.pos_int(&pos_int_built)?;
        self.push(ASTType::PosInt(pos_int_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for SkillGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item SkillGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.skill_lines(&children[0], &children[1], parse_tree),
            1 => self.line_0(&children[0], parse_tree),
            2 => self.line_1(&children[0], parse_tree),
            3 => self.line_2(&children[0], parse_tree),
            4 => self.line_3(&children[0], parse_tree),
            5 => self.change_drop_stmt_inc_gen_random_drop(&children[0], &children[1], parse_tree),
            6 => self.change_drop_stmt_inc_gen_random_drop_suffix0_0(
                &children[0],
                &children[1],
                parse_tree,
            ),
            7 => self.change_drop_stmt_inc_gen_random_drop_suffix0_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            8 => self.change_drop_stmt_inc_gen_random_drop_suffix_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            9 => self.change_drop_stmt_inc_gen_random_drop_suffix_1(
                &children[0],
                &children[1],
                parse_tree,
            ),
            10 => self.change_drop_stmt_inc_gen_random_drop_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            11 => self.change_drop_stmt_inc_gen_random_drop_list_1(parse_tree),
            12 => self.change_all_of_borad_stmt(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            13 => self.drop_refresh_stmt(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            14 => self.change_drop_block_other_first(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            15 => self.gen_random_drop_stmt1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            16 => self.drops_0(&children[0], &children[1], parse_tree),
            17 => self.drops_suffix_0(&children[0], parse_tree),
            18 => self.drops_1(&children[0], &children[1], parse_tree),
            19 => self.drops_suffix_1(&children[0], &children[1], parse_tree),
            20 => self.drops_list_0(&children[0], &children[1], parse_tree),
            21 => self.drops_list_1(parse_tree),
            22 => self.drops_list0_0(&children[0], &children[1], &children[2], parse_tree),
            23 => self.drops_list0_1(parse_tree),
            24 => self.many_drop_0(&children[0], &children[1], parse_tree),
            25 => self.many_drop_1(&children[0], &children[1], parse_tree),
            26 => self.all_drops(&children[0], &children[1], parse_tree),
            27 => self.five_attribute(&children[0], &children[1], parse_tree),
            28 => self.five_attribute_opt_0(&children[0], parse_tree),
            29 => self.five_attribute_opt_1(parse_tree),
            30 => self.quantity(&children[0], &children[1], &children[2], parse_tree),
            31 => self.quantity_opt_0(&children[0], parse_tree),
            32 => self.quantity_opt_1(parse_tree),
            33 => self.drop_0(&children[0], &children[1], parse_tree),
            34 => self.drop_1(&children[0], &children[1], parse_tree),
            35 => self.drop_opt0_0(&children[0], parse_tree),
            36 => self.drop_opt0_1(parse_tree),
            37 => self.drop_opt_0(&children[0], parse_tree),
            38 => self.drop_opt_1(parse_tree),
            39 => self.non_colored_drop_0(&children[0], parse_tree),
            40 => self.non_colored_drop_1(&children[0], parse_tree),
            41 => self.non_colored_drop_2(&children[0], parse_tree),
            42 => self.non_colored_drop_3(&children[0], parse_tree),
            43 => self.non_colored_drop_4(&children[0], parse_tree),
            44 => self.color_0(&children[0], parse_tree),
            45 => self.color_1(&children[0], parse_tree),
            46 => self.color_2(&children[0], parse_tree),
            47 => self.color_3(&children[0], parse_tree),
            48 => self.color_4(&children[0], parse_tree),
            49 => self.random_suffix(&children[0], &children[1], parse_tree),
            50 => self.fire(&children[0], parse_tree),
            51 => self.water(&children[0], parse_tree),
            52 => self.wood(&children[0], parse_tree),
            53 => self.lightning(&children[0], parse_tree),
            54 => self.dark(&children[0], parse_tree),
            55 => self.recovery(&children[0], parse_tree),
            56 => self.disturb(&children[0], parse_tree),
            57 => self.bomb(&children[0], parse_tree),
            58 => self.deadly_poison(&children[0], parse_tree),
            59 => self.poison(&children[0], parse_tree),
            60 => self.word_change(&children[0], parse_tree),
            61 => self.word_drop(&children[0], parse_tree),
            62 => self.word_all(&children[0], parse_tree),
            63 => self.word_five_attribute(&children[0], parse_tree),
            64 => self.word_random(&children[0], parse_tree),
            65 => self.word_replace(&children[0], parse_tree),
            66 => self.word_count(&children[0], parse_tree),
            67 => self.word_gen(&children[0], parse_tree),
            68 => self.word_other(&children[0], parse_tree),
            69 => self.wo(&children[0], parse_tree),
            70 => self.ni(&children[0], parse_tree),
            71 => self.so(&children[0], parse_tree),
            72 => self.and(&children[0], parse_tree),
            73 => self.each(&children[0], parse_tree),
            74 => self.from(&children[0], parse_tree),
            75 => self.plus(&children[0], parse_tree),
            76 => self.camma(&children[0], parse_tree),
            77 => self.period(&children[0], parse_tree),
            78 => self.pos_int(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
