// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use derive_builder::Builder;
use parol_runtime::id_tree::Tree;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
#[allow(unused_imports)]
use parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait SkillGrammarTrait<'t> {
    /// Semantic action for non-terminal 'SkillLines'
    fn skill_lines(&mut self, _arg: &SkillLines<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Line'
    fn line(&mut self, _arg: &Line<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ChangeDropStmt'
    fn change_drop_stmt(&mut self, _arg: &ChangeDropStmt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ChangeAllOfBoradStmt'
    fn change_all_of_borad_stmt(&mut self, _arg: &ChangeAllOfBoradStmt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DropRefreshStmt'
    fn drop_refresh_stmt(&mut self, _arg: &DropRefreshStmt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ChangeDropBlock'
    fn change_drop_block(&mut self, _arg: &ChangeDropBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ChangeAllOfBoradBlock'
    fn change_all_of_borad_block(&mut self, _arg: &ChangeAllOfBoradBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Drops'
    fn drops(&mut self, _arg: &Drops<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ManyDrop'
    fn many_drop(&mut self, _arg: &ManyDrop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllDrops'
    fn all_drops(&mut self, _arg: &AllDrops<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FiveAttribute'
    fn five_attribute(&mut self, _arg: &FiveAttribute<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Drop'
    fn drop(&mut self, _arg: &Drop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NonColoredDrop'
    fn non_colored_drop(&mut self, _arg: &NonColoredDrop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Color'
    fn color(&mut self, _arg: &Color<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Fire'
    fn fire(&mut self, _arg: &Fire<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Water'
    fn water(&mut self, _arg: &Water<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Wood'
    fn wood(&mut self, _arg: &Wood<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Lightning'
    fn lightning(&mut self, _arg: &Lightning<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dark'
    fn dark(&mut self, _arg: &Dark<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Recovery'
    fn recovery(&mut self, _arg: &Recovery<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Disturb'
    fn disturb(&mut self, _arg: &Disturb<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bomb'
    fn bomb(&mut self, _arg: &Bomb<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Poison'
    fn poison(&mut self, _arg: &Poison<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DeadlyPoison'
    fn deadly_poison(&mut self, _arg: &DeadlyPoison<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordChange'
    fn word_change(&mut self, _arg: &WordChange<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordDrop'
    fn word_drop(&mut self, _arg: &WordDrop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordAll'
    fn word_all(&mut self, _arg: &WordAll<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordFiveAttribute'
    fn word_five_attribute(&mut self, _arg: &WordFiveAttribute<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordRandom'
    fn word_random(&mut self, _arg: &WordRandom<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordReplace'
    fn word_replace(&mut self, _arg: &WordReplace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Wo'
    fn wo(&mut self, _arg: &Wo<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ni'
    fn ni(&mut self, _arg: &Ni<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'So'
    fn so(&mut self, _arg: &So<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Camma'
    fn camma(&mut self, _arg: &Camma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Period'
    fn period(&mut self, _arg: &Period<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 1
///
/// Line: ChangeDropStmt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct LineChangeDropStmt<'t> {
    pub change_drop_stmt: Box<ChangeDropStmt<'t>>,
}

///
/// Type derived for production 2
///
/// Line: ChangeAllOfBoradStmt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct LineChangeAllOfBoradStmt<'t> {
    pub change_all_of_borad_stmt: Box<ChangeAllOfBoradStmt<'t>>,
}

///
/// Type derived for production 3
///
/// Line: DropRefreshStmt;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct LineDropRefreshStmt<'t> {
    pub drop_refresh_stmt: Box<DropRefreshStmt<'t>>,
}

///
/// Type derived for production 11
///
/// Drops: Drop DropsList /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsDropDropsList<'t> {
    pub drop: Box<Drop<'t>>,
    pub drops_list: Vec<DropsList<'t>>,
}

///
/// Type derived for production 14
///
/// Drops: FiveAttribute DropsList0 /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsFiveAttributeDropsList0<'t> {
    pub five_attribute: Box<FiveAttribute<'t>>,
    pub drops_list0: Vec<DropsList0<'t>>,
}

///
/// Type derived for production 17
///
/// ManyDrop: Camma Drop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ManyDropCammaDrop<'t> {
    pub camma: Box<Camma<'t>>,
    pub drop: Box<Drop<'t>>,
}

///
/// Type derived for production 18
///
/// ManyDrop: Plus Drop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ManyDropPlusDrop<'t> {
    pub plus: Box<Plus<'t>>,
    pub drop: Box<Drop<'t>>,
}

///
/// Type derived for production 23
///
/// Drop: Color DropOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropColorDropOpt<'t> {
    pub color: Box<Color<'t>>,
    pub drop_opt: Option<Box<DropOpt<'t>>>,
}

///
/// Type derived for production 24
///
/// Drop: NonColoredDrop DropOpt0 /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropNonColoredDropDropOpt0<'t> {
    pub non_colored_drop: Box<NonColoredDrop<'t>>,
    pub drop_opt0: Option<Box<DropOpt0<'t>>>,
}

///
/// Type derived for production 29
///
/// NonColoredDrop: Recovery;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropRecovery<'t> {
    pub recovery: Box<Recovery<'t>>,
}

///
/// Type derived for production 30
///
/// NonColoredDrop: Disturb;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropDisturb<'t> {
    pub disturb: Box<Disturb<'t>>,
}

///
/// Type derived for production 31
///
/// NonColoredDrop: Bomb;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropBomb<'t> {
    pub bomb: Box<Bomb<'t>>,
}

///
/// Type derived for production 32
///
/// NonColoredDrop: Poison;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropPoison<'t> {
    pub poison: Box<Poison<'t>>,
}

///
/// Type derived for production 33
///
/// NonColoredDrop: DeadlyPoison;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct NonColoredDropDeadlyPoison<'t> {
    pub deadly_poison: Box<DeadlyPoison<'t>>,
}

///
/// Type derived for production 34
///
/// Color: Fire;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorFire<'t> {
    pub fire: Box<Fire<'t>>,
}

///
/// Type derived for production 35
///
/// Color: Water;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorWater<'t> {
    pub water: Box<Water<'t>>,
}

///
/// Type derived for production 36
///
/// Color: Wood;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorWood<'t> {
    pub wood: Box<Wood<'t>>,
}

///
/// Type derived for production 37
///
/// Color: Lightning;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorLightning<'t> {
    pub lightning: Box<Lightning<'t>>,
}

///
/// Type derived for production 38
///
/// Color: Dark;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ColorDark<'t> {
    pub dark: Box<Dark<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AllDrops
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct AllDrops<'t> {
    pub word_all: Box<WordAll<'t>>,
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal Bomb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Bomb<'t> {
    pub bomb: Token<'t>, /* 爆弾 */
}

///
/// Type derived for non-terminal Camma
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Camma<'t> {
    pub camma: Token<'t>, /* 、 */
}

///
/// Type derived for non-terminal ChangeAllOfBoradBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeAllOfBoradBlock<'t> {
    pub drops: Box<Drops<'t>>,
}

///
/// Type derived for non-terminal ChangeAllOfBoradStmt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeAllOfBoradStmt<'t> {
    pub all_drops: Box<AllDrops<'t>>,
    pub wo: Box<Wo<'t>>,
    pub change_all_of_borad_block: Box<ChangeAllOfBoradBlock<'t>>,
    pub ni: Box<Ni<'t>>,
    pub word_change: Box<WordChange<'t>>,
}

///
/// Type derived for non-terminal ChangeDropBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropBlock<'t> {
    pub drops: Box<Drops<'t>>,
    pub wo: Box<Wo<'t>>,
    pub drop: Box<Drop<'t>>,
    pub ni: Box<Ni<'t>>,
}

///
/// Type derived for non-terminal ChangeDropStmt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropStmt<'t> {
    pub change_drop_block: Box<ChangeDropBlock<'t>>,
    pub change_drop_stmt_list: Vec<ChangeDropStmtList<'t>>,
    pub word_change: Box<WordChange<'t>>,
}

///
/// Type derived for non-terminal ChangeDropStmtList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct ChangeDropStmtList<'t> {
    pub camma: Box<Camma<'t>>,
    pub change_drop_block: Box<ChangeDropBlock<'t>>,
}

///
/// Type derived for non-terminal Color
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Color<'t> {
    Fire(ColorFire<'t>),
    Water(ColorWater<'t>),
    Wood(ColorWood<'t>),
    Lightning(ColorLightning<'t>),
    Dark(ColorDark<'t>),
}

///
/// Type derived for non-terminal Dark
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Dark<'t> {
    pub dark: Token<'t>, /* 闇 */
}

///
/// Type derived for non-terminal DeadlyPoison
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DeadlyPoison<'t> {
    pub deadly_poison: Token<'t>, /* 猛毒 */
}

///
/// Type derived for non-terminal Disturb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Disturb<'t> {
    pub disturb: Token<'t>, /* お邪魔 */
}

///
/// Type derived for non-terminal Drop
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Drop<'t> {
    ColorDropOpt(DropColorDropOpt<'t>),
    NonColoredDropDropOpt0(DropNonColoredDropDropOpt0<'t>),
}

///
/// Type derived for non-terminal DropOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropOpt<'t> {
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal DropOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropOpt0<'t> {
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal DropRefreshStmt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropRefreshStmt<'t> {
    pub word_random: Box<WordRandom<'t>>,
    pub so: Box<So<'t>>,
    pub word_drop: Box<WordDrop<'t>>,
    pub wo: Box<Wo<'t>>,
    pub word_replace: Box<WordReplace<'t>>,
}

///
/// Type derived for non-terminal Drops
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Drops<'t> {
    DropDropsList(DropsDropDropsList<'t>),
    FiveAttributeDropsList0(DropsFiveAttributeDropsList0<'t>),
}

///
/// Type derived for non-terminal DropsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsList<'t> {
    pub many_drop: Box<ManyDrop<'t>>,
}

///
/// Type derived for non-terminal DropsList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct DropsList0<'t> {
    pub many_drop: Box<ManyDrop<'t>>,
}

///
/// Type derived for non-terminal Fire
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Fire<'t> {
    pub fire: Token<'t>, /* 火 */
}

///
/// Type derived for non-terminal FiveAttribute
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct FiveAttribute<'t> {
    pub word_five_attribute: Box<WordFiveAttribute<'t>>,
    pub five_attribute_opt: Option<Box<FiveAttributeOpt<'t>>>,
}

///
/// Type derived for non-terminal FiveAttributeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct FiveAttributeOpt<'t> {
    pub word_drop: Box<WordDrop<'t>>,
}

///
/// Type derived for non-terminal Lightning
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Lightning<'t> {
    pub lightning: Token<'t>, /* 光 */
}

///
/// Type derived for non-terminal Line
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Line<'t> {
    ChangeDropStmt(LineChangeDropStmt<'t>),
    ChangeAllOfBoradStmt(LineChangeAllOfBoradStmt<'t>),
    DropRefreshStmt(LineDropRefreshStmt<'t>),
}

///
/// Type derived for non-terminal ManyDrop
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ManyDrop<'t> {
    CammaDrop(ManyDropCammaDrop<'t>),
    PlusDrop(ManyDropPlusDrop<'t>),
}

///
/// Type derived for non-terminal Ni
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Ni<'t> {
    pub ni: Token<'t>, /* に */
}

///
/// Type derived for non-terminal NonColoredDrop
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum NonColoredDrop<'t> {
    Recovery(NonColoredDropRecovery<'t>),
    Disturb(NonColoredDropDisturb<'t>),
    Bomb(NonColoredDropBomb<'t>),
    Poison(NonColoredDropPoison<'t>),
    DeadlyPoison(NonColoredDropDeadlyPoison<'t>),
}

///
/// Type derived for non-terminal Period
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Period<'t> {
    pub period: Token<'t>, /* 。 */
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Plus<'t> {
    pub plus: Token<'t>, /* \+ */
}

///
/// Type derived for non-terminal Poison
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Poison<'t> {
    pub poison: Token<'t>, /* 毒 */
}

///
/// Type derived for non-terminal Recovery
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Recovery<'t> {
    pub recovery: Token<'t>, /* 回復 */
}

///
/// Type derived for non-terminal SkillLines
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct SkillLines<'t> {
    pub line: Box<Line<'t>>,
    pub period: Box<Period<'t>>,
}

///
/// Type derived for non-terminal So
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct So<'t> {
    pub so: Token<'t>, /* で */
}

///
/// Type derived for non-terminal Water
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Water<'t> {
    pub water: Token<'t>, /* 水 */
}

///
/// Type derived for non-terminal Wo
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Wo<'t> {
    pub wo: Token<'t>, /* を */
}

///
/// Type derived for non-terminal Wood
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct Wood<'t> {
    pub wood: Token<'t>, /* 木 */
}

///
/// Type derived for non-terminal WordAll
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordAll<'t> {
    pub word_all: Token<'t>, /* 全 */
}

///
/// Type derived for non-terminal WordChange
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordChange<'t> {
    pub word_change: Token<'t>, /* 変化 */
}

///
/// Type derived for non-terminal WordDrop
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordDrop<'t> {
    pub word_drop: Token<'t>, /* ドロップ */
}

///
/// Type derived for non-terminal WordFiveAttribute
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordFiveAttribute<'t> {
    pub word_five_attribute: Token<'t>, /* 5属性 */
}

///
/// Type derived for non-terminal WordRandom
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordRandom<'t> {
    pub word_random: Token<'t>, /* ランダム */
}

///
/// Type derived for non-terminal WordReplace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "derive_builder")]
pub struct WordReplace<'t> {
    pub word_replace: Token<'t>, /* 入れ替える */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AllDrops(AllDrops<'t>),
    Bomb(Bomb<'t>),
    Camma(Camma<'t>),
    ChangeAllOfBoradBlock(ChangeAllOfBoradBlock<'t>),
    ChangeAllOfBoradStmt(ChangeAllOfBoradStmt<'t>),
    ChangeDropBlock(ChangeDropBlock<'t>),
    ChangeDropStmt(ChangeDropStmt<'t>),
    ChangeDropStmtList(Vec<ChangeDropStmtList<'t>>),
    Color(Color<'t>),
    Dark(Dark<'t>),
    DeadlyPoison(DeadlyPoison<'t>),
    Disturb(Disturb<'t>),
    Drop(Drop<'t>),
    DropOpt(Option<Box<DropOpt<'t>>>),
    DropOpt0(Option<Box<DropOpt0<'t>>>),
    DropRefreshStmt(DropRefreshStmt<'t>),
    Drops(Drops<'t>),
    DropsList(Vec<DropsList<'t>>),
    DropsList0(Vec<DropsList0<'t>>),
    Fire(Fire<'t>),
    FiveAttribute(FiveAttribute<'t>),
    FiveAttributeOpt(Option<Box<FiveAttributeOpt<'t>>>),
    Lightning(Lightning<'t>),
    Line(Line<'t>),
    ManyDrop(ManyDrop<'t>),
    Ni(Ni<'t>),
    NonColoredDrop(NonColoredDrop<'t>),
    Period(Period<'t>),
    Plus(Plus<'t>),
    Poison(Poison<'t>),
    Recovery(Recovery<'t>),
    SkillLines(SkillLines<'t>),
    So(So<'t>),
    Water(Water<'t>),
    Wo(Wo<'t>),
    Wood(Wood<'t>),
    WordAll(WordAll<'t>),
    WordChange(WordChange<'t>),
    WordDrop(WordDrop<'t>),
    WordFiveAttribute(WordFiveAttribute<'t>),
    WordRandom(WordRandom<'t>),
    WordReplace(WordReplace<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct SkillGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn SkillGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `SkillGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> SkillGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn SkillGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// SkillLines: Line Period;
    ///
    #[parol_runtime::function_name::named]
    fn skill_lines(
        &mut self,
        _line: &ParseTreeStackEntry<'t>,
        _period: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let period = pop_item!(self, period, Period, context);
        let line = pop_item!(self, line, Line, context);
        let skill_lines_built = SkillLinesBuilder::default()
            .line(Box::new(line))
            .period(Box::new(period))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.skill_lines(&skill_lines_built)?;
        self.push(ASTType::SkillLines(skill_lines_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Line: ChangeDropStmt;
    ///
    #[parol_runtime::function_name::named]
    fn line_0(
        &mut self,
        _change_drop_stmt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_stmt = pop_item!(self, change_drop_stmt, ChangeDropStmt, context);
        let line_0_built = LineChangeDropStmtBuilder::default()
            .change_drop_stmt(Box::new(change_drop_stmt))
            .build()
            .into_diagnostic()?;
        let line_0_built = Line::ChangeDropStmt(line_0_built);
        // Calling user action here
        self.user_grammar.line(&line_0_built)?;
        self.push(ASTType::Line(line_0_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// Line: ChangeAllOfBoradStmt;
    ///
    #[parol_runtime::function_name::named]
    fn line_1(
        &mut self,
        _change_all_of_borad_stmt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_all_of_borad_stmt = pop_item!(
            self,
            change_all_of_borad_stmt,
            ChangeAllOfBoradStmt,
            context
        );
        let line_1_built = LineChangeAllOfBoradStmtBuilder::default()
            .change_all_of_borad_stmt(Box::new(change_all_of_borad_stmt))
            .build()
            .into_diagnostic()?;
        let line_1_built = Line::ChangeAllOfBoradStmt(line_1_built);
        // Calling user action here
        self.user_grammar.line(&line_1_built)?;
        self.push(ASTType::Line(line_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// Line: DropRefreshStmt;
    ///
    #[parol_runtime::function_name::named]
    fn line_2(
        &mut self,
        _drop_refresh_stmt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_refresh_stmt = pop_item!(self, drop_refresh_stmt, DropRefreshStmt, context);
        let line_2_built = LineDropRefreshStmtBuilder::default()
            .drop_refresh_stmt(Box::new(drop_refresh_stmt))
            .build()
            .into_diagnostic()?;
        let line_2_built = Line::DropRefreshStmt(line_2_built);
        // Calling user action here
        self.user_grammar.line(&line_2_built)?;
        self.push(ASTType::Line(line_2_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// ChangeDropStmt: ChangeDropBlock ChangeDropStmtList /* Vec */ WordChange;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt(
        &mut self,
        _change_drop_block: &ParseTreeStackEntry<'t>,
        _change_drop_stmt_list: &ParseTreeStackEntry<'t>,
        _word_change: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_change = pop_item!(self, word_change, WordChange, context);
        let change_drop_stmt_list =
            pop_and_reverse_item!(self, change_drop_stmt_list, ChangeDropStmtList, context);
        let change_drop_block = pop_item!(self, change_drop_block, ChangeDropBlock, context);
        let change_drop_stmt_built = ChangeDropStmtBuilder::default()
            .change_drop_block(Box::new(change_drop_block))
            .change_drop_stmt_list(change_drop_stmt_list)
            .word_change(Box::new(word_change))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .change_drop_stmt(&change_drop_stmt_built)?;
        self.push(ASTType::ChangeDropStmt(change_drop_stmt_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// ChangeDropStmtList /* Vec<T>::Push */: Camma ChangeDropBlock ChangeDropStmtList;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt_list_0(
        &mut self,
        _camma: &ParseTreeStackEntry<'t>,
        _change_drop_block: &ParseTreeStackEntry<'t>,
        _change_drop_stmt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut change_drop_stmt_list =
            pop_item!(self, change_drop_stmt_list, ChangeDropStmtList, context);
        let change_drop_block = pop_item!(self, change_drop_block, ChangeDropBlock, context);
        let camma = pop_item!(self, camma, Camma, context);
        let change_drop_stmt_list_0_built = ChangeDropStmtListBuilder::default()
            .change_drop_block(Box::new(change_drop_block))
            .camma(Box::new(camma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        change_drop_stmt_list.push(change_drop_stmt_list_0_built);
        self.push(ASTType::ChangeDropStmtList(change_drop_stmt_list), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// ChangeDropStmtList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_stmt_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let change_drop_stmt_list_1_built = Vec::new();
        self.push(
            ASTType::ChangeDropStmtList(change_drop_stmt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// ChangeAllOfBoradStmt: AllDrops Wo ChangeAllOfBoradBlock Ni WordChange;
    ///
    #[parol_runtime::function_name::named]
    fn change_all_of_borad_stmt(
        &mut self,
        _all_drops: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _change_all_of_borad_block: &ParseTreeStackEntry<'t>,
        _ni: &ParseTreeStackEntry<'t>,
        _word_change: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_change = pop_item!(self, word_change, WordChange, context);
        let ni = pop_item!(self, ni, Ni, context);
        let change_all_of_borad_block = pop_item!(
            self,
            change_all_of_borad_block,
            ChangeAllOfBoradBlock,
            context
        );
        let wo = pop_item!(self, wo, Wo, context);
        let all_drops = pop_item!(self, all_drops, AllDrops, context);
        let change_all_of_borad_stmt_built = ChangeAllOfBoradStmtBuilder::default()
            .all_drops(Box::new(all_drops))
            .wo(Box::new(wo))
            .change_all_of_borad_block(Box::new(change_all_of_borad_block))
            .ni(Box::new(ni))
            .word_change(Box::new(word_change))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .change_all_of_borad_stmt(&change_all_of_borad_stmt_built)?;
        self.push(
            ASTType::ChangeAllOfBoradStmt(change_all_of_borad_stmt_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// DropRefreshStmt: WordRandom So WordDrop Wo WordReplace;
    ///
    #[parol_runtime::function_name::named]
    fn drop_refresh_stmt(
        &mut self,
        _word_random: &ParseTreeStackEntry<'t>,
        _so: &ParseTreeStackEntry<'t>,
        _word_drop: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _word_replace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_replace = pop_item!(self, word_replace, WordReplace, context);
        let wo = pop_item!(self, wo, Wo, context);
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let so = pop_item!(self, so, So, context);
        let word_random = pop_item!(self, word_random, WordRandom, context);
        let drop_refresh_stmt_built = DropRefreshStmtBuilder::default()
            .word_random(Box::new(word_random))
            .so(Box::new(so))
            .word_drop(Box::new(word_drop))
            .wo(Box::new(wo))
            .word_replace(Box::new(word_replace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .drop_refresh_stmt(&drop_refresh_stmt_built)?;
        self.push(ASTType::DropRefreshStmt(drop_refresh_stmt_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// ChangeDropBlock: Drops Wo Drop Ni;
    ///
    #[parol_runtime::function_name::named]
    fn change_drop_block(
        &mut self,
        _drops: &ParseTreeStackEntry<'t>,
        _wo: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _ni: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ni = pop_item!(self, ni, Ni, context);
        let drop = pop_item!(self, drop, Drop, context);
        let wo = pop_item!(self, wo, Wo, context);
        let drops = pop_item!(self, drops, Drops, context);
        let change_drop_block_built = ChangeDropBlockBuilder::default()
            .drops(Box::new(drops))
            .wo(Box::new(wo))
            .drop(Box::new(drop))
            .ni(Box::new(ni))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .change_drop_block(&change_drop_block_built)?;
        self.push(ASTType::ChangeDropBlock(change_drop_block_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// ChangeAllOfBoradBlock: Drops;
    ///
    #[parol_runtime::function_name::named]
    fn change_all_of_borad_block(
        &mut self,
        _drops: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops = pop_item!(self, drops, Drops, context);
        let change_all_of_borad_block_built = ChangeAllOfBoradBlockBuilder::default()
            .drops(Box::new(drops))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .change_all_of_borad_block(&change_all_of_borad_block_built)?;
        self.push(
            ASTType::ChangeAllOfBoradBlock(change_all_of_borad_block_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// Drops: Drop DropsList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn drops_0(
        &mut self,
        _drop: &ParseTreeStackEntry<'t>,
        _drops_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list = pop_and_reverse_item!(self, drops_list, DropsList, context);
        let drop = pop_item!(self, drop, Drop, context);
        let drops_0_built = DropsDropDropsListBuilder::default()
            .drop(Box::new(drop))
            .drops_list(drops_list)
            .build()
            .into_diagnostic()?;
        let drops_0_built = Drops::DropDropsList(drops_0_built);
        // Calling user action here
        self.user_grammar.drops(&drops_0_built)?;
        self.push(ASTType::Drops(drops_0_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// DropsList /* Vec<T>::Push */: ManyDrop DropsList;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list_0(
        &mut self,
        _many_drop: &ParseTreeStackEntry<'t>,
        _drops_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut drops_list = pop_item!(self, drops_list, DropsList, context);
        let many_drop = pop_item!(self, many_drop, ManyDrop, context);
        let drops_list_0_built = DropsListBuilder::default()
            .many_drop(Box::new(many_drop))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        drops_list.push(drops_list_0_built);
        self.push(ASTType::DropsList(drops_list), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// DropsList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list_1_built = Vec::new();
        self.push(ASTType::DropsList(drops_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Drops: FiveAttribute DropsList0 /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn drops_1(
        &mut self,
        _five_attribute: &ParseTreeStackEntry<'t>,
        _drops_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list0 = pop_and_reverse_item!(self, drops_list0, DropsList0, context);
        let five_attribute = pop_item!(self, five_attribute, FiveAttribute, context);
        let drops_1_built = DropsFiveAttributeDropsList0Builder::default()
            .five_attribute(Box::new(five_attribute))
            .drops_list0(drops_list0)
            .build()
            .into_diagnostic()?;
        let drops_1_built = Drops::FiveAttributeDropsList0(drops_1_built);
        // Calling user action here
        self.user_grammar.drops(&drops_1_built)?;
        self.push(ASTType::Drops(drops_1_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// DropsList0 /* Vec<T>::Push */: ManyDrop DropsList0;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list0_0(
        &mut self,
        _many_drop: &ParseTreeStackEntry<'t>,
        _drops_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut drops_list0 = pop_item!(self, drops_list0, DropsList0, context);
        let many_drop = pop_item!(self, many_drop, ManyDrop, context);
        let drops_list0_0_built = DropsList0Builder::default()
            .many_drop(Box::new(many_drop))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        drops_list0.push(drops_list0_0_built);
        self.push(ASTType::DropsList0(drops_list0), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// DropsList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drops_list0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drops_list0_1_built = Vec::new();
        self.push(ASTType::DropsList0(drops_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// ManyDrop: Camma Drop;
    ///
    #[parol_runtime::function_name::named]
    fn many_drop_0(
        &mut self,
        _camma: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop = pop_item!(self, drop, Drop, context);
        let camma = pop_item!(self, camma, Camma, context);
        let many_drop_0_built = ManyDropCammaDropBuilder::default()
            .camma(Box::new(camma))
            .drop(Box::new(drop))
            .build()
            .into_diagnostic()?;
        let many_drop_0_built = ManyDrop::CammaDrop(many_drop_0_built);
        // Calling user action here
        self.user_grammar.many_drop(&many_drop_0_built)?;
        self.push(ASTType::ManyDrop(many_drop_0_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// ManyDrop: Plus Drop;
    ///
    #[parol_runtime::function_name::named]
    fn many_drop_1(
        &mut self,
        _plus: &ParseTreeStackEntry<'t>,
        _drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop = pop_item!(self, drop, Drop, context);
        let plus = pop_item!(self, plus, Plus, context);
        let many_drop_1_built = ManyDropPlusDropBuilder::default()
            .plus(Box::new(plus))
            .drop(Box::new(drop))
            .build()
            .into_diagnostic()?;
        let many_drop_1_built = ManyDrop::PlusDrop(many_drop_1_built);
        // Calling user action here
        self.user_grammar.many_drop(&many_drop_1_built)?;
        self.push(ASTType::ManyDrop(many_drop_1_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// AllDrops: WordAll WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn all_drops(
        &mut self,
        _word_all: &ParseTreeStackEntry<'t>,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let word_all = pop_item!(self, word_all, WordAll, context);
        let all_drops_built = AllDropsBuilder::default()
            .word_all(Box::new(word_all))
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.all_drops(&all_drops_built)?;
        self.push(ASTType::AllDrops(all_drops_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// FiveAttribute: WordFiveAttribute FiveAttributeOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn five_attribute(
        &mut self,
        _word_five_attribute: &ParseTreeStackEntry<'t>,
        _five_attribute_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let five_attribute_opt = pop_item!(self, five_attribute_opt, FiveAttributeOpt, context);
        let word_five_attribute = pop_item!(self, word_five_attribute, WordFiveAttribute, context);
        let five_attribute_built = FiveAttributeBuilder::default()
            .word_five_attribute(Box::new(word_five_attribute))
            .five_attribute_opt(five_attribute_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.five_attribute(&five_attribute_built)?;
        self.push(ASTType::FiveAttribute(five_attribute_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// FiveAttributeOpt /* Option<T>::Some */: WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn five_attribute_opt_0(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let five_attribute_opt_0_built = FiveAttributeOptBuilder::default()
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FiveAttributeOpt(Some(Box::new(five_attribute_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// FiveAttributeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn five_attribute_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FiveAttributeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// Drop: Color DropOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn drop_0(
        &mut self,
        _color: &ParseTreeStackEntry<'t>,
        _drop_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_opt = pop_item!(self, drop_opt, DropOpt, context);
        let color = pop_item!(self, color, Color, context);
        let drop_0_built = DropColorDropOptBuilder::default()
            .color(Box::new(color))
            .drop_opt(drop_opt)
            .build()
            .into_diagnostic()?;
        let drop_0_built = Drop::ColorDropOpt(drop_0_built);
        // Calling user action here
        self.user_grammar.drop(&drop_0_built)?;
        self.push(ASTType::Drop(drop_0_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// Drop: NonColoredDrop DropOpt0 /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn drop_1(
        &mut self,
        _non_colored_drop: &ParseTreeStackEntry<'t>,
        _drop_opt0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let drop_opt0 = pop_item!(self, drop_opt0, DropOpt0, context);
        let non_colored_drop = pop_item!(self, non_colored_drop, NonColoredDrop, context);
        let drop_1_built = DropNonColoredDropDropOpt0Builder::default()
            .non_colored_drop(Box::new(non_colored_drop))
            .drop_opt0(drop_opt0)
            .build()
            .into_diagnostic()?;
        let drop_1_built = Drop::NonColoredDropDropOpt0(drop_1_built);
        // Calling user action here
        self.user_grammar.drop(&drop_1_built)?;
        self.push(ASTType::Drop(drop_1_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// DropOpt0 /* Option<T>::Some */: WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt0_0(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let drop_opt0_0_built = DropOpt0Builder::default()
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::DropOpt0(Some(Box::new(drop_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// DropOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// DropOpt /* Option<T>::Some */: WordDrop;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt_0(
        &mut self,
        _word_drop: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = pop_item!(self, word_drop, WordDrop, context);
        let drop_opt_0_built = DropOptBuilder::default()
            .word_drop(Box::new(word_drop))
            .build()
            .into_diagnostic()?;
        self.push(ASTType::DropOpt(Some(Box::new(drop_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// DropOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn drop_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DropOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// NonColoredDrop: Recovery;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_0(
        &mut self,
        _recovery: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let recovery = pop_item!(self, recovery, Recovery, context);
        let non_colored_drop_0_built = NonColoredDropRecoveryBuilder::default()
            .recovery(Box::new(recovery))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_0_built = NonColoredDrop::Recovery(non_colored_drop_0_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_0_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_0_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// NonColoredDrop: Disturb;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_1(
        &mut self,
        _disturb: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disturb = pop_item!(self, disturb, Disturb, context);
        let non_colored_drop_1_built = NonColoredDropDisturbBuilder::default()
            .disturb(Box::new(disturb))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_1_built = NonColoredDrop::Disturb(non_colored_drop_1_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_1_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_1_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// NonColoredDrop: Bomb;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_2(
        &mut self,
        _bomb: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bomb = pop_item!(self, bomb, Bomb, context);
        let non_colored_drop_2_built = NonColoredDropBombBuilder::default()
            .bomb(Box::new(bomb))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_2_built = NonColoredDrop::Bomb(non_colored_drop_2_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_2_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_2_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// NonColoredDrop: Poison;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_3(
        &mut self,
        _poison: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let poison = pop_item!(self, poison, Poison, context);
        let non_colored_drop_3_built = NonColoredDropPoisonBuilder::default()
            .poison(Box::new(poison))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_3_built = NonColoredDrop::Poison(non_colored_drop_3_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_3_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_3_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// NonColoredDrop: DeadlyPoison;
    ///
    #[parol_runtime::function_name::named]
    fn non_colored_drop_4(
        &mut self,
        _deadly_poison: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let deadly_poison = pop_item!(self, deadly_poison, DeadlyPoison, context);
        let non_colored_drop_4_built = NonColoredDropDeadlyPoisonBuilder::default()
            .deadly_poison(Box::new(deadly_poison))
            .build()
            .into_diagnostic()?;
        let non_colored_drop_4_built = NonColoredDrop::DeadlyPoison(non_colored_drop_4_built);
        // Calling user action here
        self.user_grammar
            .non_colored_drop(&non_colored_drop_4_built)?;
        self.push(ASTType::NonColoredDrop(non_colored_drop_4_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// Color: Fire;
    ///
    #[parol_runtime::function_name::named]
    fn color_0(
        &mut self,
        _fire: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fire = pop_item!(self, fire, Fire, context);
        let color_0_built = ColorFireBuilder::default()
            .fire(Box::new(fire))
            .build()
            .into_diagnostic()?;
        let color_0_built = Color::Fire(color_0_built);
        // Calling user action here
        self.user_grammar.color(&color_0_built)?;
        self.push(ASTType::Color(color_0_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// Color: Water;
    ///
    #[parol_runtime::function_name::named]
    fn color_1(
        &mut self,
        _water: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let water = pop_item!(self, water, Water, context);
        let color_1_built = ColorWaterBuilder::default()
            .water(Box::new(water))
            .build()
            .into_diagnostic()?;
        let color_1_built = Color::Water(color_1_built);
        // Calling user action here
        self.user_grammar.color(&color_1_built)?;
        self.push(ASTType::Color(color_1_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// Color: Wood;
    ///
    #[parol_runtime::function_name::named]
    fn color_2(
        &mut self,
        _wood: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let wood = pop_item!(self, wood, Wood, context);
        let color_2_built = ColorWoodBuilder::default()
            .wood(Box::new(wood))
            .build()
            .into_diagnostic()?;
        let color_2_built = Color::Wood(color_2_built);
        // Calling user action here
        self.user_grammar.color(&color_2_built)?;
        self.push(ASTType::Color(color_2_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// Color: Lightning;
    ///
    #[parol_runtime::function_name::named]
    fn color_3(
        &mut self,
        _lightning: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lightning = pop_item!(self, lightning, Lightning, context);
        let color_3_built = ColorLightningBuilder::default()
            .lightning(Box::new(lightning))
            .build()
            .into_diagnostic()?;
        let color_3_built = Color::Lightning(color_3_built);
        // Calling user action here
        self.user_grammar.color(&color_3_built)?;
        self.push(ASTType::Color(color_3_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// Color: Dark;
    ///
    #[parol_runtime::function_name::named]
    fn color_4(
        &mut self,
        _dark: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dark = pop_item!(self, dark, Dark, context);
        let color_4_built = ColorDarkBuilder::default()
            .dark(Box::new(dark))
            .build()
            .into_diagnostic()?;
        let color_4_built = Color::Dark(color_4_built);
        // Calling user action here
        self.user_grammar.color(&color_4_built)?;
        self.push(ASTType::Color(color_4_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// Fire: "火";
    ///
    #[parol_runtime::function_name::named]
    fn fire(
        &mut self,
        fire: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fire = fire.token(parse_tree)?.clone();
        let fire_built = FireBuilder::default()
            .fire(fire)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.fire(&fire_built)?;
        self.push(ASTType::Fire(fire_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// Water: "水";
    ///
    #[parol_runtime::function_name::named]
    fn water(
        &mut self,
        water: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let water = water.token(parse_tree)?.clone();
        let water_built = WaterBuilder::default()
            .water(water)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.water(&water_built)?;
        self.push(ASTType::Water(water_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// Wood: "木";
    ///
    #[parol_runtime::function_name::named]
    fn wood(
        &mut self,
        wood: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let wood = wood.token(parse_tree)?.clone();
        let wood_built = WoodBuilder::default()
            .wood(wood)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.wood(&wood_built)?;
        self.push(ASTType::Wood(wood_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// Lightning: "光";
    ///
    #[parol_runtime::function_name::named]
    fn lightning(
        &mut self,
        lightning: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lightning = lightning.token(parse_tree)?.clone();
        let lightning_built = LightningBuilder::default()
            .lightning(lightning)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.lightning(&lightning_built)?;
        self.push(ASTType::Lightning(lightning_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// Dark: "闇";
    ///
    #[parol_runtime::function_name::named]
    fn dark(
        &mut self,
        dark: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dark = dark.token(parse_tree)?.clone();
        let dark_built = DarkBuilder::default()
            .dark(dark)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dark(&dark_built)?;
        self.push(ASTType::Dark(dark_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// Recovery: "回復";
    ///
    #[parol_runtime::function_name::named]
    fn recovery(
        &mut self,
        recovery: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let recovery = recovery.token(parse_tree)?.clone();
        let recovery_built = RecoveryBuilder::default()
            .recovery(recovery)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.recovery(&recovery_built)?;
        self.push(ASTType::Recovery(recovery_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// Disturb: "お邪魔";
    ///
    #[parol_runtime::function_name::named]
    fn disturb(
        &mut self,
        disturb: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disturb = disturb.token(parse_tree)?.clone();
        let disturb_built = DisturbBuilder::default()
            .disturb(disturb)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.disturb(&disturb_built)?;
        self.push(ASTType::Disturb(disturb_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// Bomb: "爆弾";
    ///
    #[parol_runtime::function_name::named]
    fn bomb(
        &mut self,
        bomb: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bomb = bomb.token(parse_tree)?.clone();
        let bomb_built = BombBuilder::default()
            .bomb(bomb)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bomb(&bomb_built)?;
        self.push(ASTType::Bomb(bomb_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// Poison: "毒";
    ///
    #[parol_runtime::function_name::named]
    fn poison(
        &mut self,
        poison: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let poison = poison.token(parse_tree)?.clone();
        let poison_built = PoisonBuilder::default()
            .poison(poison)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.poison(&poison_built)?;
        self.push(ASTType::Poison(poison_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// DeadlyPoison: "猛毒";
    ///
    #[parol_runtime::function_name::named]
    fn deadly_poison(
        &mut self,
        deadly_poison: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let deadly_poison = deadly_poison.token(parse_tree)?.clone();
        let deadly_poison_built = DeadlyPoisonBuilder::default()
            .deadly_poison(deadly_poison)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.deadly_poison(&deadly_poison_built)?;
        self.push(ASTType::DeadlyPoison(deadly_poison_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// WordChange: "変化";
    ///
    #[parol_runtime::function_name::named]
    fn word_change(
        &mut self,
        word_change: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_change = word_change.token(parse_tree)?.clone();
        let word_change_built = WordChangeBuilder::default()
            .word_change(word_change)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_change(&word_change_built)?;
        self.push(ASTType::WordChange(word_change_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// WordDrop: "ドロップ";
    ///
    #[parol_runtime::function_name::named]
    fn word_drop(
        &mut self,
        word_drop: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_drop = word_drop.token(parse_tree)?.clone();
        let word_drop_built = WordDropBuilder::default()
            .word_drop(word_drop)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_drop(&word_drop_built)?;
        self.push(ASTType::WordDrop(word_drop_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// WordAll: "全";
    ///
    #[parol_runtime::function_name::named]
    fn word_all(
        &mut self,
        word_all: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_all = word_all.token(parse_tree)?.clone();
        let word_all_built = WordAllBuilder::default()
            .word_all(word_all)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_all(&word_all_built)?;
        self.push(ASTType::WordAll(word_all_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// WordFiveAttribute: "5属性";
    ///
    #[parol_runtime::function_name::named]
    fn word_five_attribute(
        &mut self,
        word_five_attribute: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_five_attribute = word_five_attribute.token(parse_tree)?.clone();
        let word_five_attribute_built = WordFiveAttributeBuilder::default()
            .word_five_attribute(word_five_attribute)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .word_five_attribute(&word_five_attribute_built)?;
        self.push(
            ASTType::WordFiveAttribute(word_five_attribute_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// WordRandom: "ランダム";
    ///
    #[parol_runtime::function_name::named]
    fn word_random(
        &mut self,
        word_random: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_random = word_random.token(parse_tree)?.clone();
        let word_random_built = WordRandomBuilder::default()
            .word_random(word_random)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_random(&word_random_built)?;
        self.push(ASTType::WordRandom(word_random_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// WordReplace: "入れ替える";
    ///
    #[parol_runtime::function_name::named]
    fn word_replace(
        &mut self,
        word_replace: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_replace = word_replace.token(parse_tree)?.clone();
        let word_replace_built = WordReplaceBuilder::default()
            .word_replace(word_replace)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.word_replace(&word_replace_built)?;
        self.push(ASTType::WordReplace(word_replace_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// Wo: "を";
    ///
    #[parol_runtime::function_name::named]
    fn wo(
        &mut self,
        wo: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let wo = wo.token(parse_tree)?.clone();
        let wo_built = WoBuilder::default().wo(wo).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.wo(&wo_built)?;
        self.push(ASTType::Wo(wo_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// Ni: "に";
    ///
    #[parol_runtime::function_name::named]
    fn ni(
        &mut self,
        ni: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ni = ni.token(parse_tree)?.clone();
        let ni_built = NiBuilder::default().ni(ni).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ni(&ni_built)?;
        self.push(ASTType::Ni(ni_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// So: "で";
    ///
    #[parol_runtime::function_name::named]
    fn so(
        &mut self,
        so: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let so = so.token(parse_tree)?.clone();
        let so_built = SoBuilder::default().so(so).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.so(&so_built)?;
        self.push(ASTType::So(so_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// Plus: "\+";
    ///
    #[parol_runtime::function_name::named]
    fn plus(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token(parse_tree)?.clone();
        let plus_built = PlusBuilder::default()
            .plus(plus)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(&plus_built)?;
        self.push(ASTType::Plus(plus_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// Camma: "、";
    ///
    #[parol_runtime::function_name::named]
    fn camma(
        &mut self,
        camma: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let camma = camma.token(parse_tree)?.clone();
        let camma_built = CammaBuilder::default()
            .camma(camma)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.camma(&camma_built)?;
        self.push(ASTType::Camma(camma_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// Period: "。";
    ///
    #[parol_runtime::function_name::named]
    fn period(
        &mut self,
        period: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let period = period.token(parse_tree)?.clone();
        let period_built = PeriodBuilder::default()
            .period(period)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.period(&period_built)?;
        self.push(ASTType::Period(period_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for SkillGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item SkillGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.skill_lines(&children[0], &children[1], parse_tree),
            1 => self.line_0(&children[0], parse_tree),
            2 => self.line_1(&children[0], parse_tree),
            3 => self.line_2(&children[0], parse_tree),
            4 => self.change_drop_stmt(&children[0], &children[1], &children[2], parse_tree),
            5 => self.change_drop_stmt_list_0(&children[0], &children[1], &children[2], parse_tree),
            6 => self.change_drop_stmt_list_1(parse_tree),
            7 => self.change_all_of_borad_stmt(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            8 => self.drop_refresh_stmt(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            9 => self.change_drop_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            10 => self.change_all_of_borad_block(&children[0], parse_tree),
            11 => self.drops_0(&children[0], &children[1], parse_tree),
            12 => self.drops_list_0(&children[0], &children[1], parse_tree),
            13 => self.drops_list_1(parse_tree),
            14 => self.drops_1(&children[0], &children[1], parse_tree),
            15 => self.drops_list0_0(&children[0], &children[1], parse_tree),
            16 => self.drops_list0_1(parse_tree),
            17 => self.many_drop_0(&children[0], &children[1], parse_tree),
            18 => self.many_drop_1(&children[0], &children[1], parse_tree),
            19 => self.all_drops(&children[0], &children[1], parse_tree),
            20 => self.five_attribute(&children[0], &children[1], parse_tree),
            21 => self.five_attribute_opt_0(&children[0], parse_tree),
            22 => self.five_attribute_opt_1(parse_tree),
            23 => self.drop_0(&children[0], &children[1], parse_tree),
            24 => self.drop_1(&children[0], &children[1], parse_tree),
            25 => self.drop_opt0_0(&children[0], parse_tree),
            26 => self.drop_opt0_1(parse_tree),
            27 => self.drop_opt_0(&children[0], parse_tree),
            28 => self.drop_opt_1(parse_tree),
            29 => self.non_colored_drop_0(&children[0], parse_tree),
            30 => self.non_colored_drop_1(&children[0], parse_tree),
            31 => self.non_colored_drop_2(&children[0], parse_tree),
            32 => self.non_colored_drop_3(&children[0], parse_tree),
            33 => self.non_colored_drop_4(&children[0], parse_tree),
            34 => self.color_0(&children[0], parse_tree),
            35 => self.color_1(&children[0], parse_tree),
            36 => self.color_2(&children[0], parse_tree),
            37 => self.color_3(&children[0], parse_tree),
            38 => self.color_4(&children[0], parse_tree),
            39 => self.fire(&children[0], parse_tree),
            40 => self.water(&children[0], parse_tree),
            41 => self.wood(&children[0], parse_tree),
            42 => self.lightning(&children[0], parse_tree),
            43 => self.dark(&children[0], parse_tree),
            44 => self.recovery(&children[0], parse_tree),
            45 => self.disturb(&children[0], parse_tree),
            46 => self.bomb(&children[0], parse_tree),
            47 => self.poison(&children[0], parse_tree),
            48 => self.deadly_poison(&children[0], parse_tree),
            49 => self.word_change(&children[0], parse_tree),
            50 => self.word_drop(&children[0], parse_tree),
            51 => self.word_all(&children[0], parse_tree),
            52 => self.word_five_attribute(&children[0], parse_tree),
            53 => self.word_random(&children[0], parse_tree),
            54 => self.word_replace(&children[0], parse_tree),
            55 => self.wo(&children[0], parse_tree),
            56 => self.ni(&children[0], parse_tree),
            57 => self.so(&children[0], parse_tree),
            58 => self.plus(&children[0], parse_tree),
            59 => self.camma(&children[0], parse_tree),
            60 => self.period(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
